<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[KAIIAK]]></title>
  <subtitle><![CDATA[啦啦啦，我是卖萌的小行家]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://kaiiak.github.io//"/>
  <updated>2016-03-05T11:17:27.410Z</updated>
  <id>http://kaiiak.github.io//</id>
  
  <author>
    <name><![CDATA[Kai]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[自用vim配置文件]]></title>
    <link href="http://kaiiak.github.io/2016/03/05/personal_vimrc/"/>
    <id>http://kaiiak.github.io/2016/03/05/personal_vimrc/</id>
    <published>2016-03-05T08:49:30.000Z</published>
    <updated>2016-03-05T11:17:27.410Z</updated>
    <content type="html"><![CDATA[<h1 id="自用的vim配置文件">自用的vim配置文件</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">" 编码</span><br><span class="line">set encoding=utf-8</span><br><span class="line"></span><br><span class="line">"</span> 避免以前版本的一些bug和局限</span><br><span class="line"><span class="built_in">set</span> nocompatible</span><br><span class="line"></span><br><span class="line"><span class="string">" 逐步搜索模式，对当前键入的字符进行搜索而不必等待键入完成,/b寻找b开头的。</span><br><span class="line">set incsearch</span><br><span class="line"></span><br><span class="line">"</span>自动识别文件类型</span><br><span class="line"><span class="string">" set filetype</span><br><span class="line"></span><br><span class="line">"</span> 搜索时高亮显示找到文本</span><br><span class="line"><span class="built_in">set</span> hlsearch</span><br><span class="line"></span><br><span class="line"><span class="string">" 在Insert模式下退格键何时可以删除光标之前的字符。三项内容分别指定了Vim可以删除位于行首的空格,断行,以及开始进入Insert模式之前的位置。</span><br><span class="line">set backspace=indent,eol,start</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">"</span> 设置tab键为<span class="number">4</span>个空格，设置当行之间交错时使用<span class="number">4</span>个空格</span><br><span class="line"><span class="built_in">set</span> tabstop=<span class="number">4</span></span><br><span class="line"><span class="built_in">set</span> shiftwidth=<span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="string">" 匹配模式，左括号匹配右括号</span><br><span class="line">set showmatch</span><br><span class="line"></span><br><span class="line">"</span> 在覆盖一个文件之前备份该文件。但是对VMS系统除外,因为该系统已经为文件保存了老的版本。备份文件名由当前文件名加后辍<span class="string">"~"</span>组成。</span><br><span class="line"><span class="string">" if has("</span>vms<span class="string">")</span><br><span class="line">"</span> <span class="built_in">set</span> nobackup</span><br><span class="line"><span class="string">" else</span><br><span class="line">"</span> <span class="built_in">set</span> backup</span><br><span class="line"><span class="string">" endif</span><br><span class="line"></span><br><span class="line">"</span> 设置冒号命令和搜索命令的命令历史列表的长度。</span><br><span class="line"><span class="built_in">set</span> <span class="built_in">history</span>=<span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="string">" 总是在Vim窗口的右下角显示当前光标的行列信息。</span><br><span class="line">set ruler</span><br><span class="line"></span><br><span class="line">"</span> 在Vim窗口的右下角显示一个完整的命令已经完成的部分。比如说你键入<span class="string">"2f"</span>,Vim就会在你键入下一个要查找的字符之前显示已经键入的<span class="string">"2f"</span>。一旦你接下来再键入一个字符比如<span class="string">"w"</span>,那么一个完整的命令<span class="string">"2fw"</span>就会被Vim 执行,同时刚才显示的<span class="string">"2f"</span>也将消失。</span><br><span class="line"><span class="built_in">set</span> showcmd</span><br><span class="line"></span><br><span class="line"><span class="string">" 语法高亮</span><br><span class="line">syntax on</span><br><span class="line"></span><br><span class="line">"</span> 显示行号</span><br><span class="line"><span class="built_in">set</span> nu</span><br><span class="line"></span><br><span class="line"><span class="string">" 显示空格和TAB</span><br><span class="line">set list</span><br><span class="line">set listchars=tab:&gt;-,trail:-</span><br><span class="line"></span><br><span class="line">"</span> 凸显当前行</span><br><span class="line"><span class="built_in">set</span> cursorline</span><br><span class="line"></span><br><span class="line"><span class="string">" 检测文件类型</span><br><span class="line">filetype on</span><br><span class="line"></span><br><span class="line">"</span> 启用鼠标</span><br><span class="line"><span class="built_in">set</span> mouse=a</span><br><span class="line"></span><br><span class="line"><span class="string">" 配色方案</span><br><span class="line">"</span>colorscheme torte</span><br><span class="line"></span><br><span class="line"><span class="string">" 以下为插件</span><br><span class="line"></span><br><span class="line">"</span> 管理插件的插件pathogen</span><br><span class="line">call pathogen<span class="comment">#infect()</span></span><br><span class="line"></span><br><span class="line"><span class="string">" NERDTree目录树插件</span><br><span class="line">noremap  :NERDTree</span><br><span class="line"></span><br><span class="line">"</span> Powerline</span><br><span class="line"><span class="built_in">set</span> guifont=PowerlineSymbols\ <span class="keyword">for</span>\ Powerline</span><br><span class="line"><span class="built_in">set</span> nocompatible</span><br><span class="line"><span class="built_in">set</span> laststatus=<span class="number">2</span></span><br><span class="line"><span class="built_in">set</span> t_Co=<span class="number">256</span></span><br><span class="line"><span class="built_in">let</span> g:Powerline_symbols = <span class="string">'fancy'</span></span><br><span class="line"></span><br><span class="line"><span class="string">" NERDTree</span><br><span class="line">map &lt;F10&gt; :NERDTreeToggle&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">"</span> C的编译和运行 </span><br><span class="line">map &lt;F5&gt; :call CompileRunGcc()&lt;CR&gt; </span><br><span class="line">func! CompileRunGcc() </span><br><span class="line"><span class="built_in">exec</span> <span class="string">"w"</span> </span><br><span class="line"><span class="built_in">exec</span> <span class="string">"!gcc % -o %&lt;"</span> </span><br><span class="line"><span class="built_in">exec</span> <span class="string">"! ./%&lt;"</span> </span><br><span class="line">endfunc </span><br><span class="line"></span><br><span class="line"><span class="string">" C++的编译和运行 </span><br><span class="line">map &lt;F6&gt; :call CompileRunGpp()&lt;CR&gt; </span><br><span class="line">func! CompileRunGpp() </span><br><span class="line">exec "</span>w<span class="string">" </span><br><span class="line">exec "</span>!g++ % -o %&lt;<span class="string">" </span><br><span class="line">exec "</span>! ./%&lt;<span class="string">" </span><br><span class="line">endfunc</span></span><br></pre></td></tr></table></figure>
<h1 id="插件列表">插件列表</h1><table>
<thead>
<tr>
<th>插件名称</th>
<th style="text-align:left">项目地址</th>
<th style="text-align:left">教程地址</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>pathogen</code></td>
<td style="text-align:left"><a href="http://www.vim.org/scripts/script.php?script_id=2332" target="_blank" rel="external">项目地址</a></td>
<td style="text-align:left"><a href="https://github.com/tpope/vim-pathogen" target="_blank" rel="external">教程地址</a></td>
</tr>
<tr>
<td><code>NERDTree</code></td>
<td style="text-align:left"><a href="http://www.vim.org/scripts/script.php?script_id=1658" target="_blank" rel="external">项目地址</a></td>
<td style="text-align:left"><a href="http://my.oschina.net/VASKS/blog/388907?fromerr=ktE2belY" target="_blank" rel="external">教程地址</a></td>
</tr>
</tbody>
</table>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="自用的vim配置文件">自用的vim配置文件</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span cl]]>
    </summary>
    
      <category term="Linux" scheme="http://kaiiak.github.io/tags/Linux/"/>
    
      <category term="vim" scheme="http://kaiiak.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[APUE学习笔记——文件和目录]]></title>
    <link href="http://kaiiak.github.io/2016/02/29/APUE_study_notes-Files_and_Directories/"/>
    <id>http://kaiiak.github.io/2016/02/29/APUE_study_notes-Files_and_Directories/</id>
    <published>2016-02-29T13:48:30.000Z</published>
    <updated>2016-03-04T15:47:16.948Z</updated>
    <content type="html"><![CDATA[<h1 id="函数stat、fstat、fstatat、lstat">函数<code>stat</code>、<code>fstat</code>、<code>fstatat</code>、<code>lstat</code></h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, <span class="keyword">struct</span> stat *<span class="keyword">restrict</span> buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">struct</span> stat *buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lstat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, <span class="keyword">struct</span> stat *<span class="keyword">restrict</span> buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lstat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, <span class="keyword">struct</span> stat *<span class="keyword">restrict</span> buf, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 所有4个函数的返回值：若成功，返回0；若出错，返回-1 */</span></span><br><span class="line"></span><br><span class="line">sturct stat &#123; </span><br><span class="line">    <span class="keyword">mode_t</span>          st_mode;        <span class="comment">/* file type &amp; mode (permissions) */</span></span><br><span class="line">    <span class="keyword">ino_t</span>           st_ino;         <span class="comment">/* i-node number (serial number) */</span></span><br><span class="line">    <span class="keyword">dev_t</span>           st_dev;         <span class="comment">/* device number (file system) */</span></span><br><span class="line">    <span class="keyword">dev_t</span>           st_rdev;        <span class="comment">/* device number for special files */</span></span><br><span class="line">    <span class="keyword">nlink_t</span>         st_nlink;       <span class="comment">/* number of links */</span></span><br><span class="line">    <span class="keyword">uid_t</span>           st_uid;         <span class="comment">/* user ID of links */</span></span><br><span class="line">    <span class="keyword">gid_t</span>           st_gid;         <span class="comment">/* group ID of owner */</span></span><br><span class="line">    <span class="keyword">off_t</span>           st_size;        <span class="comment">/* size in bytes, for regular files  */</span></span><br><span class="line">    <span class="keyword">struct</span> timespec st_atime;       <span class="comment">/* time of last access */</span></span><br><span class="line">    <span class="keyword">struct</span> timespec st_mtime;       <span class="comment">/* time of last modification */</span></span><br><span class="line">    <span class="keyword">struct</span> timespec st_ctime;       <span class="comment">/* time of last file status change */</span></span><br><span class="line">    <span class="keyword">blksize_t</span>       st_blksize;     <span class="comment">/* best I/O block size */</span></span><br><span class="line">    <span class="keyword">blkcnt_t</span>        st_blocks;      <span class="comment">/* number of disk blocks allocated */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>函数<code>stat</code>:返回<code>pathname</code>命名文件有关的信息结构；</li>
<li>函数<code>fstat</code>:返回在描述符<code>fd</code>上打开文件的有关信息；</li>
<li>函数<code>lstat</code>:类似于函数<code>stat</code>，但当命名的文件是一个符号链接时，<code>lstat</code>返回该符号连接的有关信息；</li>
<li>函数<code>fstatat</code>:为一个相对于当前打开目录(由<code>fd</code>参数指向)的路径名返回文件统计信息。</li>
</ul>
<p>文件信息包含<code>stat</code>结构的<code>st_mode</code>成员中。可以下表中的宏文件确定文件的类型。</p>
<table>
<thead>
<tr>
<th>宏</th>
<th style="text-align:left">文件类型</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>S_ISREG()</code></td>
<td style="text-align:left">普通文件</td>
</tr>
<tr>
<td><code>S_ISDIR()</code></td>
<td style="text-align:left">目录文件</td>
</tr>
<tr>
<td><code>S_ISCHR()</code></td>
<td style="text-align:left">字符特殊文件</td>
</tr>
<tr>
<td><code>S_ISBLK()</code></td>
<td style="text-align:left">块特殊文件</td>
</tr>
<tr>
<td><code>S_ISFIFO()</code></td>
<td style="text-align:left">管道或FIFO</td>
</tr>
<tr>
<td><code>S_ISLNK()</code></td>
<td style="text-align:left">符号链接</td>
</tr>
<tr>
<td><code>S_ISSOCK()</code></td>
<td style="text-align:left">套接字</td>
</tr>
</tbody>
</table>
<h1 id="文件类型">文件类型</h1><p>文件类型包括如下几类：</p>
<ol>
<li>普通文件(regular file):包含了某种形式的数据；</li>
<li>目录文件(directory file):包含了其他文件的名字以及指向与这些文件有关信息的指针；</li>
<li>块特殊文件(block special file):该类型文件提供对设备(如磁盘)带缓冲的访问，每次访问以固定长度为单位进行；</li>
<li>字符特殊文件(character special file):该文件提供对设备不带缓冲的访问，每次访问长度不变。系统中的所有设备要么是字符特殊文件，要么是块特殊文件。</li>
<li>FIFO:该文件用于进程通信，也称为命名管道(named pipe)；</li>
<li>套接字(socket)：该文件用于进程间的网络通信，也可以用在一台宿主机上进程间的非网络通信。</li>
<li>符号链接(symbolic link):该文件指向另一个文件。</li>
</ol>
<h1 id="设置用户ID和设置组ID">设置用户ID和设置组ID</h1><ul>
<li>实际用户ID和实际组ID标识我们究竟是谁。</li>
<li>有效用户ID、有效组ID以及附属组ID决定了我们的文件访问权限。</li>
<li>保存的设置用户ID和保存的设置组ID在执行一个程序时包含了有效用户ID和有效组ID的副本。</li>
</ul>
<p>每个文件有一个所有者和组所有者，所有者由<code>stat</code>结构中的<code>st_uid</code>指定，组所有者则由<code>st_gid</code>指定。</p>
<h1 id="文件访问权限">文件访问权限</h1><p>所有文件类型(目录、字符特别文件等)都有访问权限(access permisiion)。</p>
<table>
<thead>
<tr>
<th><code>st_mode</code>屏蔽</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>S_IRUSR</code></td>
<td style="text-align:left">用户都</td>
</tr>
<tr>
<td><code>S_IWUSR</code></td>
<td style="text-align:left">用户写</td>
</tr>
<tr>
<td><code>S_IXUSR</code></td>
<td style="text-align:left">用户执行</td>
</tr>
<tr>
<td><code>S_IRGRP</code></td>
<td style="text-align:left">组读</td>
</tr>
<tr>
<td><code>S_IWGRP</code></td>
<td style="text-align:left">组写</td>
</tr>
<tr>
<td><code>S_IXGRP</code></td>
<td style="text-align:left">组执行</td>
</tr>
<tr>
<td><code>S_IROTH</code></td>
<td style="text-align:left">其他读</td>
</tr>
<tr>
<td><code>S_IWOTH</code></td>
<td style="text-align:left">其他写</td>
</tr>
<tr>
<td><code>S_IXOTH</code></td>
<td style="text-align:left">其他执行</td>
</tr>
</tbody>
</table>
<h1 id="函数access和faccessat">函数<code>access</code>和<code>faccessat</code></h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">access</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">faccessat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> mode, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">/* 两个函数的返回值：若成功，返回0；若出错，返回-1 */</span></span><br></pre></td></tr></table></figure>
<p><code>access</code>和<code>faccessat</code>函数是按实际用户ID和实际组ID进行访问权限测试的。</p>
<table>
<thead>
<tr>
<th><code>mode</code></th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>R_OK</code></td>
<td style="text-align:left">测试读权限</td>
</tr>
<tr>
<td><code>W_OK</code></td>
<td style="text-align:left">测试写权限</td>
</tr>
<tr>
<td><code>X_OK</code></td>
<td style="text-align:left">测试执行权限</td>
</tr>
</tbody>
</table>
<h1 id="函数umask">函数<code>umask</code></h1><p><code>umask</code>函数为进程设置文件模式创建屏蔽字(mask for the process)，并返回之前的值。(这是少数几个没有出错返回函数中的一个。)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mode_t</span> umask(<span class="keyword">mode_t</span> cmask);</span><br><span class="line"><span class="comment">/* 返回值：之前的文件模式穿件屏蔽字 */</span></span><br></pre></td></tr></table></figure>
<p>参数<code>cmask</code>是由上上个表列出的9个常量(S_IRUSR、S_IWUSR等)中若干个按位“或”构成的。</p>
<table>
<thead>
<tr>
<th>屏蔽位</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>0400</td>
<td style="text-align:left">用户读</td>
</tr>
<tr>
<td>0200</td>
<td style="text-align:left">用户写</td>
</tr>
<tr>
<td>0100</td>
<td style="text-align:left">用户执行</td>
</tr>
<tr>
<td>0040</td>
<td style="text-align:left">组读</td>
</tr>
<tr>
<td>0020</td>
<td style="text-align:left">组写</td>
</tr>
<tr>
<td>0010</td>
<td style="text-align:left">组执行</td>
</tr>
<tr>
<td>0004</td>
<td style="text-align:left">其他读</td>
</tr>
<tr>
<td>0002</td>
<td style="text-align:left">其他写</td>
</tr>
<tr>
<td>0001</td>
<td style="text-align:left">其他执行</td>
</tr>
</tbody>
</table>
<h1 id="函数chmod、fchmod和fchmodat">函数<code>chmod</code>、<code>fchmod</code>和<code>fchmodat</code></h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chomd</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, mode_t mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchome</span><span class="params">(<span class="keyword">int</span> fd, mode_t mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchomdat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, mode_t mode, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">/* 3个函数返回值：若成功，返回0；若出错，返回-1 */</span></span><br></pre></td></tr></table></figure>
<p><code>chmod</code>函数在指定的文件上进行操作，而<code>fchmod</code>函数则对已打开的文件进行操作。<br><code>fchomdat</code>函数与<code>chmod</code>函数在下面两种情况下是相同的：一种是<code>pathname</code>参数为绝对路径，另一种是<code>fd</code>参数取值为<code>AT_FDCWD</code>而<code>pathname</code>参数为相对路径。否则，<code>fchmodat</code>计算相对于打开目录(由<code>fd</code>参数指向)的pathname。<code>flag</code>参数可以用于改变<code>fchmodat</code>的行为，当设置了<code>AT_SYMLIN_NOFOLLOW</code>标志时，<code>fchmodat</code>并不会跟随符号链接。</p>
<table>
<thead>
<tr>
<th><code>mode</code></th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>S_ISUID</code></td>
<td style="text-align:left">执行时设置用户ID</td>
</tr>
<tr>
<td><code>S_ISGID</code></td>
<td style="text-align:left">执行时设置组ID</td>
</tr>
<tr>
<td><code>S_ISVTX</code></td>
<td style="text-align:left">保存正文(粘着位)</td>
</tr>
<tr>
<td><code>S_IRWXU</code></td>
<td style="text-align:left">用户(所有者)读、写和执行</td>
</tr>
<tr>
<td><code>S_IRUSR</code></td>
<td style="text-align:left">用户(所有者)读</td>
</tr>
<tr>
<td><code>S_IWUSR</code></td>
<td style="text-align:left">用户(所有者)写</td>
</tr>
<tr>
<td><code>S_IXUSR</code></td>
<td style="text-align:left">用户(所有者)执行</td>
</tr>
<tr>
<td><code>S_IRWXG</code></td>
<td style="text-align:left">组读、写和执行</td>
</tr>
<tr>
<td><code>S_IRGRP</code></td>
<td style="text-align:left">组读</td>
</tr>
<tr>
<td><code>S_IWGRP</code></td>
<td style="text-align:left">组写</td>
</tr>
<tr>
<td><code>S_IXGRP</code></td>
<td style="text-align:left">组执行</td>
</tr>
<tr>
<td><code>S_IRWXO</code></td>
<td style="text-align:left">其他读、写和执行</td>
</tr>
<tr>
<td><code>S_IROTH</code></td>
<td style="text-align:left">其他读</td>
</tr>
<tr>
<td><code>S_IWOTH</code></td>
<td style="text-align:left">其他写</td>
</tr>
<tr>
<td><code>S_IXOTH</code></td>
<td style="text-align:left">其他执行</td>
</tr>
</tbody>
</table>
<h1 id="粘着位(sticky_bit)">粘着位(sticky bit)</h1><p><code>S_ISVTX</code>位被称为<code>粘着位</code>：如果一个可执行的程序文件的这一位被设置了，那么当程序第一次被执行，在其终止时，程序正文的一个副本仍被保存在交换区。<br>后来的UNIX版本称为它为<code>保存正文位(saved-text bit)</code>，因此也就有了常量<code>S_ISVTX</code>。</p>
<h1 id="函数chown、fchown、fchownat和lchown">函数<code>chown</code>、<code>fchown</code>、<code>fchownat</code>和<code>lchown</code></h1><p>下面几个<code>chown</code>函数可用于更改文件的用户ID和组ID。如果两个参数<code>owner</code>或<code>group</code>中的任意一个是-1，则对应的ID不变。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chown</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, uid_t owner, git_t group)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchown</span><span class="params">(<span class="keyword">int</span> fd, uid_t owner, gid_t group)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchownat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, uid_t owner, gid_t group, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lchown</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, uid_t owner, gid_t group)</span></span>;</span><br><span class="line"><span class="comment">/*</span><br><span class="line"> * 4个函数的返回值：若辰宫，返回0；若出错，返回-1</span><br><span class="line"> */</span></span><br></pre></td></tr></table></figure>
<h1 id="文件长度">文件长度</h1><p><code>stat</code>结构成员<code>st_size</code>表示以字节为单位的单位长度。只对普通文件、目录文件和符号连接有效。</p>
<h1 id="文件中的空洞">文件中的空洞</h1><p>空洞是由所设置的偏移量超过文件端尾，并写入了某些数据后造成的。</p>
<h1 id="文件截断">文件截断</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">truncate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, off_t length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ftruncate</span><span class="params">(<span class="keyword">int</span> fd, off_t length)</span></span>;</span><br><span class="line"><span class="comment">/*</span><br><span class="line"> * 两个函数的返回值：若成功，返回0；若失败，返回-1</span><br><span class="line"> */</span></span><br></pre></td></tr></table></figure>
<p>如果该文件以前的长度大于<code>length</code>，则超过<code>length</code>以外的数据就不能再访问。如果以前的长度小于<code>length</code>，文件长度将增加，在以前的文件尾端和新的文件尾端之间的数据将读作0。</p>
<h1 id="文件系统">文件系统</h1><h1 id="函数link、linkat、unlink、unlinkat和remove">函数<code>link</code>、<code>linkat</code>、<code>unlink</code>、<code>unlinkat</code>和<code>remove</code></h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">link</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *existingpath, <span class="keyword">const</span> <span class="keyword">char</span> *newpath)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">linkat</span><span class="params">(<span class="keyword">int</span> efd, <span class="keyword">const</span> <span class="keyword">char</span> *existingpath, <span class="keyword">int</span> nfd, <span class="keyword">const</span> <span class="keyword">char</span> *newpath, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">/* 两个函数的返回值：若成功，返回0；若出错，返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>这两个函数创建一个新目录项<code>newpath</code>，它引用现有文件<code>existingpath</code>。如果<code>newpath</code>已存在，则返回出错。<br>对于<code>linkat</code>函数，现有文件是通过<code>efd</code>和<code>existingpath</code>指定，新的路径名是通过<code>nfd</code>和<code>newpath</code>指定的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unlinkat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">/* 两个函数的返回值：若成功，返回0；若出错，返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>这两个函数删除目录项，并将由<code>pathname</code>所引用的链接数减1。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回0；若失败，返回-1 */</span></span><br></pre></td></tr></table></figure>
<h1 id="函数rename和renameat">函数<code>rename</code>和<code>renameat</code></h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rename</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *oldname, <span class="keyword">const</span> <span class="keyword">char</span> *newname)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">renameat</span><span class="params">(<span class="keyword">int</span> oldfd, <span class="keyword">const</span> <span class="keyword">char</span> *oldname, <span class="keyword">int</span> newfd, <span class="keyword">const</span> <span class="keyword">char</span> *newname)</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>如果<code>oldname</code>指的是一个文件而不是目录，那么为该文件或符号连接重命名。</li>
<li>如果<code>oldname</code>指的是一个空目录，那么为该目录重命名。</li>
<li>如果<code>oldname</code>或<code>newname</code>引用符号连接，则处理的是符号链接本身，而不是它引用的文件。</li>
<li>不能对<code>.</code>和<code>..</code>重命名。</li>
<li>作为一个特例，如果<code>oldname</code>和<code>newname</code>引用同意文件，则函数不做任何更改而成功返回。</li>
</ol>
<h1 id="符号链接">符号链接</h1><p>符号链接是对一个文件的间接指针。符号链接以及它指向何种对象并无任何文件系统限制，任何用户都可以创建指向目录的符号连接。</p>
<h1 id="创建和读取符号连接">创建和读取符号连接</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">symlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *actualpath, <span class="keyword">const</span> <span class="keyword">char</span> *sympath)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">symlinat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *acutalpath, <span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *symptah)</span></span>;</span><br><span class="line"><span class="comment">/* 两个函数的返回值：若成功，返回0；若出错，返回-1 */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> readlink(<span class="keyword">const</span> <span class="keyword">char</span> *actualpath, <span class="keyword">const</span> <span class="keyword">char</span> *symptah);</span><br><span class="line"><span class="keyword">sszie_t</span> readlinkat(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">restrict</span> pathname, <span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">size_t</span> bufsize);</span><br><span class="line"><span class="comment">/* 两个函数的返回值：若成功，返回读取的字节数；若出错，返回-1 */</span></span><br></pre></td></tr></table></figure>
<h1 id="文件时间">文件时间</h1><table>
<thead>
<tr>
<th>字段</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">例子</th>
<th style="text-align:left">ls(1)选项</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>st_atim</code></td>
<td style="text-align:left">文件数据的最后访问时间</td>
<td style="text-align:left"><code>read</code></td>
<td style="text-align:left"><code>-u</code></td>
</tr>
<tr>
<td><code>st_mtim</code></td>
<td style="text-align:left">文件数据的最后修改时间</td>
<td style="text-align:left"><code>write</code></td>
<td style="text-align:left"><code>默认</code></td>
</tr>
<tr>
<td><code>st_ctim</code></td>
<td style="text-align:left">i节点状态的最后更改时间</td>
<td style="text-align:left"><code>chomd、chown</code></td>
<td style="text-align:left"><code>-c</code></td>
</tr>
</tbody>
</table>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="函数stat、fstat、fstatat、lstat">函数<code>stat</code>、<code>fstat</code>、<code>fstatat</code>、<code>lstat</code></h1><figure class="highli]]>
    </summary>
    
      <category term="APUE" scheme="http://kaiiak.github.io/tags/APUE/"/>
    
      <category term="Linux" scheme="http://kaiiak.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[APUE学习笔记——文件IO]]></title>
    <link href="http://kaiiak.github.io/2016/02/25/APUE_study_notes-Files_IO/"/>
    <id>http://kaiiak.github.io/2016/02/25/APUE_study_notes-Files_IO/</id>
    <published>2016-02-25T00:36:08.000Z</published>
    <updated>2016-02-29T14:01:20.496Z</updated>
    <content type="html"><![CDATA[<h1 id="APUE学习笔记——文件IO">APUE学习笔记——文件IO</h1><h2 id="文件描述符">文件描述符</h2><p>所有打开的文件都通过文件描述符(一个非负整数)引用。</p>
<p>维基百科上对于文件描述符的解释是这样的：</p>
<blockquote>
<p>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。</p>
</blockquote>
<p>当读、写一个文件时，使用<code>open</code>或<code>creat</code>返回的文件描述符标识该文件，将其作为参数传给<code>read</code>或<code>write</code>。</p>
<p>在POSIX.1的应用程序中，文件描述符0与进程的标准输入关联(STDIN_FILENO)、文件描述符1与进程的标准输出关联(STDOUT_FILENO)、文件描述符2与进程的标准错误关联(STDERR_FILENO)，且已经确定化。<br>文件描述符的变化范围是<code>0~OPEN_MAX-1</code>。</p>
<h2 id="函数open和openat">函数<code>open</code>和<code>openat</code></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> oflag, ... <span class="comment">/* mode_t mode */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">openat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> oflag, ... <span class="comment">/* mode_t mode */</span>)</span></span>;</span><br><span class="line"><span class="comment">/*</span><br><span class="line"> *path ：文件的名称，可以包含（绝对和相对）路径</span><br><span class="line"> *flags：文件打开模式</span><br><span class="line"> *mode：用来规定对该文件的所有者，文件的用户组及系 统中其他用户的访问权限</span><br><span class="line"> */</span></span><br><span class="line"><span class="comment">/* 两函数的返回值： 若成功，返回文件描述符； 若出错，返回-1 */</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>打开方式</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>O_RDONLY</code></td>
<td style="text-align:left">只读打开.</td>
</tr>
<tr>
<td><code>O_WRONLY</code></td>
<td style="text-align:left">只写打开.</td>
</tr>
<tr>
<td><code>O_RDWR</code></td>
<td style="text-align:left">读、写打开.</td>
</tr>
<tr>
<td><code>O_EXEC</code></td>
<td style="text-align:left">只执行打开.</td>
</tr>
<tr>
<td><code>O_SEARCH</code></td>
<td style="text-align:left">只搜索打开 (应用于目录).</td>
</tr>
<tr>
<td><code>O_APPEND</code></td>
<td style="text-align:left">每次写时都追加到文件的尾端.</td>
</tr>
<tr>
<td><code>O_CLOEXEC</code></td>
<td style="text-align:left">设置<code>FD_CLOEXEC</code>文件描述符.</td>
</tr>
<tr>
<td><code>O_CREAT</code></td>
<td style="text-align:left">若此文件不存在则创建它.</td>
</tr>
<tr>
<td><code>O_DIRECTORY</code></td>
<td style="text-align:left">如果<code>path</code>引用的不是目录，则出错.</td>
</tr>
<tr>
<td><code>O_EXCL</code></td>
<td style="text-align:left">如果同时指定了<code>O_CREAT</code>，而文件已存在，则出错.</td>
</tr>
<tr>
<td><code>O_NOCTTY</code></td>
<td style="text-align:left">如果<code>path</code>引用的是终端设备，则不将该设备分配作为此进程的控制终端.</td>
</tr>
<tr>
<td><code>O_NOFOLLOW</code></td>
<td style="text-align:left">如果<code>path</code>引用的是一个符号连接，则出错.</td>
</tr>
<tr>
<td><code>O_NONBLOCK</code></td>
<td style="text-align:left">如果<code>path</code>引用的是一个<code>FIFO</code>、一个块特殊文件或一个自负特殊文件，则此选项为文件的本次打开操作和后续的I/O操作设置非阻塞方式.</td>
</tr>
<tr>
<td><code>O_SYNC</code></td>
<td style="text-align:left">使每次<code>write</code>等待物理I/O完成，包括由该<code>write</code>操作引起的文件属性更新所需的I/O.</td>
</tr>
<tr>
<td><code>O_TRUNC</code></td>
<td style="text-align:left">如果此文件存在，而且为只写或读-写成功打开，则将其长度截断为0.</td>
</tr>
<tr>
<td><code>O_TTY_INIT</code></td>
<td style="text-align:left">如果打开一个还未打开的终端设备，设置非标准<code>termios</code>参数值，使其符合<code>Single UNIX Specification</code>.</td>
</tr>
<tr>
<td><code>O_DSYNC</code></td>
<td style="text-align:left">使每次<code>write</code>要等待物理I/O完成，但是如果该写操作并不影响读取刚写入的数据，则不需等待文件属性被更新.</td>
</tr>
<tr>
<td><code>O_RSYNC</code></td>
<td style="text-align:left">使每一个一文件描述符作为参数进行的<code>read</code>操作等待，直至所有对文件同一部份挂起的写操作都完成.</td>
</tr>
</tbody>
</table>
<h3 id="fd参数吧open和openat函数区分开，共有3种可能性。"><code>fd</code>参数吧<code>open</code>和<code>openat</code>函数区分开，共有3种可能性。</h3><ol>
<li><code>path</code>参数指定的是绝对路径名，在这种情况下，<code>fd</code>参数被忽略，<code>openat</code>函数就相当于<code>open</code>函数。</li>
<li><code>path</code>参数指定的是相对路径名，<code>fd</code>参数指出了相对路径名在文件系统中的开始地址。<code>fd</code>参数是通过打开相对路径名所在的目录来获取。</li>
<li><code>path</code>参数指定了相对路径名，<code>fd</code>参数具有特殊值<code>AT_FDCWD</code>。在这种情况下，路径名在当前工作目录中获取，<code>openat</code>函数在操作上与<code>open</code>函数类似。</li>
</ol>
<h2 id="函数creat">函数<code>creat</code></h2><h3 id="调用函数creat创建一个新的文件">调用函数<code>creat</code>创建一个新的文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">creat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, mode_t mode)</span></span>;</span><br><span class="line"><span class="comment">/* 返回值： 若成功，返回为只写打开的文件描述符；如出错，返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>等效于：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open(path, O_WRONLY|O_CREAT|O_TRUNC, mode);</span><br></pre></td></tr></table></figure></p>
<h2 id="函数close">函数<code>close</code></h2><h3 id="调用close函数关闭一个打开文件">调用<code>close</code>函数关闭一个打开文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回0；如出错，返回-1 */</span></span><br></pre></td></tr></table></figure>
<h2 id="函数lseek">函数<code>lseek</code></h2><h3 id="当前文件偏移量(current_file_offset)：它通常是一个非负整数，用以度量从文件开始处计算的字节数。">当前文件偏移量(current file offset)：它通常是一个非负整数，用以度量从文件开始处计算的字节数。</h3><h3 id="调用lseek显式的为一个打开文件设置偏移量。">调用<code>lseek</code>显式的为一个打开文件设置偏移量。</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">off_t</span> lseek(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence);</span><br><span class="line"><span class="comment">/* 返回值：若辰宫，返回新的文件偏移量；若出错，返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>对参数<code>offset</code>的解释与参数<code>whence</code>的值有关。</p>
<ul>
<li>若<code>whence</code>是<code>SEEK_SET</code>，则经该文件的偏移量设置为距文件开始处<code>offset</code>个字节。</li>
<li>若<code>whence</code>是<code>SEEK_CUR</code>，则经该文件的偏移量设置为其当前量增加<code>offset</code>，<code>offset</code>可为正或负。</li>
<li>若<code>whence</code>是<code>SEEK_END</code>，则经该文件的偏移量设置为文件长度加<code>offset</code>，<code>offset</code>可正可负。</li>
</ul>
<h2 id="函数read">函数<code>read</code></h2><h3 id="调用read函数从打开文件中读数据。">调用<code>read</code>函数从打开文件中读数据。</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes);</span><br><span class="line"><span class="comment">/* 返回值：读到的字节数，若已到文件尾，返回0；若出错，返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>有多种情况可使实际读到的字节数少于要求读的字节数：</p>
<ul>
<li>读到普通文件时，在读到要求字计数之前已到达了文件微端。</li>
<li>当从终端设备读时，通常一次最多读一行。</li>
<li>当从网络读时，网络中的缓冲机制可能造成返回值小于所要求的字节数。</li>
<li>当从管道或<code>FIFO</code>读时，如若管道包含的字节少于所需的数量，那么<code>read</code>将只返回实际可用的字节数。</li>
<li>当从某些面向记录的设备读时，一次最多返回一个记录。</li>
<li>当一信号造成中断，而已经读到部分数据量时。</li>
</ul>
<h2 id="函数write">函数<code>write</code></h2><h3 id="调用write函数向打开文件写数据。">调用<code>write</code>函数向打开文件写数据。</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> write(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes);</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回已写的字节数；若出错，返回-1 */</span></span><br></pre></td></tr></table></figure>
<h2 id="函数pread和pwrite">函数<code>pread</code>和<code>pwrite</code></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> pread(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes. <span class="keyword">off_t</span> offset);</span><br><span class="line"><span class="comment">/* 返回值：读到的字节数，若已到文件尾，返回0；若出错，返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> pwrite(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes, <span class="keyword">off_t</span> offset);</span><br></pre></td></tr></table></figure>
<p>调用<code>pread</code>相当于调用<code>lseek</code>后调用<code>read</code>，但是<code>pread</code>又与这种顺序调用有下列重要区别。</p>
<ul>
<li>调用<code>pread</code>时，无法中断其定位和都读操作。</li>
<li>不更新当前文件偏移量。<br>调用<code>pwrite</code>相当于调用<code>lseek</code>后调用<code>write</code>，但也与它们有类似的区别。</li>
</ul>
<blockquote>
<p>原子操作(atomic operation)；指的是由多步组成一个一个操作。如果该操作原子地执行，则要么执行所有步骤，要么一步也不执行，不可能只执行所有步骤的一个子集。</p>
</blockquote>
<h2 id="函数dup和dup2">函数<code>dup</code>和<code>dup2</code></h2><h3 id="复制一个现有的文件描述符">复制一个现有的文件描述符</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> fd2)</span></span>;</span><br><span class="line"><span class="comment">/* 两函数的返回值：若成功，返回新的文件描述符；如出错，返回-1 */</span></span><br></pre></td></tr></table></figure>
<h2 id="函数sync、fsync和fdatasync">函数<code>sync</code>、<code>fsync</code>和<code>fdatasync</code></h2><blockquote>
<p>内核通常先将数据复制到缓冲区中，然后排入队列，晚些时候写入磁盘。这种方法被称为<code>延迟写(delayed write)</code>.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unitstd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsync</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fdatasync</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回0；若出错，返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sync</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>sync</code>只是将所有修改过的块缓冲区排入写队列，然后就返回，它并不等待实际写磁盘操作结束。<br><code>fsync</code>函数只对由文件描述符<code>fd</code>指定的一个文件起作用，并且等待写磁盘操作结束才返回。<br><code>fdatasync</code>函数类似于<code>fsync</code>，但它只影响文件的数据部分。</p>
<h2 id="函数fcntl">函数<code>fcntl</code></h2><h3 id="改变已经打开文件的属性。">改变已经打开文件的属性。</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ... <span class="comment">/* int arg */</span>)</span></span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，则依赖cmd，若出错，返回-1 */</span></span><br></pre></td></tr></table></figure>
<h4 id="fcntl函数有以下5种功能。"><code>fcntl</code>函数有以下5种功能。</h4><ol>
<li>复制一个已有的描述符 (<code>cmd=F_DUPFD</code>或<code>F_DUPFD_CLOEXEC</code>)。</li>
<li>获取/设置文件描述符标志 (<code>cmd=F_GETFD</code>或<code>F_SETFD</code>)。</li>
<li>获取/设置文件状态标志 (<code>cmd=F_GETFL</code>或<code>F_SETFL</code>)。</li>
<li>获取/设置异步I/O所有权 (<code>cmd=F_GETOWN</code>或<code>F_SETOWN</code>)。</li>
<li>获取/设置记录锁 (<code>cmd=F_GETLK</code>或<code>F_SETLKW</code>)。</li>
</ol>
<p>|cmd|功能<br>|<br>|——|:—————————————————-|<br>|<code>F_DUPFD</code>|复制文件描述符<code>fd</code>。|<br>|<code>F_DUPFD_CLOEXEC</code>|复制文件描述符，设置与新描述符关联的<code>FD_CLOEXEC</code>文件描述符标志的值，返回新文件描述符。|<br>|<code>F_GETFD</code>|对应于<code>fd</code>的文件描述符标志作为函数值返回。|<br>|<code>F_SETFD</code>|对于<code>fd</code>设置文件描述符标志。|<br>|<code>F_GETFL</code>|对应于<code>fd</code>的文件状态标志作为函数值返回。|<br>|<code>F_SETFL</code>|将文件状态标志设置为第3个参数的值。可以更改的几个标志是：<code>O_APPEND</code>、<code>O_NONBLOCK</code>、<code>O_SYNC</code>、<code>O_DSYNC</code>、<code>O_RSYNC</code>、<code>O_FSYNC</code>、和<code>O_ASYNC</code>。|<br>|<code>F_GETOWN</code>|获取当前接收<code>SIGIO</code>和<code>SIGURG</code>信号进程ID或进程组ID。|<br>|<code>F_SETOWN</code>|设置接收<code>SIGIO</code>和<code>SIGURG</code>信号的进程ID或进程组ID。|</p>
<h2 id="函数ioctl">函数<code>ioctl</code></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> /* System V */</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span>  /* BSD and Linux */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ioctl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> request, ...)</span></span>;</span><br><span class="line"><span class="comment">/* 返回值：若出错，返回-1；若成功，返回其他值 */</span></span><br></pre></td></tr></table></figure>
<h2 id="/dev/fd"><code>/dev/fd</code></h2><p>较新的系统都提供名为<code>/dev/fd</code>的目录，其目录项是名为0、1、2等的文件。打开文件<code>/dev/fdn</code>等效于复制描述符n(假设描述符n是打开的).</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="APUE学习笔记——文件IO">APUE学习笔记——文件IO</h1><h2 id="文件描述符">文件描述符</h2><p>所有打开的文件都通过文件描述符(一个非负整数)引用。</p>
<p>维基百科上对于文件描述符的解释是这样的：</p>
<blockquot]]>
    </summary>
    
      <category term="APUE" scheme="http://kaiiak.github.io/tags/APUE/"/>
    
      <category term="Linux" scheme="http://kaiiak.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[编译apue.3e并解决编译错误]]></title>
    <link href="http://kaiiak.github.io/2016/01/28/%E7%BC%96%E8%AF%91apue-3e%E5%B9%B6%E8%A7%A3%E5%86%B3%E7%BC%96%E8%AF%91%E9%94%99%E8%AF%AF/"/>
    <id>http://kaiiak.github.io/2016/01/28/编译apue-3e并解决编译错误/</id>
    <published>2016-01-28T14:38:58.000Z</published>
    <updated>2016-02-12T12:15:10.705Z</updated>
    <content type="html"><![CDATA[<h2 id="下载源代码">下载源代码</h2><p>我们在学习APUE这本书的时候，总会见到书上的源代码总会引用<code>apue.h</code>这个头文件，这个并不是Linux系统自带的。所以，我们要自己编译。<br>我们在<a href="http://www.apuebook.com/src.3e.tar.gz" target="_blank" rel="external">http://www.apuebook.com/src.3e.tar.gz</a>下载源代码后，解压。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf src.3e.tar.gz</span><br></pre></td></tr></table></figure></p>
<p>然后编译<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make</span><br></pre></td></tr></table></figure></p>
<p>但是在编译过程中，会出现错误，错误部分的log是这样的。<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gcc -ansi -I..<span class="regexp">/include -Wall -DLINUX -D_GNU_SOURCE  badexit2.c -o badexit2  -L../</span>lib -lapue -pthread -lrt -lbsd</span><br><span class="line"><span class="regexp">/usr/</span>bin/<span class="string">ld:</span> cannot find -lbsd</span><br><span class="line"><span class="string">collect2:</span> ld returned <span class="number">1</span> exit status</span><br><span class="line"><span class="string">Makefile:</span><span class="number">31</span>: recipe <span class="keyword">for</span> target <span class="string">'badexit2'</span> failed</span><br><span class="line">make[<span class="number">1</span>]: *** [badexit2] Error <span class="number">1</span></span><br><span class="line">make[<span class="number">1</span>]: Leaving directory <span class="string">'/home/pi/apue.3e/threads'</span></span><br><span class="line"><span class="string">Makefile:</span><span class="number">6</span>: recipe <span class="keyword">for</span> target <span class="string">'all'</span> failed</span><br><span class="line"><span class="label"></span><br><span class="line">make:</span> *** [all] Error <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<h2 id="修复">修复</h2><p>出现这个错误是因为，我们缺少一个库。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get inatall libbsd-dev</span><br></pre></td></tr></table></figure></p>
<p>安装完成后，重新进行编译.</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp ./<span class="keyword">include</span>/apue.<span class="keyword">h</span> ./lib/<span class="keyword">error</span>.c /usr/<span class="keyword">include</span></span><br></pre></td></tr></table></figure>
<p>然后，在<code>/usr/include/apue.h</code>的<code>ifdef</code>和<code>endif</code>中间添加<code>#include &quot;error.c&quot;</code>,就可以在编写的程序中，愉快的使用<code>apue.h</code>了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="下载源代码">下载源代码</h2><p>我们在学习APUE这本书的时候，总会见到书上的源代码总会引用<code>apue.h</code>这个头文件，这个并不是Linux系统自带的。所以，我们要自己编译。<br>我们在<a href="http://www.apu]]>
    </summary>
    
      <category term="APUE" scheme="http://kaiiak.github.io/tags/APUE/"/>
    
      <category term="Linux" scheme="http://kaiiak.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Happy New Year]]></title>
    <link href="http://kaiiak.github.io/2016/01/01/Happy-New-Year/"/>
    <id>http://kaiiak.github.io/2016/01/01/Happy-New-Year/</id>
    <published>2016-01-01T06:21:25.000Z</published>
    <updated>2016-01-01T06:44:56.890Z</updated>
    <content type="html"><![CDATA[<h2 id="新年快乐～">新年快乐～</h2><p>在新的一年里，希望我能入门C++，哈哈哈哈哈哈哈哈哈哈哈哈</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="新年快乐～">新年快乐～</h2><p>在新的一年里，希望我能入门C++，哈哈哈哈哈哈哈哈哈哈哈哈</p>
]]>
    </summary>
    
      <category term="随笔" scheme="http://kaiiak.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C#利用VLC播放网络串流]]></title>
    <link href="http://kaiiak.github.io/2015/11/19/using-vlclib-in-vs/"/>
    <id>http://kaiiak.github.io/2015/11/19/using-vlclib-in-vs/</id>
    <published>2015-11-19T13:08:23.000Z</published>
    <updated>2015-12-01T11:31:26.444Z</updated>
    <content type="html"><![CDATA[<p><a href="http://www.videolan.org" target="_blank" rel="external">VLC的官方网站</a>，VLC的源代码是用C语言实现的。我们这里用<code>C#</code>的封装——nVLC。<br><a href="http://www.codeproject.com/Articles/109639/nVLC" target="_blank" rel="external">nVLC</a>。</p>
<h2 id="开始">开始</h2><p>在运行本程序之前，请先安装VLC，或者拷贝<code>libvlc.dll</code>、<code>libvlccode.dll</code>和<code>plugins目录</code>到你的</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using System;&#10;using System.Windows.Forms;&#10;using Declarations;&#10;using Declarations.Enums;&#10;using Declarations.Media;&#10;using Declarations.Players;&#10;using Implementation;&#10;&#10;namespace nVLC_Demo_MemoryInputOutput&#10;&#123;&#10;    public partial class Form1 : Form&#10;    &#123;&#10;        IMediaPlayerFactory m_factory;&#10;        IVideoPlayer m_sourcePlayer;&#10;        IVideoPlayer m_renderPlayer;&#10;        IMemoryInputMedia m_inputMedia;&#10;        const long MicroSecondsInSecomd = 1000 * 1000;&#10;        long MicroSecondsBetweenFrame;&#10;        long frameCounter;&#10;        FrameData data = new FrameData() &#123; DTS = -1 &#125;;&#10;        const int DefaultFps = 24;&#10;        Timer timer = new Timer();&#10;&#10;        public Form1()&#10;        &#123;&#10;            InitializeComponent();&#10;            timer.Tick += new EventHandler(timer_Tick);&#10;            timer.Interval = 1000;&#10;        &#125;&#10;&#10;        void timer_Tick(object sender, EventArgs e)&#10;        &#123;&#10;            this.Text = m_inputMedia.PendingFramesCount.ToString();&#10;        &#125;&#10;&#10;        protected override void OnLoad(EventArgs e)&#10;        &#123;&#10;            base.OnLoad(e);&#10;&#10;            m_factory = new MediaPlayerFactory(true);&#10;            m_sourcePlayer = m_factory.CreatePlayer&#60;IVideoPlayer&#62;();&#10;            m_sourcePlayer.Events.PlayerPlaying += new EventHandler(Events_PlayerPlaying);&#10;            m_sourcePlayer.Mute = true;&#10;            m_renderPlayer = m_factory.CreatePlayer&#60;IVideoPlayer&#62;();&#10;            m_renderPlayer.WindowHandle = panel1.Handle;&#10;            m_inputMedia = m_factory.CreateMedia&#60;IMemoryInputMedia&#62;(MediaStrings.IMEM);&#10;            SetupOutput(m_sourcePlayer.CustomRendererEx);&#10;        &#125;&#10;&#10;        void Events_PlayerPlaying(object sender, EventArgs e)&#10;        &#123;&#10;            MicroSecondsBetweenFrame = (long)(MicroSecondsInSecomd / (m_sourcePlayer.FPS != 0 ? m_sourcePlayer.FPS : DefaultFps));&#10;        &#125;&#10;&#10;        private void SetupOutput(IMemoryRendererEx iMemoryRenderer)&#10;        &#123;&#10;            iMemoryRenderer.SetFormatSetupCallback(OnSetupCallback);&#10;            iMemoryRenderer.SetExceptionHandler(OnErrorCallback);&#10;            iMemoryRenderer.SetCallback(OnNewFrameCallback);&#10;        &#125;&#10;&#10;        private BitmapFormat OnSetupCallback(BitmapFormat format)&#10;        &#123;&#10;            SetupInput(format);&#10;            return new BitmapFormat(format.Width, format.Height, ChromaType.RV24);&#10;        &#125;&#10;&#10;        private void OnErrorCallback(Exception error)&#10;        &#123;&#10;            MessageBox.Show(error.Message);&#10;        &#125;&#10;&#10;        private void OnNewFrameCallback(PlanarFrame frame)&#10;        &#123;          &#10;            data.Data = frame.Planes[0];&#10;            data.DataSize = frame.Lenghts[0];&#10;            data.PTS = frameCounter++ * MicroSecondsBetweenFrame;&#10;            m_inputMedia.AddFrame(data);&#10;&#10;            if (/*m_inputMedia.PendingFramesCount == 10 &#38;&#38; */!m_renderPlayer.IsPlaying)&#10;            &#123;&#10;                m_renderPlayer.Play();&#10;            &#125;&#10;        &#125;&#10;&#10;        private void SetupInput(BitmapFormat format)&#10;        &#123;&#10;            var streamInfo = new StreamInfo();&#10;            streamInfo.Category = StreamCategory.Video;&#10;            streamInfo.Codec = VideoCodecs.BGR24;&#10;            streamInfo.Width = format.Width;&#10;            streamInfo.Height = format.Height;&#10;            streamInfo.Size = format.ImageSize;&#10;&#10;            m_inputMedia.Initialize(streamInfo);&#10;            m_inputMedia.SetExceptionHandler(OnErrorCallback);&#10;            m_renderPlayer.Open(m_inputMedia);           &#10;        &#125;&#10;&#10;        private void OpenSourceMedia(string path)&#10;        &#123;&#10;            //IMediaFromFile media = m_factory.CreateMedia&#60;IMediaFromFile&#62;(path);&#10;            IMedia media = m_factory.CreateMedia&#60;IMedia&#62;(path);&#10;            m_sourcePlayer.Open(media);&#10;            m_sourcePlayer.Play();&#10;            timer.Start();&#10;            &#10;        &#125;&#10;&#10;        private void button1_Click(object sender, EventArgs e)&#10;        &#123;&#10;            OpenSourceMedia(&#34;http://192.168.2.108:8090&#34;);&#10;        &#125;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://www.videolan.org" target="_blank" rel="external">VLC的官方网站</a>，VLC的源代码是用C语言实现的。我们这里用<code>C#</code>的封装——nVLC。<br><a href="]]>
    </summary>
    
      <category term="CSharp" scheme="http://kaiiak.github.io/tags/CSharp/"/>
    
      <category term="vlc" scheme="http://kaiiak.github.io/tags/vlc/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[通过pylirc实现红外控制]]></title>
    <link href="http://kaiiak.github.io/2015/11/14/%E9%80%9A%E8%BF%87pylirc%E5%AE%9E%E7%8E%B0%E7%BA%A2%E5%A4%96%E6%8E%A7%E5%88%B6/"/>
    <id>http://kaiiak.github.io/2015/11/14/通过pylirc实现红外控制/</id>
    <published>2015-11-14T12:39:40.000Z</published>
    <updated>2015-11-14T13:31:45.495Z</updated>
    <content type="html"><![CDATA[<h2 id="官方文档">官方文档</h2><p>在2005年更新的官方文档，点击<a href="http://bazaar.launchpad.net/~rockstar/pylirc2/trunk/view/head:/doc/simple.txt" target="_blank" rel="external">这里</a>.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyLirc v0.0.5&#10;&#10;Introduction&#10;&#10;pyLirc is a module for Python that interacts with lirc to give &#10;Python programs the ability to receive commands from remote &#10;controls.&#10;&#10;This isn&#39;t much of documentation, but at least it&#39;s a start and&#10;there isn&#39;t much to document right now anyway.&#10;&#10;&#10;Initialization&#10;&#10;Before you can receive any commands from lirc, you&#39;ll need to &#10;initialize the module. After importing pyLirc, call the pylirc.init()&#10;function:&#10;&#10;   import pylirc&#10;&#10;   integer = pylirc.init(string name[, string configuration [, integer blocking ]])&#10;&#10;the returnvalue is the returnvalue of lircs client library&#10;lirc_init(), ie a socket, or zero on failure.&#10;&#10;The socket can be used with select.select() to wait for data if you don&#39;t&#10;want to use blocking. This is especially useful in multithreaded programs&#10;as blocking mode of pylirc will blick all threads, whereas select() will&#10;only block the current and with optional timeout.&#10;&#10;name: the name used for your program in the lirc configuration&#10;file, must be supplied.&#10;&#10;configuration:  a filename to a lirc configuration file in case you wish not to&#10;use lircs default configuration file (usually ~/.lircrc).&#10;&#10;blocking: a flag indicating wether you want blocking mode or not. See also &#10;blocking() and select.select() (latter in python docs)&#10;&#10;&#10;Polling&#10;&#10;If initialization was ok, you can poll lirc for commands. To read any commands&#10;in queue call pylirc.nextcode():&#10;&#10;   list = pylirc.nextcode([integer Exteneded])&#10;&#10;The returnvalue is &#39;None&#39;, if no commands was on the queue, or a list&#10;containing the commands read.&#10;&#10;To get the commands one by one enumerate the list:&#10;&#10;   for code in list:&#10;      print code&#10;&#10;If you supply the optional argument Extended as true, code will be a dictionary&#10;otherwise it will be a string (old behaviour).&#10;&#10;The dictionary currently contains:&#10;&#34;config&#34;: The config string from lirc config file - the same string you&#39;d get in&#10;          non-extended mode.&#10;&#34;repeat&#34;: The repeat count of the buttonpress.&#10;      &#10;Note, that there can still be more commands on queue after a call&#10;to pylirc.nextcode(). You should call it in a loop until you get&#10;&#39;None&#39; back.&#10;&#10;&#10;Exiting&#10;&#10;When you&#39;re done using pyLirc and before you exit your program you&#10;should clean up:&#10;&#10;   pylirc.exit()&#10;&#10;&#10;Changing mode&#10;&#10;When you initialize pyLirc, you can chose wether you want blocking or&#10;non-blocking mode. Blocking mode means pylirc.nextcode() waits until&#10;there is a command to be read until it returns.&#10;To change mode after initialization, use blocking():&#10;&#10;   success = pylirc.blocking(int)</span><br></pre></td></tr></table></figure>
<h2 id="中文翻译">中文翻译</h2><p>自己尝试翻译一下，英语渣渣，有不正确的地方请指正。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyLirc v0.0.5&#10;&#10;&#20171;&#32461;&#10;&#10;pyLirc&#26159;&#19968;&#20010;&#19982;LIRC&#20132;&#20114;&#32473;&#10;Python&#31243;&#24207;&#20174;&#36828;&#31243;&#25509;&#25910;&#36828;&#31243;&#21629;&#20196;&#30340;&#33021;&#21147;&#10;&#30340;Python&#27169;&#22359;&#12290;&#10;&#10;&#36825;&#26159;&#27809;&#26377;&#22826;&#22810;&#30340;&#25991;&#26723;&#65292;&#27605;&#31455;&#23427;&#26159;&#19968;&#20010;&#26032;&#39033;&#30446;&#65292;&#10;&#29616;&#22312;&#21453;&#27491;&#27809;&#26377;&#22826;&#22810;&#30340;&#25991;&#26723;&#12290;&#10;&#10;&#21021;&#22987;&#21270;&#10;&#10;&#22312;&#25509;&#21463;&#26469;&#33258;lirc&#30340;&#21629;&#20196;&#20043;&#21069;&#65292;&#20320;&#24212;&#35813;&#21021;&#22987;&#21270;&#26412;&#27169;&#22359;&#12290;&#22312; import pylirc&#20043;&#21518;&#65292;&#20351;&#29992; pylirc.inti()&#20989;&#25968;&#65306;&#10;&#9;import pylirc&#10;&#9;integer = pylirc.init(string name[, string configuration [, integer blocking ]])&#10;&#36820;&#22238;&#20540;&#26159;&#23458;&#25143;&#31471;&#24211;&#20013;lirc_init()&#20989;&#25968;&#30340;&#36820;&#22238;&#20540;&#65292;&#26159;&#19968;&#20010;socket&#65292;&#22914;&#26524;&#36820;&#22238;&#20540;&#26159;0&#65292;&#21017;&#21021;&#22987;&#21270;&#22833;&#36133;&#12290;</span><br></pre></td></tr></table></figure>
<h1 id="示例代码">示例代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> pylirc</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Buttons</span>:</span></span><br><span class="line">    SELECT = <span class="number">0</span></span><br><span class="line">    RIGHT = <span class="number">1</span></span><br><span class="line">    DOWN = <span class="number">2</span></span><br><span class="line">    UP = <span class="number">3</span></span><br><span class="line">    LEFT = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, app, conf)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pylirc.init(app, conf, <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"Unable to init pylirc"</span>);</span><br><span class="line">        pylirc.blocking(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">readButton</span><span class="params">(self)</span>:</span></span><br><span class="line">        btn = pylirc.nextcode()</span><br><span class="line">        <span class="keyword">if</span> btn:</span><br><span class="line">            <span class="keyword">return</span> btn[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="官方文档">官方文档</h2><p>在2005年更新的官方文档，点击<a href="http://bazaar.launchpad.net/~rockstar/pylirc2/trunk/view/head:/doc/simple.txt" target="_b]]>
    </summary>
    
      <category term="pylirc" scheme="http://kaiiak.github.io/tags/pylirc/"/>
    
      <category term="树莓派" scheme="http://kaiiak.github.io/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[为Eclipse本地安装PyDev]]></title>
    <link href="http://kaiiak.github.io/2015/11/09/local-install-pydev-with-eclipse/"/>
    <id>http://kaiiak.github.io/2015/11/09/local-install-pydev-with-eclipse/</id>
    <published>2015-11-09T11:05:57.000Z</published>
    <updated>2015-11-09T11:31:35.282Z</updated>
    <content type="html"><![CDATA[<h3 id="由于众所周知的原因，国内的网络环境一直不是很好。最近我在Eclipse上安装Pydev也不可以了。所以，打算用本地安装的方法来解决。">由于众所周知的原因，国内的网络环境一直不是很好。最近我在Eclipse上安装Pydev也不可以了。所以，打算用本地安装的方法来解决。</h3><p>可以在<a href="http://sourceforge.net/projects/pydev" target="_blank" rel="external">这里</a>下载到最新的PyDev for Eclipse。<br>然后，将压缩包内的<code>features</code>和<code>plugins</code>文件夹拷贝到eclipse的安装目录下。重启eclipse，在<code>Help</code>-&gt;<code>About Eclipse</code>-&gt;<code>Installation Details</code>中看到PyDev的信息。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="由于众所周知的原因，国内的网络环境一直不是很好。最近我在Eclipse上安装Pydev也不可以了。所以，打算用本地安装的方法来解决。">由于众所周知的原因，国内的网络环境一直不是很好。最近我在Eclipse上安装Pydev也不可以了。所以，打算用本地安装的方法来解]]>
    </summary>
    
      <category term="Eclipse" scheme="http://kaiiak.github.io/tags/Eclipse/"/>
    
      <category term="PyDev" scheme="http://kaiiak.github.io/tags/PyDev/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Sqlite创建数据库]]></title>
    <link href="http://kaiiak.github.io/2015/11/04/sqlite-create-datebase/"/>
    <id>http://kaiiak.github.io/2015/11/04/sqlite-create-datebase/</id>
    <published>2015-11-04T13:53:54.000Z</published>
    <updated>2015-11-06T13:30:46.995Z</updated>
    <content type="html"><![CDATA[<p>其实很简单，但刚开始一点都不会。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$sqlite test.db&#10;SQLite version 2.8.17&#10;Enter &#34;.help&#34; for instructions&#10;sqlite&#62; .database&#10;seq  name             file                                                      &#10;---  ---------  -------------------------&#10;0    main        /home/pi/code/testDB.db</span><br></pre></td></tr></table></figure></p>
<p>这样就创建成功了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>其实很简单，但刚开始一点都不会。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="cod]]>
    </summary>
    
      <category term="sqlite" scheme="http://kaiiak.github.io/tags/sqlite/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ZOJ_1003:Crashing Ballon]]></title>
    <link href="http://kaiiak.github.io/2015/11/04/crashing-ballon/"/>
    <id>http://kaiiak.github.io/2015/11/04/crashing-ballon/</id>
    <published>2015-11-04T12:15:01.000Z</published>
    <updated>2015-11-04T13:07:12.484Z</updated>
    <content type="html"><![CDATA[<h1 id="题目">题目</h1><blockquote>
<p>On every June 1st, the Children’s Day, there will be a game named “crashing balloon” on TV.   The rule is very simple.  On the ground there are 100 labeled balloons, with the numbers 1 to 100.  After the referee shouts “Let’s go!” the two players, who each starts with a score of  “1”, race to crash the balloons by their feet and, at the same time, multiply their scores by the numbers written on the balloons they crash.  After a minute, the little audiences are allowed to take the remaining balloons away, and each contestant reports his\her score, the product of the numbers on the balloons he\she’s crashed.  The unofficial winner is the player who announced the highest score.</p>
<p>Inevitably, though, disputes arise, and so the official winner is not determined until the disputes are resolved.  The player who claims the lower score is entitled to challenge his\her opponent’s score.  The player with the lower score is presumed to have told the truth, because if he\she were to lie about his\her score, he\she would surely come up with a bigger better lie.  The challenge is upheld if the player with the higher score has a score that cannot be achieved with balloons not crashed by the challenging player.  So, if the challenge is successful, the player claiming the lower score wins.</p>
<p>So, for example, if one player claims 343 points and the other claims 49, then clearly the first player is lying; the only way to score 343 is by crashing balloons labeled 7 and 49, and the only way to score 49 is by crashing a balloon labeled 49.  Since each of two scores requires crashing the balloon labeled 49, the one claiming 343 points is presumed to be lying.</p>
<p>On the other hand, if one player claims 162 points and the other claims 81, it is possible for both to be telling the truth (e.g. one crashes balloons 2, 3 and 27, while the other crashes balloon 81), so the challenge would not be upheld.</p>
<p>By the way, if the challenger made a mistake on calculating his/her score, then the challenge would not be upheld. For example, if one player claims 10001 points and the other claims 10003, then clearly none of them are telling the truth. In this case, the challenge would not be upheld.</p>
<p>Unfortunately, anyone who is willing to referee a game of crashing balloon is likely to get over-excited in the hot atmosphere that he\she could not reasonably be expected to perform the intricate calculations that refereeing requires.  Hence the need for you, sober programmer, to provide a software solution.</p>
<p>Input</p>
<p>Pairs of unequal, positive numbers, with each pair on a single line, that are claimed scores from a game of crashing balloon.<br>Output</p>
<p>Numbers, one to a line, that are the winning scores, assuming that the player with the lower score always challenges the outcome.<br>Sample Input</p>
<p>343 49<br>3599 610<br>62 36</p>
<p>Sample Output</p>
<p>49<br>610<br>62</p>
</blockquote>
<h1 id="代码">代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=1003</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> f1, f2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> numa, <span class="keyword">int</span> numb, <span class="keyword">int</span> k)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(numb == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        f2 = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(numa == <span class="number">1</span>) f1 = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(k == <span class="number">1</span> || (f1 &amp;&amp; f2)) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(numa % k == <span class="number">0</span>) dfs(numa / k, numb, k - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(numb % k == <span class="number">0</span>) dfs(numa, numb / k, k - <span class="number">1</span>);</span><br><span class="line">	dfs(numa, numb, k - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a, b;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b) != EOF)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(a &lt; b) swap(a, b);</span><br><span class="line">		f1 = f2 = <span class="literal">false</span>;</span><br><span class="line">		dfs(a, b, <span class="number">100</span>);</span><br><span class="line">		<span class="keyword">if</span>(!f1 &amp;&amp; f2) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,b);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="题目">题目</h1><blockquote>
<p>On every June 1st, the Children’s Day, there will be a game named “crashing balloon” on TV.   The rule is]]>
    </summary>
    
      <category term="ACM" scheme="http://kaiiak.github.io/tags/ACM/"/>
    
      <category term="C" scheme="http://kaiiak.github.io/tags/C/"/>
    
      <category term="ZOJ" scheme="http://kaiiak.github.io/tags/ZOJ/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于树莓派lirc的配置]]></title>
    <link href="http://kaiiak.github.io/2015/10/31/%E5%85%B3%E4%BA%8E%E6%A0%91%E8%8E%93%E6%B4%BElirc%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    <id>http://kaiiak.github.io/2015/10/31/关于树莓派lirc的配置/</id>
    <published>2015-10-31T13:10:19.000Z</published>
    <updated>2015-11-01T12:02:55.707Z</updated>
    <content type="html"><![CDATA[<h2 id="记录原因">记录原因</h2><p>这是我正在DIY的一个<a href="https://github.com/kaiiak/NineSky/blob/master/README.md" target="_blank" rel="external">基于树莓派智能家居</a>的过程中，配置lirc的一个小问题的总结。<br>因为在网上搜索到的类似的博客给出的解决方式都不可行，所以打算记录下来，方便后来者。</p>
<h2 id="事情的起因">事情的起因</h2><p>安装lirc——一个开源的红外控制的库<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install lirc</span><br></pre></td></tr></table></figure></p>
<p>配置到这一步时，网络上给出的下一步都是在</p>
<blockquote>
<p>加载内核模块<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo modprobe lirc_rpi gpio_in_pin=23gpio_out_pin=24</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>然而照着做以后，并不能成功。</p>
<h2 id="解决方法">解决方法</h2><p>配置树莓派的lirc，需要在<code>/boot/config.txt</code>中添加，在<a href="https://github.com/raspberrypi/firmware/blob/master/boot/overlays/README" target="_blank" rel="external">这里</a>找到的。<br><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dtoverlay=lirc-rpi,gpio<span class="number">_</span><span class="keyword">in</span><span class="number">_p</span><span class="keyword">in</span>=<span class="number">23</span>,gpio<span class="number">_</span><span class="keyword">out</span><span class="number">_p</span><span class="keyword">in</span>=<span class="number">24</span></span><br></pre></td></tr></table></figure></p>
<p>然后重启就可以了。</p>
<p>加载lir_rpi内核模块<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo modprobe lirc_rpi</span><br></pre></td></tr></table></figure></p>
<p>测试<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mode2 -d /dev/lirc0</span><br></pre></td></tr></table></figure></p>
<p>现在就会看到一大串space和pulse交替产生。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="记录原因">记录原因</h2><p>这是我正在DIY的一个<a href="https://github.com/kaiiak/NineSky/blob/master/README.md" target="_blank" rel="external">基于树莓派智]]>
    </summary>
    
      <category term="Linux" scheme="http://kaiiak.github.io/tags/Linux/"/>
    
      <category term="lirc" scheme="http://kaiiak.github.io/tags/lirc/"/>
    
      <category term="树莓派" scheme="http://kaiiak.github.io/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用Python控制树莓派的GPIO(1)]]></title>
    <link href="http://kaiiak.github.io/2015/10/18/%E4%BD%BF%E7%94%A8Python%E6%8E%A7%E5%88%B6%E6%A0%91%E8%8E%93%E6%B4%BE%E7%9A%84GPIO-1/"/>
    <id>http://kaiiak.github.io/2015/10/18/使用Python控制树莓派的GPIO-1/</id>
    <published>2015-10-18T09:19:07.000Z</published>
    <updated>2015-10-20T13:21:15.045Z</updated>
    <content type="html"><![CDATA[<h3 id="使用的树莓派2B">使用的树莓派2B</h3><p>通过PRI.GPIO来实现Python控制树莓派的GPIO。</p>
<h2 id="安装">安装</h2><p>在<a href="http://pythonhosted.org/RPIO/" target="_blank" rel="external">官方文档</a>中给出了三种按章方式。分别是</p>
<h3 id="用_easy_install或者pip来安装：">用 <code>easy_install</code>或者<code>pip</code>来安装：</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python-setuptools&#10;sudo easy_install -U RPIO</span><br></pre></td></tr></table></figure>
<h3 id="从Github上克隆然后安装">从Github上克隆然后安装</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/metachris/RPIO.git&#10;cd RPIO&#10;sudo python setup.py install</span><br></pre></td></tr></table></figure>
<h3 id="从Github或者别处下载安装">从Github或者别处下载安装</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L https://github.com/metachris/RPIO/archive/master.tar.gz | tar -xz&#10;cd RPIO-master&#10;sudo python setup.py install</span><br></pre></td></tr></table></figure>
<h2 id="使用">使用</h2><p><img src="http://ww1.sinaimg.cn/mw690/ae94c92cgw1ex5fscddh0j20fi0bigqz.jpg" alt="树莓派引脚图"><br><img src="http://ww3.sinaimg.cn/mw690/ae94c92cgw1ex6qv7sjpoj20jq0c6gps.jpg" alt="树莓派2B引脚图"></p>
<p>这是用wiringPi生成的引脚图，用wiringPi控制GPIO会在以后写。</p>
<p>树莓派的GPIO大致可以分为INPUT和OUTPUT两种状态。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> RPIO</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置为输入位无上拉</span></span><br><span class="line">RPIO.setup(<span class="number">7</span>, RPIO.IN)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置为输出位有上拉. 可以设置为</span></span><br><span class="line"><span class="comment"># PUD_UP(上拉), PUD_DOWN(下拉) or PUD_OFF (default)</span></span><br><span class="line">RPIO.setup(<span class="number">7</span>, RPIO.IN, pull_up_down=RPIO.PUD_UP)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取GPIO7的输入状态</span></span><br><span class="line">input_value = RPIO.input(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置GPIO为输出位</span></span><br><span class="line">RPIO.setup(<span class="number">8</span>, RPIO.OUT)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置GPIO8为高电位</span></span><br><span class="line">RPIO.output(<span class="number">8</span>, <span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置为输出位并给予一个初始值</span></span><br><span class="line">RPIO.setup(<span class="number">8</span>, RPIO.OUT, initial=RPIO.LOW)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 改变为BOARD编号模式</span></span><br><span class="line">RPIO.setmode(RPIO.BOARD)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在通道17上设置软件上拉</span></span><br><span class="line">RPIO.set_pullupdn(<span class="number">17</span>, RPIO.PUD_UP)  <span class="comment"># new in RPIO</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得通道8的设置(IN、OUT、ALTo)</span></span><br><span class="line">RPIO.gpio_function(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复位所有由该程序设置过的通道，</span></span><br><span class="line"><span class="comment"># 并清除 GPIO 中断接口</span></span><br><span class="line">RPIO.cleanup()</span><br></pre></td></tr></table></figure>
<p>照着上一篇文章写的那样做，并不能成功。因为RPIO的最后一个release版本是2013年的，并不支持我的树莓派2B。</p>
<p>如果想在树莓派2B上运行，需要做这些工作<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install rpi.gpio&#10;sudo pip freeze</span><br></pre></td></tr></table></figure></p>
<p>如果有一行<code>RPi.GPIO==0.511</code>就说明安装成功了。</p>
<p>然后我们在新建<code>led.py</code>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> RPi.GPIO <span class="keyword">as</span> GPIO</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">LED = <span class="number">4</span> </span><br><span class="line"></span><br><span class="line">GPIO.setmode(GPIO.BCM)</span><br><span class="line">GPIO.setup(LED, GPIO.OUT)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"结束程序，请按CTRL+C"</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	<span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">		GPIO.output(LED, <span class="keyword">False</span>)</span><br><span class="line">		<span class="comment">#延时1s</span></span><br><span class="line">		time.sleep(<span class="number">1</span>)</span><br><span class="line">		GPIO.output(LED, <span class="keyword">True</span>)</span><br><span class="line">		time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">except</span> KeyboardInterrupt: <span class="comment"># 如果程序被CTRL+C结束</span></span><br><span class="line">	GPIO.cleanup()</span><br></pre></td></tr></table></figure></p>
<p>前几天搞不懂GPIO.setmode函数中的参数GPIO.BCM和GPIO.BOARD指的是什么。<br>后来知道BOARD指的是主板引脚编号，而BCM指的是BCM芯片的引脚编号，在本文的配图中有。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="使用的树莓派2B">使用的树莓派2B</h3><p>通过PRI.GPIO来实现Python控制树莓派的GPIO。</p>
<h2 id="安装">安装</h2><p>在<a href="http://pythonhosted.org/RPIO/" target="]]>
    </summary>
    
      <category term="PRI.GPIO" scheme="http://kaiiak.github.io/tags/PRI-GPIO/"/>
    
      <category term="Pyhon" scheme="http://kaiiak.github.io/tags/Pyhon/"/>
    
      <category term="树莓派" scheme="http://kaiiak.github.io/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用Xshell进行上传和下载]]></title>
    <link href="http://kaiiak.github.io/2015/10/12/%E4%BD%BF%E7%94%A8Xshell%E8%BF%9B%E8%A1%8C%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/"/>
    <id>http://kaiiak.github.io/2015/10/12/使用Xshell进行上传和下载/</id>
    <published>2015-10-12T13:13:53.000Z</published>
    <updated>2015-10-12T13:28:27.428Z</updated>
    <content type="html"><![CDATA[<p>在日常使用Xshell进行远程登录的时候，我们想通过Xshell在Windows和Linux之间便捷的进行文件传输，这时候我们可以使用 <code>rz</code> 或 <code>sz</code> 命令。</p>
<p>在树莓派上安装<code>rz</code>和<code>sz</code>命令。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> install lrzsz</span><br></pre></td></tr></table></figure>
<p>下载某个文件或文件夹<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sz</span> filename</span><br></pre></td></tr></table></figure></p>
<p><code>rz</code>直接把文件拖到Xshell上就可以了.</p>
<p><code>sz</code>和<code>rz</code>的帮助文档<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">rz version 0.12.21rc</span><br><span class="line">Usage: rz [options] [filename.if.xmodem]</span><br><span class="line">Receive files with ZMODEM/YMODEM/XMODEM protocol</span><br><span class="line">    (X) = option applies to XMODEM only</span><br><span class="line">    (Y) = option applies to YMODEM only</span><br><span class="line">    (Z) = option applies to ZMODEM only</span><br><span class="line">  -<span class="ruby">+, --append                append to existing files</span><br><span class="line"></span>  -<span class="ruby">a, --ascii                 <span class="constant">ASCII</span> transfer (change <span class="constant">CR</span>/<span class="constant">LF</span> to <span class="constant">LF</span>)</span><br><span class="line"></span>  -<span class="ruby">b, --binary                binary transfer</span><br><span class="line"></span>  -<span class="ruby"><span class="constant">B</span>, --bufsize <span class="constant">N</span>             buffer <span class="constant">N</span> bytes (<span class="constant">N</span>==<span class="symbol">auto:</span> buffer whole file)</span><br><span class="line"></span>  -<span class="ruby">c, --with-crc              <span class="constant">Use</span> <span class="number">16</span> bit <span class="constant">CRC</span> (<span class="constant">X</span>)</span><br><span class="line"></span>  -<span class="ruby"><span class="constant">C</span>, --allow-remote-commands allow execution of remote commands (<span class="constant">Z</span>)</span><br><span class="line"></span>  -<span class="ruby"><span class="constant">D</span>, --null                  write all received data to /dev/null</span><br><span class="line"></span>      -<span class="ruby">-delay-startup <span class="constant">N</span>       sleep <span class="constant">N</span> seconds before doing anything</span><br><span class="line"></span>  -<span class="ruby">e, --escape                <span class="constant">Escape</span> control characters (<span class="constant">Z</span>)</span><br><span class="line"></span>  -<span class="ruby"><span class="constant">E</span>, --rename                rename any files already existing</span><br><span class="line"></span>      -<span class="ruby">-errors <span class="constant">N</span>              generate <span class="constant">CRC</span> error every <span class="constant">N</span> bytes (debugging)</span><br><span class="line"></span>  -<span class="ruby">h, --help                  <span class="constant">Help</span>, print this usage message</span><br><span class="line"></span>  -<span class="ruby">m, --min-bps <span class="constant">N</span>             stop transmission <span class="keyword">if</span> <span class="constant">BPS</span> below <span class="constant">N</span></span><br><span class="line"></span>  -<span class="ruby"><span class="constant">M</span>, --min-bps-time <span class="constant">N</span>          <span class="keyword">for</span> at least <span class="constant">N</span> seconds (<span class="symbol">default:</span> <span class="number">120</span>)</span><br><span class="line"></span>  -<span class="ruby"><span class="constant">O</span>, --disable-timeouts      disable timeout code, wait forever <span class="keyword">for</span> data</span><br><span class="line"></span>      -<span class="ruby">-o-sync                open output file(s) <span class="keyword">in</span> synchronous write mode</span><br><span class="line"></span>  -<span class="ruby">p, --protect               protect existing files</span><br><span class="line"></span>  -<span class="ruby">q, --quiet                 quiet, no progress reports</span><br><span class="line"></span>  -<span class="ruby">r, --resume                try to resume interrupted file transfer (<span class="constant">Z</span>)</span><br><span class="line"></span>  -<span class="ruby"><span class="constant">R</span>, --restricted            restricted, more secure mode</span><br><span class="line"></span>  -<span class="ruby">s, --stop-at &#123;<span class="constant">HH</span><span class="symbol">:MM|+N</span>&#125;    stop transmission at <span class="constant">HH</span><span class="symbol">:MM</span> <span class="keyword">or</span> <span class="keyword">in</span> <span class="constant">N</span> seconds</span><br><span class="line"></span>  -<span class="ruby"><span class="constant">S</span>, --timesync              request remote time (<span class="symbol">twice:</span> set local time)</span><br><span class="line"></span>      -<span class="ruby">-syslog[=off]          turn syslog on <span class="keyword">or</span> off, <span class="keyword">if</span> possible</span><br><span class="line"></span>  -<span class="ruby">t, --timeout <span class="constant">N</span>             set timeout to <span class="constant">N</span> tenths of a second</span><br><span class="line"></span>      -<span class="ruby">-tcp-server            open socket, wait <span class="keyword">for</span> connection (<span class="constant">Z</span>)</span><br><span class="line"></span>      -<span class="ruby">-tcp-client <span class="constant">ADDR</span><span class="symbol">:PORT</span>  open socket, connect to ... (<span class="constant">Z</span>)</span><br><span class="line"></span>  -<span class="ruby">u, --keep-uppercase        keep upper <span class="keyword">case</span> filenames</span><br><span class="line"></span>  -<span class="ruby"><span class="constant">U</span>, --unrestrict            disable restricted mode (<span class="keyword">if</span> allowed to)</span><br><span class="line"></span>  -<span class="ruby">v, --verbose               be verbose, provide debugging information</span><br><span class="line"></span>  -<span class="ruby">w, --windowsize <span class="constant">N</span>          <span class="constant">Window</span> is <span class="constant">N</span> bytes (<span class="constant">Z</span>)</span><br><span class="line"></span>  -<span class="ruby"><span class="constant">X</span>  --xmodem                use <span class="constant">XMODEM</span> protocol</span><br><span class="line"></span>  -<span class="ruby">y, --overwrite             <span class="constant">Yes</span>, clobber existing file <span class="keyword">if</span> any</span><br><span class="line"></span>      -<span class="ruby">-ymodem                use <span class="constant">YMODEM</span> protocol</span><br><span class="line"></span>  -<span class="ruby"><span class="constant">Z</span>, --zmodem                use <span class="constant">ZMODEM</span> protocol</span><br><span class="line"></span></span><br><span class="line">short options use the same arguments as the long ones</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在日常使用Xshell进行远程登录的时候，我们想通过Xshell在Windows和Linux之间便捷的进行文件传输，这时候我们可以使用 <code>rz</code> 或 <code>sz</code> 命令。</p>
<p>在树莓派上安装<code>rz</code>和<]]>
    </summary>
    
      <category term="Linux" scheme="http://kaiiak.github.io/tags/Linux/"/>
    
      <category term="Xshell" scheme="http://kaiiak.github.io/tags/Xshell/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[树莓派直连电脑二三事]]></title>
    <link href="http://kaiiak.github.io/2015/10/11/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%9B%B4%E8%BF%9E%E7%94%B5%E8%84%91%E4%BA%8C%E4%B8%89%E4%BA%8B/"/>
    <id>http://kaiiak.github.io/2015/10/11/树莓派直连电脑二三事/</id>
    <published>2015-10-11T12:09:35.000Z</published>
    <updated>2015-10-11T13:22:11.439Z</updated>
    <content type="html"><![CDATA[<h2 id="解决方法">解决方法</h2><p>因为在学校的实验室网络不是很稳定，所以树莓派一直不能直接用网线连接网络。而且wpa_supplication真的很不稳定，莫名其妙的罢工好几次，每次只能重新写镜像。<br>种种原因选择了直连电脑的方法来联网,而我的电脑连接的是信号很弱的无线网，无奈条件太艰苦。</p>
<p>需要额外准备的东西就是一根直通线啦。好啦，接下来就是设置的时间了。</p>
<p>首先打开网络与共享中心-&gt;更改适配器设置-&gt;右击无线网络连接-&gt;属性-&gt;共享。<br>如图：<br>        <img src="http://ww2.sinaimg.cn/mw690/ae94c92cgw1ewxgxexpm2j20ah0camy8.jpg" alt="无线网络属性共享"><br>根据别人写的教程，做到这步就可以实现远程登录树莓派和树莓派访问外网了。但是我只能实现远程登录树莓派，访问外网实现不了。经过试验，是没有配置DNS服务器的原因，在本地连接的IPV4属性中添加DNS服务器就可以了。这里我使用的是OpenDNS。<br>        <img src="http://ww3.sinaimg.cn/mw690/ae94c92cgw1ewxgxrj8stj20bi0bxgn5.jpg" alt="IPV4属性"></p>
<h2 id="原理">原理</h2><p>windows实现直连访问的技术叫做ICS，百科上的解释如下：</p>
<blockquote>
<p>ICS即Internet连接共享(InternetConnectionSharing)的英文简称，是Windows系统针对家庭网络或小型的Intranet网络提供的一种Internet连接共享服务。它实际上相当于一种网络地址转换器，所谓网络地址转换器就是当数据包向前传递的过程中，可以转换数据包中的IP地址和TCP/UDP端口等地址信息。有了网络地址转换器，家庭网络或小型的办公网络中的电脑就可以使用私有地址，并且通过网络地址转换器将私有地址转换成ISP分配的单一的公用IP地址从而实现对Internet的连接。ICS方式也称之为Internet转换连接。</p>
</blockquote>
<p>这里是<a href="http://windows.microsoft.com/zh-cn/windows/using-internet-connection-sharing#1TC=windows-7" target="_blank" rel="external">在微软的官方帮助文档</a>中对ICS的介绍，使用它也可以连接路由器使用。</p>
<h3 id="推荐阿里和中科大的的树莓派镜像">推荐阿里和中科大的的树莓派镜像</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deb <span class="symbol">http:</span>/<span class="regexp">/mirrors.aliyun.com/raspbian</span><span class="regexp">/raspbian/</span>   wheezy main contrib non-free rpi</span><br><span class="line">deb <span class="symbol">http:</span>/<span class="regexp">/mirrors.ustc.edu.cn/raspbian</span><span class="regexp">/raspbian/</span>   wheezy main contrib non-free rpi</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="解决方法">解决方法</h2><p>因为在学校的实验室网络不是很稳定，所以树莓派一直不能直接用网线连接网络。而且wpa_supplication真的很不稳定，莫名其妙的罢工好几次，每次只能重新写镜像。<br>种种原因选择了直连电脑的方法来联网,而我的电脑连接的是信]]>
    </summary>
    
      <category term="树莓派" scheme="http://kaiiak.github.io/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[打算买个小米路由刷openWRT]]></title>
    <link href="http://kaiiak.github.io/2015/08/05/%E6%89%93%E7%AE%97%E4%B9%B0%E4%B8%AA%E6%9E%81%E8%B7%AF%E7%94%B1%E5%88%B7openWRT/"/>
    <id>http://kaiiak.github.io/2015/08/05/打算买个极路由刷openWRT/</id>
    <published>2015-08-05T09:28:20.000Z</published>
    <updated>2015-08-05T13:07:03.017Z</updated>
    <content type="html"><![CDATA[<p>主要是因为学校的天翼客户端不能用路由器，这样的话我的树莓派就没法用了。<br>所以买个路由器刷openWRT，然后破解客户端，在openWRT上编写破解程序用路由器分享wifi。毕竟动态域名也是要一个外网ip的。<br>哈哈～<br>这是想象之中的，但愿我能坚持下来吧。<br>Thx～<br>然而在极路由和小米路由器mini之间我选择了小米路由mini。<br>毕竟第一次折腾openWRT，不是很敢自己刷。可以直接在他们定制的openWRT系统上折腾。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>主要是因为学校的天翼客户端不能用路由器，这样的话我的树莓派就没法用了。<br>所以买个路由器刷openWRT，然后破解客户端，在openWRT上编写破解程序用路由器分享wifi。毕竟动态域名也是要一个外网ip的。<br>哈哈～<br>这是想象之中的，但愿我能坚持下来吧。<b]]>
    </summary>
    
      <category term="openWRT" scheme="http://kaiiak.github.io/tags/openWRT/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[解决Yilia主题的subnav中链接的问题]]></title>
    <link href="http://kaiiak.github.io/2015/08/01/%E8%A7%A3%E5%86%B3Yilia%E4%B8%BB%E9%A2%98%E7%9A%84subnav%E4%B8%AD%E9%93%BE%E6%8E%A5%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://kaiiak.github.io/2015/08/01/解决Yilia主题的subnav中链接的问题/</id>
    <published>2015-07-31T16:11:23.000Z</published>
    <updated>2015-07-31T18:07:04.429Z</updated>
    <content type="html"><![CDATA[<h2 id="问题说明">问题说明</h2><p>我很喜欢Yilia这个漂亮的主题，但是当我自己用的时候发现在subnav区生成的链接并不是我想要的。比如我的github地址是<code>github.com/kaiiak</code>，但是实际生成的是<code>kaiiak.github.io/github.com/kaiiak</code>。微博地址也是这样，邮箱地址也是。</p>
<h2 id="心路历程">心路历程</h2><p>我一点一点试验嘛，今天一晚上翻来覆去改了有30多次。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">subnav:</span><br><span class="line">  github: "https://github.com/kaiiak"</span><br><span class="line">  weibo:  "http://weibo.com/itkaikai"</span><br><span class="line">  #mail:   "itkaikai@gmail.com"</span><br></pre></td></tr></table></figure>
<p>  这时可以了，我以为是因为链接对齐了呢，可是我把mail那里的<code>#</code>去掉后，发现邮箱那一栏生成的地址还是没变啊。我又陷入了沉思～</p>
<h2 id="问题解决">问题解决</h2><p>解决的原因是我把git生成的diff看了一遍，发现微博那一栏在没加<code>http://</code>时，生成的html代码是这样的<code>/weibo.com/itkaikai</code>，加了<code>http://</code>后生成的html代码就变成了<code>http://weibo.com/itkaikai</code>了。看到这里，大家一定会明白了。<br>把subnav改成这样子就可以了。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">subnav:</span><br><span class="line">  github: "https://github.com/kaiiak"</span><br><span class="line">  weibo:  "http://weibo.com/itkaikai"</span><br><span class="line">  mail:   "mailto:itkaikai@gmail.com"</span><br></pre></td></tr></table></figure></p>
<h2 id="后记">后记</h2><p>把时间花费在打磨工具上有点很吃亏啊，还是等有钱买个vps好了。<br>晚安～</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="问题说明">问题说明</h2><p>我很喜欢Yilia这个漂亮的主题，但是当我自己用的时候发现在subnav区生成的链接并不是我想要的。比如我的github地址是<code>github.com/kaiiak</code>，但是实际生成的是<code>kaiiak]]>
    </summary>
    
      <category term="Hexo主题" scheme="http://kaiiak.github.io/tags/Hexo%E4%B8%BB%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[第一篇]]></title>
    <link href="http://kaiiak.github.io/2015/07/30/%E7%AC%AC%E4%B8%80%E7%AF%87/"/>
    <id>http://kaiiak.github.io/2015/07/30/第一篇/</id>
    <published>2015-07-30T15:59:17.000Z</published>
    <updated>2015-07-31T18:07:04.414Z</updated>
    <content type="html"><![CDATA[<h2 id="第一次在github上写博客">第一次在github上写博客</h2><p>哈哈，有点小兴奋呢</p>
<h3 id="测试下代码高亮">测试下代码高亮</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Hello World!\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最近在做ACM和准备电赛，多多加油！</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="第一次在github上写博客">第一次在github上写博客</h2><p>哈哈，有点小兴奋呢</p>
<h3 id="测试下代码高亮">测试下代码高亮</h3><figure class="highlight c"><table><tr><td class="g]]>
    </summary>
    
      <category term="随笔" scheme="http://kaiiak.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>