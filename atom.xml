<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[KAIIAK]]></title>
  <subtitle><![CDATA[啦啦啦，我是卖萌的小行家]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="https://kaiiak.github.io//"/>
  <updated>2016-06-04T12:13:51.576Z</updated>
  <id>https://kaiiak.github.io//</id>
  
  <author>
    <name><![CDATA[Kai]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[APUE学习笔记——进程控制]]></title>
    <link href="https://kaiiak.github.io/2016/04/27/APUE_study_notes-process-control/"/>
    <id>https://kaiiak.github.io/2016/04/27/APUE_study_notes-process-control/</id>
    <published>2016-04-27T15:08:52.000Z</published>
    <updated>2016-06-04T12:13:51.576Z</updated>
    <content type="html"><![CDATA[<h1 id="进程标识">进程标识</h1><p>每个进程都有一个非负整型表示的唯一进程ID。</p>
<ul>
<li>ID为0的进程通常是调度进程，常常被称为<code>交换进程(swapper)</code>。该进程是内核的一部分，它并不执行任何磁盘上的程序，因此被称为系统进程。</li>
<li>进程ID为1的通常是<code>init</code>进程，在自举过程结束时由内核调用。<code>init</code>进程决不会终止。它是一个普通的用户进程，但它以超级用户特权运行。</li>
<li>进程ID2是<code>页守护进程(page daemon)</code>，此进程负责支持虚拟存储器系统的分页操作。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> getpid(<span class="keyword">void</span>);     <span class="comment">/* 返回值：调用进程的进程ID */</span></span><br><span class="line"><span class="keyword">pid_t</span> getppid(<span class="keyword">void</span>);    <span class="comment">/* 返回值：调用进程的父进程ID */</span></span><br><span class="line"><span class="keyword">uid_t</span> getuid(<span class="keyword">void</span>);     <span class="comment">/* 返回值：调用进程的实际用户ID */</span></span><br><span class="line"><span class="keyword">uid_t</span> geteuid(<span class="keyword">void</span>);    <span class="comment">/* 返回值：调用进程的有效用户ID */</span></span><br><span class="line"><span class="keyword">gid_t</span> getgid(<span class="keyword">void</span>);     <span class="comment">/* 返回值：调用进程的实际组ID */</span></span><br><span class="line"><span class="keyword">gid_t</span> getegid(<span class="keyword">void</span>);    <span class="comment">/* 返回值：调用进程的有效组ID */</span></span><br></pre></td></tr></table></figure>
<h1 id="函数fork">函数<code>fork</code></h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> fork(<span class="keyword">void</span>);</span><br><span class="line"><span class="comment">/* 返回值：子进程返回0，父进程返回子进程ID；若出错，返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>由<code>fork</code>创建的新进程被称为<code>子进程(child process)</code>。<br>两次返回的区别是子进程的返回值是0，而父进程的返回值则是新建子进程的进程ID。<br>子进程和父进程继续执行<code>fork</code>调用之后的指令。子进程是父进程的副本。父进程和子进程共享正文段。<br>一般来说，<code>fork</code>之后是父进程先执行还是子进程先执行是不确定的。<br>在重定向父进程的标准输出时，子进程的标准输出也被重定向。<br>子进程和父进程共享一个文件偏移量。</p>
<h1 id="函数vfork">函数<code>vfork</code></h1><p>父进程和子进程共享数据段，并且先保诚子进程先运行，只有当子进程调用<code>exec</code>或<code>exit</code>后父进程才可能被调用运行。<br><em>调用vfork()后，子程序要么_exit(),要么调用exec()，否则都是未定义行为(UB)</em></p>
<h1 id="函数exit">函数<code>exit</code></h1><p>5种正常终止方式：</p>
<ol>
<li>在<code>main</code>函数内执行<code>return</code>语句。</li>
<li>调用<code>exit</code>函数。</li>
<li>调用<code>_exit</code>或<code>_Exit</code>函数。</li>
<li>进程的最后一个线程在其启动例程中执行<code>return</code>语句。</li>
<li>进程的最后一个线程调用<code>pthread_exit</code>函数。</li>
</ol>
<p>3种异常终止：</p>
<ol>
<li>调用<code>abort</code>。</li>
<li>当进程接收到某些信号时。</li>
<li>最后一个线程对“取消”(cancellation)请求作出响应。</li>
</ol>
<p>对于父进程已经终止的所有进程，它们的父进程都改为<code>init</code>进程，我们称为这些进程由<code>init</code>进程收养。</p>
<p>在UNIX术语中，一个已经终止、但是其父进程尚未对其进行善后处理(获取终止子进程的有关信息、释放它仍占用的资源)的进程被称为<code>僵死进程(zombie)</code>。</p>
<h1 id="函数wait和waitpid">函数<code>wait</code>和<code>waitpid</code></h1><p>当一个进程正常或异常终止时，内核就向其父进程发送<code>SIGCHLD</code>信号。</p>
<ul>
<li>如果其所有子进程都还在运行，则阻塞。</li>
<li>如果一个子进程终止，正等待父进程获取其终止状态，则取得该子进程的终止状态立即返回。</li>
<li><p>如果没有任何子进程，则立即出错返回。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> wait(<span class="keyword">int</span> *statloc);</span><br><span class="line"><span class="keyword">pid_t</span> waitpid(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *statloc, <span class="keyword">int</span> options);</span><br><span class="line"><span class="comment">/* 两个函数返回值：若成功，返回进程ID；若出错，返回0或-1 */</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在一个子进程终止前，<code>wait</code>使其调用者阻塞，而<code>waitpid</code>有一选项，可使调用者不阻塞。</p>
</li>
<li><code>waitpid</code>并不等待在其调用之后的第一个终止子进程，可以控制它所等待的进程。</li>
</ul>
<p>这两个函数的参数<code>statloc</code>是一个整型指针。如果<code>statloc</code>不是一个空指针，则终止进程的终止状态就存放在它所指向的单元内。</p>
<table>
<thead>
<tr>
<th style="text-align:center">宏</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">WIFEXITED(status)</td>
<td style="text-align:center">若为正常正常终止子进程返回的状态，则为真。对于这种情况可执行WIFEXITED(status)，获取子进程传送给exit或_exit参数的低8位</td>
</tr>
<tr>
<td style="text-align:center">WIFSIGNALED(status)</td>
<td style="text-align:center">若为异常终止子进程返回的状态，则为真(接到一个不捕捉的信号)。对于这种情况，可执行WIFSIGNALED(status)，则为真(接到一个不捕捉的信号)。对于这种情况，可执行()WTERMSIG(status),获取使子进程终止的信号编号。另外，有些实现(非Single UNIX Specification)定义宏WCOREDUMP(status),若已产生终止进程core文件，则它返回真</td>
</tr>
<tr>
<td style="text-align:center">WIFSTOPPED(status)</td>
<td style="text-align:center">若为当前暂停子进程的返回的状态，则为真。对于这种情况，可执行WSTOPSIG(status),获取使子进程暂停的信号编号</td>
</tr>
<tr>
<td style="text-align:center">WIFCONTINUED(status)</td>
<td style="text-align:center">若在作业控制暂停后已经继续的子进程返回了状态，则为真</td>
</tr>
</tbody>
</table>
<p><code>waitpid</code>函数中pid参数的作用解释如下：</p>
<ul>
<li>pid == -1 等待任一子进程。此种情况下，<code>wait</code>和<code>waitpid</code>等效。</li>
<li>pid &gt; 0   等待进程ID与pid相等的子进程。</li>
<li>pid == 0  等待组ID等于调用进程组ID的任一子进程。</li>
<li>pid &lt; -1  等待组ID等于pid绝对值的任一子进程。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">options常量</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">WCONTINUED</td>
<td style="text-align:center">若实现支持罪业控制，那么由pid制定的任一子进程在停止后已经继续，但其状态尚未报告，则返回其状态</td>
</tr>
<tr>
<td style="text-align:center">WNOHANG</td>
<td style="text-align:center">若由pid指定的子进程并不是立即可用的，则waitpid不阻塞，此时其返回值为0</td>
</tr>
<tr>
<td style="text-align:center">WUNTRACED</td>
<td style="text-align:center">若某实现支持作业控制，而由pid指定的任一子进程已处于停止状态，并且其状态由停止以来还没报告过，则返回其状态。WIFSTOPPED宏确定返回值是否对应于一个停止的子进程。</td>
</tr>
</tbody>
</table>
<h1 id="函数waittid">函数<code>waittid</code></h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">waittid</span><span class="params">(idtype_t idtype, id_t id, siginfo_t *infop, <span class="keyword">int</span> options)</span></span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回0；若出错，返回-1 */</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">idtype常量</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">P_PID</td>
<td style="text-align:center">等待一特定进程：id包含要等待子进程的进程ID</td>
</tr>
<tr>
<td style="text-align:center">P_PGID</td>
<td style="text-align:center">等待一特定进程组中的任一子进程：id包含要等待子进程的进程组ID</td>
</tr>
<tr>
<td style="text-align:center">P_ALL</td>
<td style="text-align:center">等待任一子进程：忽略id</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">options常量</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">WCONTINUED</td>
<td style="text-align:center">等待一进程，它以前曾被停止，此后又已继续，但其状态尚未报告</td>
</tr>
<tr>
<td style="text-align:center">WEXITED</td>
<td style="text-align:center">等待已退出的进程</td>
</tr>
<tr>
<td style="text-align:center">WNOHANG</td>
<td style="text-align:center">如无可用的子进程推出状态，立即返回而非阻塞</td>
</tr>
<tr>
<td style="text-align:center">WNOWAIT</td>
<td style="text-align:center">不破坏子进程退出状态。该子进程退出状态可由后续的wait、waitid或waitpid调用取得</td>
</tr>
<tr>
<td style="text-align:center">WSTOPPED</td>
<td style="text-align:center">等待一进程，它已经停止，但其状态尚未报告</td>
</tr>
</tbody>
</table>
<h1 id="函数wait3和wait4">函数<code>wait3</code>和<code>wait4</code></h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> wait3(<span class="keyword">int</span> *statloc, <span class="keyword">int</span> options, <span class="keyword">struct</span> rusage *rusage);</span><br><span class="line"><span class="keyword">pid_t</span> wait4(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *statloc, <span class="keyword">int</span> options, <span class="keyword">struct</span> rusage *rusage);</span><br><span class="line"><span class="comment">/* 两个函数返回值：若成功，返回进程ID；若出错，返回-1 */</span></span><br></pre></td></tr></table></figure>
<h1 id="函数exec">函数<code>exec</code></h1><p>调用<code>exec</code>并不创建新进程，所以前后的进程ID并没有改变。<code>exec</code>只是用磁盘上的一个新程序替换了当前进程的正文段、数据段、堆栈和栈段。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">const</span> <span class="keyword">char</span> *arg0, ... <span class="comment">/* (char *)0 */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execle</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">const</span> <span class="keyword">char</span> *arg0, ...</span><br><span class="line">    <span class="comment">/* (char *)0, char *const envp[] */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *arg0, ... <span class="comment">/* (char *)0 */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fexecve</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>;</span><br><span class="line"><span class="comment">/* 7个函数返回值：若出错，返回-1；若成功，不返回 */</span></span><br></pre></td></tr></table></figure>
<p>当<code>filename</code>作为参数时：</p>
<ul>
<li>如果<code>filename</code>中包含<code>/</code>，则将其设为路径名；</li>
<li>否则就按<code>PATH</code>环境变量，在她所指定的各目录搜寻可执行文件。</li>
</ul>
<p>execl,execle,execlp(结尾带l)要在可变参数结尾添加<code>(char *)0</code>。<br>execlp,execvp(结尾带p)表示第一个参数path不用输入完整路径，只有给出命令名即可，它会在环境变量PATH当中查找命令。<br>execv,execvp(不带l)表示命令所需的参数以char *arg[]形式给出且arg最后一个元素必须是NULL。</p>
<h1 id="更改用户ID和更改组ID">更改用户ID和更改组ID</h1><p>可以用<code>setuid</code>函数设置实际用户ID和有效用户ID；可以用<code>setgid</code>函数设置实际组ID和有效组ID。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setuid</span><span class="params">(uid_t uid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setgit</span><span class="params">(gid_t gid)</span></span>;</span><br><span class="line"><span class="comment">/* 两个函数返回值：若成功，返回0；若出错，返回-1 */</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li>若进程拥有超级用户权限，则setuid函数将实际用户ID、有效用户ID以及保存的设置用户ID设置为uid；</li>
<li>若进程没有超级用户权限，但是uid等于实际用户ID或保存的设置用户ID，则<code>setuid</code>只将有效用户ID设置为uid。不更改实际用户ID和保存的设置用户ID；</li>
<li><p>若以上两个条件都不满足，则<code>errno</code>设置为<code>EPERM</code>，并返回-1.</p>
</li>
<li><p>只有超级用户进程可以更改实际用户ID；</p>
</li>
<li>仅当对程序文件设置了设置用户ID位时，<code>exec</code>函数才设置有效用户ID；</li>
<li>保存的设置用户ID是由<code>ecec</code>复制有效用户ID而得到的。</li>
</ol>
<h2 id="函数setreuid和setregid">函数<code>setreuid</code>和<code>setregid</code></h2><p>功能是交换实际用户ID和有效用户ID<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setreuid</span><span class="params">(uid_t ruid, uid_t euid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setregid</span><span class="params">(gid_t rgid, gid_t egid)</span></span>;</span><br><span class="line"><span class="comment">/* 两个函数的返回值：若成功，返回0；若出错，返回-1 */</span></span><br></pre></td></tr></table></figure></p>
<p>如若其中任一参数的值为-1，则表示相应的ID应当保持不变。</p>
<h2 id="函数seteuid和setegid">函数<code>seteuid</code>和<code>setegid</code></h2><p>类似于<code>setuid</code>和<code>setgid</code>，但只更改有效用户ID和有效组ＩＤ。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">seteuid</span><span class="params">(uid_t uid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setegid</span><span class="params">(uid_t gid)</span></span>;</span><br><span class="line"><span class="comment">/* 两个函数的返回值：若成功，返回0；若出错，返回-1 */</span></span><br></pre></td></tr></table></figure></p>
<h1 id="函数system">函数<code>system</code></h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">system</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cmdstring)</span></span>;</span><br></pre></td></tr></table></figure>
<p>如果<code>cmdstring</code>是一个空指针，则仅当命令程序可用时，<code>system</code>返回非0值，这一特征可以确定在一个给定的操作系统上是否支持<code>system</code>函数。</p>
<ol>
<li><code>fork</code>失败或者<code>waitpid</code>返回处<code>EINTR</code>之外的出错，则<code>system</code>返回-1，并且设置<code>errno</code>以指示错误类型。</li>
<li>如果<code>exec</code>失败，则返回值如同shell执行了<code>exit(127)</code>一样。</li>
<li>否则所有3个函数(<code>fork</code>、<code>exec</code>和<code>waitpid</code>)都成功，那么<code>system</code>的返回值是shell的终止状态，其格式已在<code>waitpid</code>中说明。</li>
</ol>
<h1 id="进程会计(process_accounting)">进程会计(process accounting)</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> u_short <span class="keyword">comp_t</span>; <span class="comment">/* 3-bit base 8 exponent; 13-bit fraction */</span></span><br><span class="line"><span class="keyword">struct</span> acct</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> ac_flag;   <span class="comment">/* flag (see Figure 8.26) */</span></span><br><span class="line">    <span class="keyword">char</span> ac_stat;   <span class="comment">/* termination status (signal &amp; core flag only) */</span></span><br><span class="line">                    <span class="comment">/* (Solaris only) */</span></span><br><span class="line">    <span class="keyword">uid_t</span> ac_uid;   <span class="comment">/* real user ID */</span></span><br><span class="line">    <span class="keyword">gid_t</span> ac_gid;   <span class="comment">/* real group ID */</span></span><br><span class="line">    <span class="keyword">dev_t</span> ac_tty;   <span class="comment">/* controlling terminal */</span></span><br><span class="line">    <span class="keyword">time_t</span> ac_btime; <span class="comment">/* starting calendar time */</span></span><br><span class="line">    <span class="keyword">comp_t</span> ac_utime; <span class="comment">/* user CPU time */</span></span><br><span class="line">    <span class="keyword">comp_t</span> ac_stime; <span class="comment">/* system CPU time */</span></span><br><span class="line">    <span class="keyword">comp_t</span> ac_etime; <span class="comment">/* elapsed time */</span></span><br><span class="line">    <span class="keyword">comp_t</span> ac_mem;  <span class="comment">/* average memory usage */</span></span><br><span class="line">    <span class="keyword">comp_t</span> ac_io;   <span class="comment">/* bytes transferred (by read and write) */</span></span><br><span class="line">                    <span class="comment">/* "blocks" on BSD systems */</span></span><br><span class="line">    <span class="keyword">comp_t</span> ac_rw;   <span class="comment">/* blocks read or written */</span></span><br><span class="line">                    <span class="comment">/* (not present on BSD systems) */</span></span><br><span class="line">    <span class="keyword">char</span> ac_comm[<span class="number">8</span>]; <span class="comment">/* command name: [8] for Solaris, */</span></span><br><span class="line">                     <span class="comment">/* [10] for Mac OS X, [16] for FreeBSD, and */</span></span><br><span class="line">                     <span class="comment">/* [17] for Linux */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li>我们不能获取永远不终止的进程的会计记录；</li>
<li>在会计文件记录的顺序对应于进程终止的顺序，而不是它们启动的顺序；</li>
<li>会计记录对应于进程而不是程序。<code>exec</code>并不创建一个新的会计记录，但相应记录中的命令名称改变了，<code>AFORK</code>标志被清除。</li>
</ol>
<h1 id="用户标识">用户标识</h1><p>得到运行该程序的用户的登录名，当有多个用户名对应着一个用户ID时，通常返回用户登录时用的用户名。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getlogin</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回指向登陆名字符串的指针；若出错，返回NULL */</span></span><br></pre></td></tr></table></figure></p>
<h1 id="进程调度">进程调度</h1><p>进程可以通过调整<code>nice</code>值选择以最低优先级运行，只有特权进程允许提高调度权限。<br><code>nice</code>值的大小在0~(2<em>NZERO)-1之间，有些实现支持0~2</em>NZERO。<em>nice值越小，优先级越高</em>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nice</span><span class="params">(<span class="keyword">int</span> incr)</span></span>;</span><br><span class="line"><span class="comment">/*返回值：若成功，返回新的nice值NZERO；若出错，返回-18*/</span></span><br></pre></td></tr></table></figure></p>
<p><code>getpriority</code>函数可以像<code>nice</code>函数那样用户获取进程的<code>nice</code>值，但是<code>getpriority</code>还可以获取一组相关进程的<code>nice</code>值。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpriority</span><span class="params">(<span class="keyword">int</span> which, id_t who)</span></span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回-NZERO~NZERO-1之间的nice值；若出错，返回-1 */</span></span><br></pre></td></tr></table></figure></p>
<p><code>setpriority</code>函数可以用于为进程、进程组和属于特定用户ID的所有进程设置优先级。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setpriority</span><span class="params">(<span class="keyword">int</span> which, id_t who, <span class="keyword">int</span> value)</span></span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回0；若出错，返回-1 */</span></span><br></pre></td></tr></table></figure></p>
<h1 id="进程时间">进程时间</h1><p><code>times</code>函数获得它自己以及已终止子进程的墙上时钟时间、用户CPU时间和系统CPU时间。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/times.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">clock_t</span> times(<span class="keyword">struct</span> tms *buf);</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回墙上时钟时间(以时钟滴答数为单位)；若出错，返回-1 */</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> tms &#123;</span><br><span class="line">    <span class="keyword">clock_t</span> tms_utime;  <span class="comment">/* 用户CPU时间 */</span></span><br><span class="line">    <span class="keyword">clock_t</span> tms_stime;  <span class="comment">/* 系统CPU时间 */</span></span><br><span class="line">    <span class="keyword">clock_t</span> tms_cutime; <span class="comment">/* 子进程的用户CPU时间 */</span></span><br><span class="line">    <span class="keyword">clock_t</span> tms_cstiem; <span class="comment">/* 子进程的系统CPU时间 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="进程标识">进程标识</h1><p>每个进程都有一个非负整型表示的唯一进程ID。</p>
<ul>
<li>ID为0的进程通常是调度进程，常常被称为<code>交换进程(swapper)</code>。该进程是内核的一部分，它并不执行任何磁盘上的程序，因此被称为系]]>
    </summary>
    
      <category term="APUE" scheme="https://kaiiak.github.io/tags/APUE/"/>
    
      <category term="Linux" scheme="https://kaiiak.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[APUE学习笔记——进程环境]]></title>
    <link href="https://kaiiak.github.io/2016/04/07/APUE_study_notes-process-environment/"/>
    <id>https://kaiiak.github.io/2016/04/07/APUE_study_notes-process-environment/</id>
    <published>2016-04-07T15:35:06.000Z</published>
    <updated>2016-04-27T13:46:01.154Z</updated>
    <content type="html"><![CDATA[<h1 id="进程终止">进程终止</h1><ol>
<li><p>退出函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span></span>;</span><br><span class="line"><span class="keyword">void</span> _Exit(<span class="keyword">int</span> status);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _exit(<span class="keyword">int</span> status);</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数<code>atexit</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atexit</span><span class="params">(<span class="keyword">void</span> (*func)</span><span class="params">(<span class="keyword">void</span>)</span>)</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>其中，<code>atexit</code>的参数是一个函数地址，当调用此函数时无需向它传递任何参数，也不期望它返回一个值。<code>exit</code>调用这些函数的顺序与它们等级时候的顺序相反。同一函数如若登记多次也会被调用多次。</p>
<h1 id="环境表">环境表</h1><p>环境表也是一个字符指针数组，其中每个指针包含一个以<code>null</code>结束的C字符串的地址。全局变量<code>environ</code>则包含了该指针的数组的地址：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> **environ;</span><br></pre></td></tr></table></figure></p>
<p>我们称<code>environ</code>为<code>环境指针(environment pointer)</code>，指针数组为环境表，其中各指针指向的字符串为环境字符串。<br>通常用<code>getenv</code>和<code>putenv</code>函数来访问特定的环境变量，而不是<code>environ</code>变量。</p>
<h1 id="C程序的存储空间布局">C程序的存储空间布局</h1><ul>
<li>正文段。</li>
<li>初始化数据段。</li>
<li>未初始化数据段。</li>
<li>栈。</li>
<li>堆。</li>
</ul>
<h1 id="存储空间分配">存储空间分配</h1><ol>
<li><code>malloc</code>，分配指定字节的存储区。此存储区中的初始值不确定。</li>
<li><code>calloc</code>,为指定数量指定长度的对象分配存储空间。该空间中的每一位(bit)都初始化为0。</li>
<li><code>realloc</code>,增加或减少以前分配区的长度。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(size_t size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">calloc</span><span class="params">(size_t nobj, size_t size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">realloc</span><span class="params">(size_t nobj, size_t newsize)</span></span>;</span><br><span class="line"><span class="comment">/*</span><br><span class="line"> * 3个函数返回值：若成功，返回非空指针；若出错，返回NULL</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</span><br></pre></td></tr></table></figure>
<h1 id="环境变量">环境变量</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> **<span class="title">getenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"><span class="comment">/* 返回值：指向与name关联的value的指针；若未找到，返回NULL */</span></span><br></pre></td></tr></table></figure>
<p><code>getenv</code>,可以用其取环境变量值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putenv</span><span class="params">(<span class="keyword">char</span> *str)</span></span>;</span><br><span class="line"><span class="comment">/* 函数返回值：若成功，返回0；若出错，返回非0 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">char</span> *value, <span class="keyword">int</span> rewrite)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unsetenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"><span class="comment">/* 两个函数返回值：若成功，返回0；若出错，返回-1 */</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>putenv</code>取形式为<code>name=value</code>的字符串，将其放到环境中。</li>
<li><code>setenv</code>将<code>name</code>设置为<code>value</code>。如果在环境中<code>name</code>已存在,那么(a)若<code>rewrite</code>非0，则首先删除其现有的定义;(b)若<code>rewrite</code>为0，则不删除其现有定义(<code>name</code>不设置为新<code>value</code>,而且也不出错)。</li>
<li><code>unsetenv</code>删除<code>name</code>的定义。即使不存在这种定义与不出错。</li>
</ul>
<h1 id="函数setjmp和longjmp">函数<code>setjmp</code>和<code>longjmp</code></h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setjmp</span><span class="params">(jmp_buf env)</span></span>;</span><br><span class="line"><span class="comment">/* 返回值：若直接调用，返回0；若从longjmp返回，则为非0 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">longjmp</span><span class="params">(jmp_buf env, <span class="keyword">int</span> val)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在希望返回到的位置调用<code>setjmp</code>。当调用<code>longjmp</code>是，第一个参数是调用<code>setjmp</code>时的<code>env</code>;第二个参数是具有非0值的<code>val</code>,它将称为从<code>setjmp</code>处返回的值。<br>在课本的<a href="https://github.com/kaiiak/APUE/blob/master/chapter7/7.13.c" target="_blank" rel="external">例程7.13</a>中，全局变量、静态变量和易失变量(volatile variables)不受优化的影响。如果要编写一个使用非局部跳转的可移植程序，则必须使用<code>volatile</code>属性。但是一个系统移植到另一个系统，其他任何事情都可能改变。</p>
<h1 id="函数getrlimit和setrlimit">函数<code>getrlimit</code>和<code>setrlimit</code></h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getrlimit</span><span class="params">(<span class="keyword">int</span> resource, <span class="keyword">struct</span> rlimit *rlptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setrlimit</span><span class="params">(<span class="keyword">int</span> resource, <span class="keyword">const</span> <span class="keyword">struct</span> rlimit *rlptr)</span></span>;</span><br><span class="line"><span class="comment">/* 两个函数返回值：若成功，返回0；若出错，返回非0 */</span></span><br></pre></td></tr></table></figure>
<p>这两个函数的每一次调用都指定一个资源以及一个指向下列结构的指针。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> rlimit &#123;</span><br><span class="line">    <span class="keyword">rlim_t</span> rlim_cur;    <span class="comment">/* soft limit: current limit */</span></span><br><span class="line">    <span class="keyword">rlim_t</span> rlim_max;    <span class="comment">/* hard limit: maximum value for rlim_cur */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>任何一个进程都可以将一个限制值更改为小于或等于其硬限制值。</li>
<li>任何一个进程都可以降低其硬限制值，但它必须大于或等于其软限制值。</li>
<li>只有超级用户进程才可以提高硬限制值。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="进程终止">进程终止</h1><ol>
<li><p>退出函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><s]]>
    </summary>
    
      <category term="APUE" scheme="https://kaiiak.github.io/tags/APUE/"/>
    
      <category term="Linux" scheme="https://kaiiak.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[APUE学习笔记——格式化I/O]]></title>
    <link href="https://kaiiak.github.io/2016/03/29/APUE_study_notes-standard_IO_libray/"/>
    <id>https://kaiiak.github.io/2016/03/29/APUE_study_notes-standard_IO_libray/</id>
    <published>2016-03-29T13:53:18.000Z</published>
    <updated>2016-03-31T07:30:28.030Z</updated>
    <content type="html"><![CDATA[<h1 id="流和FILE对象">流和FILE对象</h1><p>对于<code>ASCII</code>字符集，一个字符用于一个字节表示。对于国际字符集，一个字符可用于多个字节表示。标准I/O文件流可用于单字节或多字节(“宽”)字符集。流的定向(stream’s orientation)决定了所读、所写的字符是单字节还是多字节。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;wchar.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fwide</span><span class="params">(FILE *fp, <span class="keyword">int</span> mode)</span></span>;</span><br><span class="line"><span class="comment">/*</span><br><span class="line"> * 返回值：若流是宽定向的，返回正值；</span><br><span class="line"> * 若流是字节定向的，返回负值；若流是未定向的，返回0</span><br><span class="line"> * 如果mode参数值为负，fwide将试图使指定的流是字节定向的。</span><br><span class="line"> * 如果mode参数值为正，fwide将试图使指定的流是宽定向的。</span><br><span class="line"> * 如果mode参数值为0，fwide将不试图设置流的定向，但返回标识该流定向的值。</span><br><span class="line"> */</span></span><br></pre></td></tr></table></figure></p>
<h1 id="标准输入、标准输出和标准错误">标准输入、标准输出和标准错误</h1><p>可以通过预定义文件指针<code>stdin</code>、<code>stdout</code>和<code>stderr</code>加以引用。</p>
<h1 id="缓冲">缓冲</h1><ul>
<li>全缓冲。在这种情况下，在填满标准I/O缓冲区才进行实际I/O操作。<pre><code>冲洗(flush)说明标准I/O缓冲区的写操作。也可以直接调用<span class="escape">`f</span>flush<span class="escape">`函</span>数冲洗一个流。在终端驱动程序中，<span class="escape">`f</span>lush(刷清)<span class="escape">`表</span>示丢弃已存储在缓冲区中的数据。
</code></pre></li>
<li>行缓冲。在这种情况下，当在输入和输出中遇到换行符时，标准I/O库执行I/O操作。</li>
<li>不带缓冲。标准I/O库不对字符进行缓冲存储。标准错误流<code>stderr</code>通常是不带缓冲的。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setbuf</span><span class="params">(FILE *<span class="keyword">restrict</span> fp, <span class="keyword">char</span> *<span class="keyword">restrict</span> buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setvbuf</span><span class="params">(FILE *<span class="keyword">restrict</span> fp, <span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">int</span> mode, size_t size)</span></span>;</span><br><span class="line"><span class="comment">/*</span><br><span class="line"> * 返回值：若成功，返回0；若出错，返回非0</span><br><span class="line"> */</span></span><br></pre></td></tr></table></figure>
<p>这两个函数可用于更改缓冲类型。</p>
<ul>
<li><code>_IOFBF</code> 全缓冲 </li>
<li><code>_IOLBF</code> 行缓冲</li>
<li><code>_IONBF</code> 不带缓冲</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fflush</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回0；若出错，返回EOF */</span></span><br></pre></td></tr></table></figure>
<h1 id="打开流">打开流</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> ptahname, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> type)</span></span>;</span><br><span class="line"><span class="function">FILE *<span class="title">freopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> type, FILE *<span class="keyword">restrict</span> fp)</span></span>;</span><br><span class="line"><span class="function">FILE *<span class="title">fdopen</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *type)</span></span>;</span><br><span class="line"><span class="comment">/* 3个函数的返回值：若成功，返回文件指针；若出错，返回NULL */</span></span><br></pre></td></tr></table></figure>
<ol>
<li><code>fopen</code>函数打开路径名为<code>pathname</code>的一个指定的文件。</li>
<li><code>freopen</code>函数在一个指定的流上打开一个指定的文件，如若该流已经打开，则先关闭该流。</li>
<li><code>fdopen</code>函数取一个已有的文件描述符，并使一个标准的I/O流与该描述符相结合。</li>
</ol>
<p>调用<code>fclose</code>关闭一个打开的流。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fclose</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回0；若返回，返回EOF */</span></span><br></pre></td></tr></table></figure></p>
<p><strong>在该文件被关闭之前，冲洗缓冲区中的输出数据。</strong></p>
<h1 id="读和写流">读和写流</h1><ol>
<li>输入函数<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getc</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetc</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getchar</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">/* 3个函数的返回值：若成功，返回下一个字符；若已到达文件尾端或出错，返回EOF */</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>函数<code>getchar</code>等同于<code>getc(stdin)</code>。前两个函数的区别是，<code>getc</code>可被实现为宏，而<code>fgetc</code>不能实现为宏。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ferror</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">feof</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"><span class="comment">/* 两个函数返回值：若条件为真，返回非0(真)；否则，返回0(假) */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearerr</span><span class="params">(FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure>
<p>为了区别是到达文件结尾还是出错。<br>例程<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    FILE*stream;</span><br><span class="line">    <span class="comment">/*openafileforwriting*/</span></span><br><span class="line">    stream=</span><br><span class="line">    fopen(<span class="string">"DUMMY.FIL"</span>,<span class="string">"w"</span>);</span><br><span class="line">    <span class="comment">/*forceanerrorconditionbyattemptingtoread*/</span></span><br><span class="line">    (<span class="keyword">void</span>)</span><br><span class="line">    getc(stream);</span><br><span class="line">    <span class="keyword">if</span>(ferror(stream))<span class="comment">/*testforanerroronthestream*/</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">/*displayanerrormessage*/</span></span><br><span class="line">     </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ErrorreadingfromDUMMY.FIL\n"</span>);</span><br><span class="line">    <span class="comment">/*resettheerrorandEOFindicators*/</span></span><br><span class="line">     </span><br><span class="line">    clearerr(stream);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    fclose(stream);</span><br><span class="line">    return0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从流中读取数据后，可以调用<code>ungetc</code>将字符再压送回流中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ungetc</span><span class="params">(<span class="keyword">int</span> c, FILE *fp)</span></span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回c；若出错，返回EOF */</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li>输出函数<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putc</span><span class="params">(<span class="keyword">int</span> c, FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputc</span><span class="params">(<span class="keyword">int</span> c, FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putchar</span><span class="params">(<span class="keyword">int</span> c)</span></span>;</span><br><span class="line"><span class="comment">/* 3个函数返回值：若成功，返回c;若出错，返回EOF */</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="每次一行I/O">每次一行I/O</h1><p>下面两个函数提供每次输入一行的功能。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">fgets</span><span class="params">(<span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">int</span> n, FILE *<span class="keyword">restrict</span> fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">gets</span><span class="params">(<span class="keyword">char</span> *buf)</span></span>;</span><br><span class="line"><span class="comment">/* 两个函数返回值：若成功，返回buf；若已到达文件尾端或出错，返回NULL */</span></span><br></pre></td></tr></table></figure></p>
<p><code>fgets</code>函数一直读到下一个换行符为止，但是不超过n-1个字符，读入的字符被送入缓冲区。</p>
<p><code>fputs</code>和<code>puts</code>提供每次输入一行的功能。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> str, FILE *<span class="keyword">restrict</span> fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">puts</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>;</span><br><span class="line"><span class="comment">/* 两个函数返回值：若成功，返回非负值；若出错，返回EOF */</span></span><br></pre></td></tr></table></figure></p>
<p>函数<code>fputs</code>将一个以null字节终止的字符串写到指定的流，尾端的终止符null不写出。</p>
<h1 id="二进制I/O">二进制I/O</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> fread(<span class="keyword">void</span> *<span class="keyword">restrict</span> ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nboj, FILE *<span class="keyword">restrict</span> fp);</span><br><span class="line"><span class="keyword">size_t</span> fwrite(<span class="keyword">const</span> <span class="keyword">void</span> *<span class="keyword">restrict</span> ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nobj, FILE *<span class="keyword">restrict</span> fp);</span><br><span class="line"><span class="comment">/* 两个函数的返回值：读或写的对象数 */</span></span><br></pre></td></tr></table></figure>
<p><strong>指定size为每个数组元素的长度，nobj为欲写元素个数</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 写数组 */</span></span><br><span class="line"><span class="keyword">float</span> data[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fwrite(&amp;data[<span class="number">2</span>], <span class="keyword">sizeof</span>(<span class="keyword">float</span>), <span class="number">4</span>, fp) != <span class="number">4</span>)</span><br><span class="line">    err_sys(<span class="string">"fwrite error"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 写一个结构体 */</span></span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">short</span>   count;</span><br><span class="line">    <span class="keyword">long</span>    total;</span><br><span class="line">    <span class="keyword">char</span>    name[NAMESIZE];</span><br><span class="line">&#125; item;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fwrite(&amp;item, <span class="keyword">sizeof</span>(item), <span class="number">1</span>, fp) != <span class="number">1</span>)</span><br><span class="line">    err_sys(<span class="string">"fwrite error"</span>);</span><br></pre></td></tr></table></figure></p>
<p><strong>使用二进制I/O的基本问题，它只能用于读在同一个系统上已写的数据</strong></p>
<h1 id="定位流(Positioning_a_Stream)">定位流(Positioning a Stream)</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ftell</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回当前文件位置指示；若出错，返回-1L */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseek</span><span class="params">(FILE *fp, <span class="keyword">long</span> offset, <span class="keyword">int</span> whence)</span></span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回0；若出错，返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rewind</span><span class="params">(FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>whence</code>的值与<code>lseek</code>函数的相同：<code>SEEK_SET</code>表示从文件的起始位置开始，<code>SEEK_CUR</code>表示从当前文件位置开始，<code>SEEK_END</code>表示从文件的尾端开始。<code>offset</code>，文件偏移量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">off_t</span> ftello(FILE *fp);</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回当前文件位置；若出错，返回(off_t)-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseeko</span><span class="params">(FILE *fp, off_t offset, <span class="keyword">int</span> whence)</span></span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回0；若出错，返回-1 */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetpos</span><span class="params">(FILE *<span class="keyword">restrict</span> fp, fpos_t *<span class="keyword">restrict</span> pos)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsetpos</span><span class="params">(FILE *fp, <span class="keyword">const</span> fpos_t *pos)</span></span>;</span><br><span class="line"><span class="comment">/* 两个函数返回值：若成功，返回0；若出错，返回非0 */</span></span><br></pre></td></tr></table></figure>
<h1 id="格式化I/O">格式化I/O</h1><ol>
<li>格式化输出<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fprintf</span><span class="params">(FILE *<span class="keyword">restrict</span> fp, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dprintf</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, ...)</span></span>;</span><br><span class="line"><span class="comment">/* 3个函数返回值：若成功，返回输入字符数；若出错，返回负值 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sprintf</span><span class="params">(<span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, ...)</span></span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回输入数组的字符数；若编码出错，返回负值 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snprintf</span><span class="params">(<span class="keyword">char</span> *<span class="keyword">restrict</span> buf, size_t n, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, ...)</span></span>;</span><br><span class="line"><span class="comment">/* 返回值：若缓冲区足够大，返回将要存入数组的字符数；若编码出错，返回负值 */</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>printf将格式化数据写到标准输出，fprintf写至指定的流，dprintf写至制定的文件描述符，sprintf将格式化的字符送入数组buf。</strong></p>
<p>下面5种<code>printf</code>族的变体，将可变参数表(…)替换成了arg。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vprintf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, va_list arg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfprintf</span><span class="params">(FILE *<span class="keyword">restrict</span> fp, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, va_list arg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vdprintf</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, va_list arg)</span></span>;</span><br><span class="line"><span class="comment">/* 3个函数返回值：若成功，返回输入字符数；若出错，返回负值 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vsprintf</span><span class="params">(<span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, va_list arg)</span></span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回输入数组的字符数；若编码出错，返回负值 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vsnprintf</span><span class="params">(<span class="keyword">char</span> *<span class="keyword">restrict</span> buf, size_t n, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, va_list arg)</span></span>;</span><br><span class="line"><span class="comment">/* 返回值：若缓冲区足够大，返回将要存入数组的字符数；若编码出错，返回负值 */</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li>格式化输入<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">scanf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fscanf</span><span class="params">(FILE *<span class="keyword">restrict</span> fp, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sscanf</span><span class="params">(<span class="keyword">const</span> *<span class="keyword">restrict</span> buf, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, ...)</span></span>;</span><br><span class="line"><span class="comment">/* 3个函数返回值：赋值的输入项数；若输入出错或在任一转换前已到达文件尾端，返回EOF */</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="临时文件">临时文件</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">tmpnam</span><span class="params">(<span class="keyword">char</span> *ptr)</span></span>;</span><br><span class="line"><span class="comment">/* 返回值：指向唯一路径名的指针 */</span></span><br><span class="line"></span><br><span class="line"><span class="function">FILE *<span class="title">tmpfile</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回文件指针；若出错，返回NULL */</span></span><br></pre></td></tr></table></figure>
<p><code>tmpnam</code>函数产生一个与现有文件名不同的一个有效路径名字符串。如果<code>ptr</code>是NULL，则产生的路径名存放在一个静态区中，指向该静态区的指针作为函数值返回。后续调用<code>tmpnam</code>会从写该静态区。如过<code>ptr</code>不是NULL，则认为它应该指向长度至少是<code>L_tmpnam</code>个字符的数组。所产生的路径名存放在该数组中，<code>ptr</code>也作为函数值返回。<br><code>tmpfile</code>创建一个临时二进制文件(wb+)，在关闭该文件或程序结束时将自动删除这种文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">mkdtemp</span><span class="params">(<span class="keyword">char</span> *<span class="keyword">template</span>)</span></span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回指向目录名的指针；若出错，返回NULL */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkstemp</span><span class="params">(<span class="keyword">char</span> *<span class="keyword">template</span>)</span></span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回文件描述符；若出错，返回-1 */</span></span><br></pre></td></tr></table></figure>
<p><code>mkdtemp</code>函数创建了一个目录，该目录有唯一的名字；<code>mkstemp</code>函数创建了一个文件，该文件有一个唯一的名字。<strong>名字是通过template字符串进行选择的。这个字符串后6位设置为XXXXXX的路径名。</strong></p>
<h1 id="内存流">内存流</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">FILE *<span class="title">fmemopen</span><span class="params">(<span class="keyword">void</span> *<span class="keyword">restrict</span> buf, size_t size, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> type)</span></span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回流指针；若出错，返回NULL */</span></span><br></pre></td></tr></table></figure>
<p><code>fmemopen</code>函数允许调用者提供缓冲区用于内存流：<code>buf</code>参数指向缓冲区的开始位置，<code>size</code>参数指定了缓冲区大小的字节数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function">FILE *<span class="title">open_memstream</span><span class="params">(<span class="keyword">char</span> **bufp, size_t *sizep)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;wchar.h&gt;</span></span></span><br><span class="line"><span class="function">FILE *<span class="title">open_wmemstream</span><span class="params">(wchar_t **bufp, size_t *sizep)</span></span>;</span><br><span class="line"><span class="comment">/* 两个函数的返回值：若成功，返回流指针；若出错，返回NULL */</span></span><br></pre></td></tr></table></figure>
<p><code>open_memstream</code>函数创建的流是面向字节的，<code>open_wmemstream</code>函数创建的流是面向宽字节的。</p>
<ul>
<li>创建的流只能打开；</li>
<li>不能指定自己的缓冲区，但可以分别通过<code>bufp</code>和<code>sizep</code>参数访问缓冲区地址和大小；</li>
<li>关闭后需要自行释放缓冲区；</li>
<li>对流添加字节会增加缓冲区大小。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="流和FILE对象">流和FILE对象</h1><p>对于<code>ASCII</code>字符集，一个字符用于一个字节表示。对于国际字符集，一个字符可用于多个字节表示。标准I/O文件流可用于单字节或多字节(“宽”)字符集。流的定向(stream’s orient]]>
    </summary>
    
      <category term="APUE" scheme="https://kaiiak.github.io/tags/APUE/"/>
    
      <category term="Linux" scheme="https://kaiiak.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[安装vim插件YouCompleteMe]]></title>
    <link href="https://kaiiak.github.io/2016/03/06/compile_YouCompleteMe_in_Ubuntu_64/"/>
    <id>https://kaiiak.github.io/2016/03/06/compile_YouCompleteMe_in_Ubuntu_64/</id>
    <published>2016-03-06T09:59:39.000Z</published>
    <updated>2016-03-07T04:17:03.299Z</updated>
    <content type="html"><![CDATA[<p><code>YouCompleteMe</code>是<code>vim</code>上非常好用的代码自动补全的插件。但是必须自己本机编译他，提高了门槛。<br>我的环境是<code>ubuntu15.10</code>，照着教程来：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule add https://github.com/Valloric/YouCompleteMe bundle/YouCompleteMe&#10;git submodule update --init --recursive -- bundle/YouCompleteMe</span><br></pre></td></tr></table></figure></p>
<p>然后编译：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd bundle/YouCompleteMe</span><br><span class="line">./install.sh --clang-completer</span><br></pre></td></tr></table></figure></p>
<p>但是我编译的时候出现了错误：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="number">87</span>%] Building CXX object ycm/CMakeFiles/ycm_core.dir/ClangCompleter/ClangCompleter.cpp.o</span><br><span class="line">In file included from /home/kai/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/BoostParts/boost/type_traits/ice.hpp:<span class="number">15</span>:<span class="number">0</span>,</span><br><span class="line">                 from /home/kai/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/BoostParts/boost/python/detail/def_helper.hpp:<span class="number">9</span>,</span><br><span class="line">                 from /home/kai/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/BoostParts/boost/python/<span class="keyword">class</span>.hpp:<span class="number">29</span>,</span><br><span class="line">                 from /home/kai/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/BoostParts/boost/python.hpp:<span class="number">18</span>,</span><br><span class="line">                 from /home/kai/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/ycm/ReleaseGil.h:<span class="number">21</span>,</span><br><span class="line">                 from /home/kai/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/ycm/ClangCompleter/ClangCompleter.cpp:<span class="number">28</span>:</span><br><span class="line">/home/kai/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/BoostParts/boost/type_traits/detail/ice_or.hpp:<span class="number">17</span>:<span class="number">71</span>: note: <span class="preprocessor">#<span class="keyword">pragma</span> message: NOTE: Use of this header (ice_or.hpp) is deprecated</span></span><br><span class="line"> <span class="preprocessor"># <span class="keyword">pragma</span> message(<span class="string">"NOTE: Use of this header (ice_or.hpp) is deprecated"</span>)</span></span><br><span class="line">                                                                       ^</span><br></pre></td></tr></table></figure></p>
<p>然后一直到最后。<br>这个是因为在编译<code>boost</code>时，出现了错误。</p>
<p>在这之前，脚本会自动下载<code>clang</code>，然后编译编译<code>boost</code>，而且编译出现了错误。这时我想为什么不用本机上已经安装好的的<code>clang</code>和<code>boost</code>呢？<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get instll clang&#10;sudo apt-get install libboost-all-dev</span><br></pre></td></tr></table></figure></p>
<p>然后执行<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./install.sh --clang-completer --system-libclang --system-boost</span><br></pre></td></tr></table></figure></p>
<p>而这一切都在<a href="https://github.com/Valloric/YouCompleteMe#freebsdopenbsd" target="_blank" rel="external">官方文档里有说明</a>，我折腾完才看到，所以认真读说明是很重要的。 :(</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><code>YouCompleteMe</code>是<code>vim</code>上非常好用的代码自动补全的插件。但是必须自己本机编译他，提高了门槛。<br>我的环境是<code>ubuntu15.10</code>，照着教程来：<br><figure class="h]]>
    </summary>
    
      <category term="Linux" scheme="https://kaiiak.github.io/tags/Linux/"/>
    
      <category term="YouCompleteMe" scheme="https://kaiiak.github.io/tags/YouCompleteMe/"/>
    
      <category term="vim" scheme="https://kaiiak.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自用vim配置文件]]></title>
    <link href="https://kaiiak.github.io/2016/03/05/personal_vimrc/"/>
    <id>https://kaiiak.github.io/2016/03/05/personal_vimrc/</id>
    <published>2016-03-05T08:49:30.000Z</published>
    <updated>2016-03-07T04:37:45.745Z</updated>
    <content type="html"><![CDATA[<h1 id="使用Pathogen管理插件">使用<code>Pathogen</code>管理插件</h1><p>推荐<a href="http://lostjs.com/2012/02/04/use-pathogen-and-git-to-manage-vimfiles/" target="_blank" rel="external">这篇教程</a>，使用<code>Pahtogen</code>+<code>Git</code>的方式管理插件和vim配置，方便vim的迁移和团队配置的统一。</p>
<h1 id="自用的vim配置文件">自用的vim配置文件</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">" 编码</span><br><span class="line"><span class="operator"><span class="keyword">set</span> <span class="keyword">encoding</span>=utf-<span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="string">" 避免以前版本的一些bug和局限</span><br><span class="line">set nocompatible</span><br><span class="line"></span><br><span class="line">"</span> 逐步搜索模式，对当前键入的字符进行搜索而不必等待键入完成,/b寻找b开头的。</span><br><span class="line"><span class="keyword">set</span> incsearch</span><br><span class="line"></span><br><span class="line"><span class="string">"自动识别文件类型</span><br><span class="line">"</span> <span class="keyword">set</span> filetype</span><br><span class="line"></span><br><span class="line"><span class="string">" 搜索时高亮显示找到文本</span><br><span class="line">set hlsearch</span><br><span class="line"></span><br><span class="line">"</span> 在<span class="keyword">Insert</span>模式下退格键何时可以删除光标之前的字符。三项内容分别指定了Vim可以删除位于行首的空格,断行,以及开始进入<span class="keyword">Insert</span>模式之前的位置。</span><br><span class="line"><span class="keyword">set</span> backspace=indent,eol,<span class="keyword">start</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">" 设置tab键为4个空格，设置当行之间交错时使用4个空格</span><br><span class="line">set tabstop=4</span><br><span class="line">set shiftwidth=4</span><br><span class="line"></span><br><span class="line">"</span> 匹配模式，左括号匹配右括号</span><br><span class="line"><span class="keyword">set</span> showmatch</span><br><span class="line"></span><br><span class="line"><span class="string">" 在覆盖一个文件之前备份该文件。但是对VMS系统除外,因为该系统已经为文件保存了老的版本。备份文件名由当前文件名加后辍"</span>~<span class="string">"组成。</span><br><span class="line">"</span> <span class="keyword">if</span> has(<span class="string">"vms"</span>)</span><br><span class="line"><span class="string">" set nobackup</span><br><span class="line">"</span> <span class="keyword">else</span></span><br><span class="line"><span class="string">" set backup</span><br><span class="line">"</span> endif</span><br><span class="line"></span><br><span class="line"><span class="string">" 设置冒号命令和搜索命令的命令历史列表的长度。</span><br><span class="line">set history=1000</span><br><span class="line"></span><br><span class="line">"</span> 总是在Vim窗口的右下角显示当前光标的行列信息。</span><br><span class="line"><span class="keyword">set</span> ruler</span><br><span class="line"></span><br><span class="line"><span class="string">" 在Vim窗口的右下角显示一个完整的命令已经完成的部分。比如说你键入"</span><span class="number">2</span><span class="keyword">f</span><span class="string">",Vim就会在你键入下一个要查找的字符之前显示已经键入的"</span><span class="number">2</span><span class="keyword">f</span><span class="string">"。一旦你接下来再键入一个字符比如"</span>w<span class="string">",那么一个完整的命令"</span><span class="number">2</span>fw<span class="string">"就会被Vim 执行,同时刚才显示的"</span><span class="number">2</span><span class="keyword">f</span><span class="string">"也将消失。</span><br><span class="line">set showcmd</span><br><span class="line"></span><br><span class="line">"</span> 语法高亮</span><br><span class="line">syntax <span class="keyword">on</span></span><br><span class="line"></span><br><span class="line"><span class="string">" 显示行号</span><br><span class="line">set nu</span><br><span class="line"></span><br><span class="line">"</span> 显示空格和TAB</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">list</span></span><br><span class="line"><span class="keyword">set</span> listchars=tab:&gt;-,trail:-</span><br><span class="line"></span><br><span class="line"><span class="string">" 凸显当前行</span><br><span class="line">set cursorline</span><br><span class="line"></span><br><span class="line">"</span> 检测文件类型</span><br><span class="line">filetype <span class="keyword">on</span></span><br><span class="line"></span><br><span class="line"><span class="string">" 启用鼠标</span><br><span class="line">set mouse=a</span><br><span class="line"></span><br><span class="line">"</span> 配色方案</span><br><span class="line"><span class="string">"colorscheme torte</span><br><span class="line"></span><br><span class="line">"</span> 以下为插件</span><br><span class="line"></span><br><span class="line"><span class="string">" 管理插件的插件pathogen</span><br><span class="line">call pathogen#infect()</span><br><span class="line"></span><br><span class="line">"</span> Powerline</span><br><span class="line"><span class="keyword">set</span> guifont=PowerlineSymbols\ <span class="keyword">for</span>\ Powerline</span><br><span class="line"><span class="keyword">set</span> nocompatible</span><br><span class="line"><span class="keyword">set</span> laststatus=<span class="number">2</span></span><br><span class="line"><span class="keyword">set</span> t_Co=<span class="number">256</span></span><br><span class="line">let <span class="keyword">g</span>:Powerline_symbols = <span class="string">'fancy'</span></span><br><span class="line"></span><br><span class="line"><span class="string">" NERDTree</span><br><span class="line">map &lt;F10&gt; :NERDTreeToggle&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">"</span> <span class="keyword">C</span>的编译和运行 </span><br><span class="line"><span class="keyword">map</span> &lt;F5&gt; :<span class="keyword">call</span> CompileRunGcc()&lt;CR&gt; </span><br><span class="line">func! CompileRunGcc() </span><br><span class="line">exec <span class="string">"w"</span> </span><br><span class="line">exec <span class="string">"!gcc % -o %&lt;"</span> </span><br><span class="line">exec <span class="string">"! ./%&lt;"</span> </span><br><span class="line">endfunc </span><br><span class="line"></span><br><span class="line"><span class="string">" C++的编译和运行 </span><br><span class="line">map &lt;F6&gt; :call CompileRunGpp()&lt;CR&gt; </span><br><span class="line">func! CompileRunGpp() </span><br><span class="line">exec "</span>w<span class="string">" </span><br><span class="line">exec "</span>!<span class="keyword">g</span>++ % -o %&lt;<span class="string">" </span><br><span class="line">exec "</span>! ./%&lt;<span class="string">" </span><br><span class="line">endfunc</span></span></span><br></pre></td></tr></table></figure>
<h1 id="插件列表">插件列表</h1><table>
<thead>
<tr>
<th>插件名称</th>
<th style="text-align:left">项目地址</th>
<th style="text-align:left">教程地址</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>pathogen</code></td>
<td style="text-align:left"><a href="http://www.vim.org/scripts/script.php?script_id=2332" target="_blank" rel="external">项目地址</a></td>
<td style="text-align:left"><a href="https://github.com/tpope/vim-pathogen" target="_blank" rel="external">教程地址</a></td>
</tr>
<tr>
<td><code>NERDTree</code></td>
<td style="text-align:left"><a href="http://www.vim.org/scripts/script.php?script_id=1658" target="_blank" rel="external">项目地址</a></td>
<td style="text-align:left"><a href="http://my.oschina.net/VASKS/blog/388907?fromerr=ktE2belY" target="_blank" rel="external">教程地址</a></td>
</tr>
</tbody>
</table>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="使用Pathogen管理插件">使用<code>Pathogen</code>管理插件</h1><p>推荐<a href="http://lostjs.com/2012/02/04/use-pathogen-and-git-to-manage-vimfiles/"]]>
    </summary>
    
      <category term="Linux" scheme="https://kaiiak.github.io/tags/Linux/"/>
    
      <category term="vim" scheme="https://kaiiak.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[APUE学习笔记——文件和目录]]></title>
    <link href="https://kaiiak.github.io/2016/02/29/APUE_study_notes-Files_and_Directories/"/>
    <id>https://kaiiak.github.io/2016/02/29/APUE_study_notes-Files_and_Directories/</id>
    <published>2016-02-29T13:48:30.000Z</published>
    <updated>2016-03-07T04:38:05.092Z</updated>
    <content type="html"><![CDATA[<h1 id="函数stat、fstat、fstatat、lstat">函数<code>stat</code>、<code>fstat</code>、<code>fstatat</code>、<code>lstat</code></h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, <span class="keyword">struct</span> stat *<span class="keyword">restrict</span> buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">struct</span> stat *buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lstat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, <span class="keyword">struct</span> stat *<span class="keyword">restrict</span> buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lstat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, <span class="keyword">struct</span> stat *<span class="keyword">restrict</span> buf, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 所有4个函数的返回值：若成功，返回0；若出错，返回-1 */</span></span><br><span class="line"></span><br><span class="line">sturct stat &#123; </span><br><span class="line">    <span class="keyword">mode_t</span>          st_mode;        <span class="comment">/* file type &amp; mode (permissions) */</span></span><br><span class="line">    <span class="keyword">ino_t</span>           st_ino;         <span class="comment">/* i-node number (serial number) */</span></span><br><span class="line">    <span class="keyword">dev_t</span>           st_dev;         <span class="comment">/* device number (file system) */</span></span><br><span class="line">    <span class="keyword">dev_t</span>           st_rdev;        <span class="comment">/* device number for special files */</span></span><br><span class="line">    <span class="keyword">nlink_t</span>         st_nlink;       <span class="comment">/* number of links */</span></span><br><span class="line">    <span class="keyword">uid_t</span>           st_uid;         <span class="comment">/* user ID of links */</span></span><br><span class="line">    <span class="keyword">gid_t</span>           st_gid;         <span class="comment">/* group ID of owner */</span></span><br><span class="line">    <span class="keyword">off_t</span>           st_size;        <span class="comment">/* size in bytes, for regular files  */</span></span><br><span class="line">    <span class="keyword">struct</span> timespec st_atime;       <span class="comment">/* time of last access */</span></span><br><span class="line">    <span class="keyword">struct</span> timespec st_mtime;       <span class="comment">/* time of last modification */</span></span><br><span class="line">    <span class="keyword">struct</span> timespec st_ctime;       <span class="comment">/* time of last file status change */</span></span><br><span class="line">    <span class="keyword">blksize_t</span>       st_blksize;     <span class="comment">/* best I/O block size */</span></span><br><span class="line">    <span class="keyword">blkcnt_t</span>        st_blocks;      <span class="comment">/* number of disk blocks allocated */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>函数<code>stat</code>:返回<code>pathname</code>命名文件有关的信息结构；</li>
<li>函数<code>fstat</code>:返回在描述符<code>fd</code>上打开文件的有关信息；</li>
<li>函数<code>lstat</code>:类似于函数<code>stat</code>，但当命名的文件是一个符号链接时，<code>lstat</code>返回该符号连接的有关信息；</li>
<li>函数<code>fstatat</code>:为一个相对于当前打开目录(由<code>fd</code>参数指向)的路径名返回文件统计信息。</li>
</ul>
<p>文件信息包含<code>stat</code>结构的<code>st_mode</code>成员中。可以下表中的宏文件确定文件的类型。</p>
<table>
<thead>
<tr>
<th>宏</th>
<th style="text-align:left">文件类型</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>S_ISREG()</code></td>
<td style="text-align:left">普通文件</td>
</tr>
<tr>
<td><code>S_ISDIR()</code></td>
<td style="text-align:left">目录文件</td>
</tr>
<tr>
<td><code>S_ISCHR()</code></td>
<td style="text-align:left">字符特殊文件</td>
</tr>
<tr>
<td><code>S_ISBLK()</code></td>
<td style="text-align:left">块特殊文件</td>
</tr>
<tr>
<td><code>S_ISFIFO()</code></td>
<td style="text-align:left">管道或FIFO</td>
</tr>
<tr>
<td><code>S_ISLNK()</code></td>
<td style="text-align:left">符号链接</td>
</tr>
<tr>
<td><code>S_ISSOCK()</code></td>
<td style="text-align:left">套接字</td>
</tr>
</tbody>
</table>
<h1 id="文件类型">文件类型</h1><p>文件类型包括如下几类：</p>
<ol>
<li>普通文件(regular file):包含了某种形式的数据；</li>
<li>目录文件(directory file):包含了其他文件的名字以及指向与这些文件有关信息的指针；</li>
<li>块特殊文件(block special file):该类型文件提供对设备(如磁盘)带缓冲的访问，每次访问以固定长度为单位进行；</li>
<li>字符特殊文件(character special file):该文件提供对设备不带缓冲的访问，每次访问长度不变。系统中的所有设备要么是字符特殊文件，要么是块特殊文件。</li>
<li>FIFO:该文件用于进程通信，也称为命名管道(named pipe)；</li>
<li>套接字(socket)：该文件用于进程间的网络通信，也可以用在一台宿主机上进程间的非网络通信。</li>
<li>符号链接(symbolic link):该文件指向另一个文件。</li>
</ol>
<h1 id="设置用户ID和设置组ID">设置用户ID和设置组ID</h1><ul>
<li>实际用户ID和实际组ID标识我们究竟是谁。</li>
<li>有效用户ID、有效组ID以及附属组ID决定了我们的文件访问权限。</li>
<li>保存的设置用户ID和保存的设置组ID在执行一个程序时包含了有效用户ID和有效组ID的副本。</li>
</ul>
<p>每个文件有一个所有者和组所有者，所有者由<code>stat</code>结构中的<code>st_uid</code>指定，组所有者则由<code>st_gid</code>指定。</p>
<h1 id="文件访问权限">文件访问权限</h1><p>所有文件类型(目录、字符特别文件等)都有访问权限(access permisiion)。</p>
<table>
<thead>
<tr>
<th><code>st_mode</code>屏蔽</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>S_IRUSR</code></td>
<td style="text-align:left">用户都</td>
</tr>
<tr>
<td><code>S_IWUSR</code></td>
<td style="text-align:left">用户写</td>
</tr>
<tr>
<td><code>S_IXUSR</code></td>
<td style="text-align:left">用户执行</td>
</tr>
<tr>
<td><code>S_IRGRP</code></td>
<td style="text-align:left">组读</td>
</tr>
<tr>
<td><code>S_IWGRP</code></td>
<td style="text-align:left">组写</td>
</tr>
<tr>
<td><code>S_IXGRP</code></td>
<td style="text-align:left">组执行</td>
</tr>
<tr>
<td><code>S_IROTH</code></td>
<td style="text-align:left">其他读</td>
</tr>
<tr>
<td><code>S_IWOTH</code></td>
<td style="text-align:left">其他写</td>
</tr>
<tr>
<td><code>S_IXOTH</code></td>
<td style="text-align:left">其他执行</td>
</tr>
</tbody>
</table>
<h1 id="函数access和faccessat">函数<code>access</code>和<code>faccessat</code></h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">access</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">faccessat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> mode, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">/* 两个函数的返回值：若成功，返回0；若出错，返回-1 */</span></span><br></pre></td></tr></table></figure>
<p><code>access</code>和<code>faccessat</code>函数是按实际用户ID和实际组ID进行访问权限测试的。</p>
<table>
<thead>
<tr>
<th><code>mode</code></th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>R_OK</code></td>
<td style="text-align:left">测试读权限</td>
</tr>
<tr>
<td><code>W_OK</code></td>
<td style="text-align:left">测试写权限</td>
</tr>
<tr>
<td><code>X_OK</code></td>
<td style="text-align:left">测试执行权限</td>
</tr>
</tbody>
</table>
<h1 id="函数umask">函数<code>umask</code></h1><p><code>umask</code>函数为进程设置文件模式创建屏蔽字(mask for the process)，并返回之前的值。(这是少数几个没有出错返回函数中的一个。)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mode_t</span> umask(<span class="keyword">mode_t</span> cmask);</span><br><span class="line"><span class="comment">/* 返回值：之前的文件模式穿件屏蔽字 */</span></span><br></pre></td></tr></table></figure>
<p>参数<code>cmask</code>是由上上个表列出的9个常量(S_IRUSR、S_IWUSR等)中若干个按位“或”构成的。</p>
<table>
<thead>
<tr>
<th>屏蔽位</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>0400</td>
<td style="text-align:left">用户读</td>
</tr>
<tr>
<td>0200</td>
<td style="text-align:left">用户写</td>
</tr>
<tr>
<td>0100</td>
<td style="text-align:left">用户执行</td>
</tr>
<tr>
<td>0040</td>
<td style="text-align:left">组读</td>
</tr>
<tr>
<td>0020</td>
<td style="text-align:left">组写</td>
</tr>
<tr>
<td>0010</td>
<td style="text-align:left">组执行</td>
</tr>
<tr>
<td>0004</td>
<td style="text-align:left">其他读</td>
</tr>
<tr>
<td>0002</td>
<td style="text-align:left">其他写</td>
</tr>
<tr>
<td>0001</td>
<td style="text-align:left">其他执行</td>
</tr>
</tbody>
</table>
<h1 id="函数chmod、fchmod和fchmodat">函数<code>chmod</code>、<code>fchmod</code>和<code>fchmodat</code></h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chomd</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, mode_t mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchome</span><span class="params">(<span class="keyword">int</span> fd, mode_t mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchomdat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, mode_t mode, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">/* 3个函数返回值：若成功，返回0；若出错，返回-1 */</span></span><br></pre></td></tr></table></figure>
<p><code>chmod</code>函数在指定的文件上进行操作，而<code>fchmod</code>函数则对已打开的文件进行操作。<br><code>fchomdat</code>函数与<code>chmod</code>函数在下面两种情况下是相同的：一种是<code>pathname</code>参数为绝对路径，另一种是<code>fd</code>参数取值为<code>AT_FDCWD</code>而<code>pathname</code>参数为相对路径。否则，<code>fchmodat</code>计算相对于打开目录(由<code>fd</code>参数指向)的pathname。<code>flag</code>参数可以用于改变<code>fchmodat</code>的行为，当设置了<code>AT_SYMLIN_NOFOLLOW</code>标志时，<code>fchmodat</code>并不会跟随符号链接。</p>
<table>
<thead>
<tr>
<th><code>mode</code></th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>S_ISUID</code></td>
<td style="text-align:left">执行时设置用户ID</td>
</tr>
<tr>
<td><code>S_ISGID</code></td>
<td style="text-align:left">执行时设置组ID</td>
</tr>
<tr>
<td><code>S_ISVTX</code></td>
<td style="text-align:left">保存正文(粘着位)</td>
</tr>
<tr>
<td><code>S_IRWXU</code></td>
<td style="text-align:left">用户(所有者)读、写和执行</td>
</tr>
<tr>
<td><code>S_IRUSR</code></td>
<td style="text-align:left">用户(所有者)读</td>
</tr>
<tr>
<td><code>S_IWUSR</code></td>
<td style="text-align:left">用户(所有者)写</td>
</tr>
<tr>
<td><code>S_IXUSR</code></td>
<td style="text-align:left">用户(所有者)执行</td>
</tr>
<tr>
<td><code>S_IRWXG</code></td>
<td style="text-align:left">组读、写和执行</td>
</tr>
<tr>
<td><code>S_IRGRP</code></td>
<td style="text-align:left">组读</td>
</tr>
<tr>
<td><code>S_IWGRP</code></td>
<td style="text-align:left">组写</td>
</tr>
<tr>
<td><code>S_IXGRP</code></td>
<td style="text-align:left">组执行</td>
</tr>
<tr>
<td><code>S_IRWXO</code></td>
<td style="text-align:left">其他读、写和执行</td>
</tr>
<tr>
<td><code>S_IROTH</code></td>
<td style="text-align:left">其他读</td>
</tr>
<tr>
<td><code>S_IWOTH</code></td>
<td style="text-align:left">其他写</td>
</tr>
<tr>
<td><code>S_IXOTH</code></td>
<td style="text-align:left">其他执行</td>
</tr>
</tbody>
</table>
<h1 id="粘着位(sticky_bit)">粘着位(sticky bit)</h1><p><code>S_ISVTX</code>位被称为<code>粘着位</code>：如果一个可执行的程序文件的这一位被设置了，那么当程序第一次被执行，在其终止时，程序正文的一个副本仍被保存在交换区。<br>后来的UNIX版本称为它为<code>保存正文位(saved-text bit)</code>，因此也就有了常量<code>S_ISVTX</code>。</p>
<h1 id="函数chown、fchown、fchownat和lchown">函数<code>chown</code>、<code>fchown</code>、<code>fchownat</code>和<code>lchown</code></h1><p>下面几个<code>chown</code>函数可用于更改文件的用户ID和组ID。如果两个参数<code>owner</code>或<code>group</code>中的任意一个是-1，则对应的ID不变。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chown</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, uid_t owner, git_t group)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchown</span><span class="params">(<span class="keyword">int</span> fd, uid_t owner, gid_t group)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchownat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, uid_t owner, gid_t group, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lchown</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, uid_t owner, gid_t group)</span></span>;</span><br><span class="line"><span class="comment">/*</span><br><span class="line"> * 4个函数的返回值：若辰宫，返回0；若出错，返回-1</span><br><span class="line"> */</span></span><br></pre></td></tr></table></figure>
<h1 id="文件长度">文件长度</h1><p><code>stat</code>结构成员<code>st_size</code>表示以字节为单位的单位长度。只对普通文件、目录文件和符号连接有效。</p>
<h1 id="文件中的空洞">文件中的空洞</h1><p>空洞是由所设置的偏移量超过文件端尾，并写入了某些数据后造成的。</p>
<h1 id="文件截断">文件截断</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">truncate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, off_t length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ftruncate</span><span class="params">(<span class="keyword">int</span> fd, off_t length)</span></span>;</span><br><span class="line"><span class="comment">/*</span><br><span class="line"> * 两个函数的返回值：若成功，返回0；若失败，返回-1</span><br><span class="line"> */</span></span><br></pre></td></tr></table></figure>
<p>如果该文件以前的长度大于<code>length</code>，则超过<code>length</code>以外的数据就不能再访问。如果以前的长度小于<code>length</code>，文件长度将增加，在以前的文件尾端和新的文件尾端之间的数据将读作0。</p>
<h1 id="文件系统">文件系统</h1><h1 id="函数link、linkat、unlink、unlinkat和remove">函数<code>link</code>、<code>linkat</code>、<code>unlink</code>、<code>unlinkat</code>和<code>remove</code></h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">link</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *existingpath, <span class="keyword">const</span> <span class="keyword">char</span> *newpath)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">linkat</span><span class="params">(<span class="keyword">int</span> efd, <span class="keyword">const</span> <span class="keyword">char</span> *existingpath, <span class="keyword">int</span> nfd, <span class="keyword">const</span> <span class="keyword">char</span> *newpath, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">/* 两个函数的返回值：若成功，返回0；若出错，返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>这两个函数创建一个新目录项<code>newpath</code>，它引用现有文件<code>existingpath</code>。如果<code>newpath</code>已存在，则返回出错。<br>对于<code>linkat</code>函数，现有文件是通过<code>efd</code>和<code>existingpath</code>指定，新的路径名是通过<code>nfd</code>和<code>newpath</code>指定的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unlinkat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">/* 两个函数的返回值：若成功，返回0；若出错，返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>这两个函数删除目录项，并将由<code>pathname</code>所引用的链接数减1。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回0；若失败，返回-1 */</span></span><br></pre></td></tr></table></figure>
<h1 id="函数rename和renameat">函数<code>rename</code>和<code>renameat</code></h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rename</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *oldname, <span class="keyword">const</span> <span class="keyword">char</span> *newname)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">renameat</span><span class="params">(<span class="keyword">int</span> oldfd, <span class="keyword">const</span> <span class="keyword">char</span> *oldname, <span class="keyword">int</span> newfd, <span class="keyword">const</span> <span class="keyword">char</span> *newname)</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>如果<code>oldname</code>指的是一个文件而不是目录，那么为该文件或符号连接重命名。</li>
<li>如果<code>oldname</code>指的是一个空目录，那么为该目录重命名。</li>
<li>如果<code>oldname</code>或<code>newname</code>引用符号连接，则处理的是符号链接本身，而不是它引用的文件。</li>
<li>不能对<code>.</code>和<code>..</code>重命名。</li>
<li>作为一个特例，如果<code>oldname</code>和<code>newname</code>引用同意文件，则函数不做任何更改而成功返回。</li>
</ol>
<h1 id="符号链接">符号链接</h1><p>符号链接是对一个文件的间接指针。符号链接以及它指向何种对象并无任何文件系统限制，任何用户都可以创建指向目录的符号连接。</p>
<h1 id="创建和读取符号连接">创建和读取符号连接</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">symlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *actualpath, <span class="keyword">const</span> <span class="keyword">char</span> *sympath)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">symlinat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *acutalpath, <span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *symptah)</span></span>;</span><br><span class="line"><span class="comment">/* 两个函数的返回值：若成功，返回0；若出错，返回-1 */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> readlink(<span class="keyword">const</span> <span class="keyword">char</span> *actualpath, <span class="keyword">const</span> <span class="keyword">char</span> *symptah);</span><br><span class="line"><span class="keyword">sszie_t</span> readlinkat(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">restrict</span> pathname, <span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">size_t</span> bufsize);</span><br><span class="line"><span class="comment">/* 两个函数的返回值：若成功，返回读取的字节数；若出错，返回-1 */</span></span><br></pre></td></tr></table></figure>
<h1 id="文件时间">文件时间</h1><table>
<thead>
<tr>
<th>字段</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">例子</th>
<th style="text-align:left">ls(1)选项</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>st_atim</code></td>
<td style="text-align:left">文件数据的最后访问时间</td>
<td style="text-align:left"><code>read</code></td>
<td style="text-align:left"><code>-u</code></td>
</tr>
<tr>
<td><code>st_mtim</code></td>
<td style="text-align:left">文件数据的最后修改时间</td>
<td style="text-align:left"><code>write</code></td>
<td style="text-align:left"><code>默认</code></td>
</tr>
<tr>
<td><code>st_ctim</code></td>
<td style="text-align:left">i节点状态的最后更改时间</td>
<td style="text-align:left"><code>chomd、chown</code></td>
<td style="text-align:left"><code>-c</code></td>
</tr>
</tbody>
</table>
<h1 id="函数futimens、utimensat和utimes">函数<code>futimens</code>、<code>utimensat</code>和<code>utimes</code></h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">futimens</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">struct</span> timespec times[<span class="number">2</span>])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">utimensat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">struct</span> timespec times[<span class="number">2</span>], <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">/* 两个函数返回值：若成功，返回0；若出错，返回-1 */</span></span><br></pre></td></tr></table></figure>
<h1 id="函数mkdir、mkdirat和rmdir">函数<code>mkdir</code>、<code>mkdirat</code>和<code>rmdir</code></h1><p>两个函数创建一个新目录。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, mode_t mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkdir</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, mode_t mode)</span></span>;</span><br><span class="line"><span class="comment">/* 两个函数返回值：若成功，返回0；若出错，返回-1 */</span></span><br></pre></td></tr></table></figure></p>
<p>用<code>rmdir</code>函数可以创建一个空目录。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rmdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回0；若失败，返回-1 */</span></span><br></pre></td></tr></table></figure></p>
<h1 id="读目录">读目录</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">DIR *<span class="title">opendir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br><span class="line"><span class="function">DIR *<span class="title">fdopendir</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="comment">/* 两个函数返回值：若成功，返回指针；若出错，返回NULL */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">struct</span> dirent *<span class="title">readdir</span><span class="params">(DIR *dp)</span></span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回指针；若在目录尾或出错，返回NULL */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rewinddir</span><span class="params">(DIR *dp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">closeddir</span><span class="params">(DIR *dp)</span></span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回0；若失败，返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">telldir</span><span class="params">(DIR *dp)</span></span>;</span><br><span class="line"><span class="comment">/* 返回值：与dp关联的相关位置 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">seekdir</span><span class="params">(DIR *dp, <span class="keyword">long</span> loc)</span></span>;</span><br></pre></td></tr></table></figure>
<h1 id="函数chdir、fchdir和getcwd">函数<code>chdir</code>、<code>fchdir</code>和<code>getcwd</code></h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchdir</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure>
<p>进程调用<code>chdir</code>和<code>fchdir</code>函数更改当前工作目录。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getcwd</span><span class="params">(<span class="keyword">char</span> *buf, size_t size)</span></span>;</span><br></pre></td></tr></table></figure>
<p>逐层上移，直到遇到根，得到当前工作目录完整的绝对路径。<br>必须像此函数传递两个函数，一个是缓冲区地址<code>buf</code>(要有足够的长度容纳绝对路径再加上一个终止<code>null</code>字节)，另一个是缓冲区的长度<code>size</code>(以字节为单位)。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="函数stat、fstat、fstatat、lstat">函数<code>stat</code>、<code>fstat</code>、<code>fstatat</code>、<code>lstat</code></h1><figure class="highli]]>
    </summary>
    
      <category term="APUE" scheme="https://kaiiak.github.io/tags/APUE/"/>
    
      <category term="Linux" scheme="https://kaiiak.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[APUE学习笔记——文件IO]]></title>
    <link href="https://kaiiak.github.io/2016/02/25/APUE_study_notes-Files_IO/"/>
    <id>https://kaiiak.github.io/2016/02/25/APUE_study_notes-Files_IO/</id>
    <published>2016-02-25T00:36:08.000Z</published>
    <updated>2016-03-16T13:50:57.360Z</updated>
    <content type="html"><![CDATA[<h1 id="文件描述符">文件描述符</h1><p>所有打开的文件都通过文件描述符(一个非负整数)引用。</p>
<p>维基百科上对于文件描述符的解释是这样的：</p>
<blockquote>
<p>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。</p>
</blockquote>
<p>当读、写一个文件时，使用<code>open</code>或<code>creat</code>返回的文件描述符标识该文件，将其作为参数传给<code>read</code>或<code>write</code>。</p>
<p>在POSIX.1的应用程序中，文件描述符0与进程的标准输入关联(STDIN_FILENO)、文件描述符1与进程的标准输出关联(STDOUT_FILENO)、文件描述符2与进程的标准错误关联(STDERR_FILENO)，且已经确定化。<br>文件描述符的变化范围是<code>0~OPEN_MAX-1</code>。</p>
<h1 id="函数open和openat">函数<code>open</code>和<code>openat</code></h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> oflag, ... <span class="comment">/* mode_t mode */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">openat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> oflag, ... <span class="comment">/* mode_t mode */</span>)</span></span>;</span><br><span class="line"><span class="comment">/*</span><br><span class="line"> *path ：文件的名称，可以包含（绝对和相对）路径</span><br><span class="line"> *flags：文件打开模式</span><br><span class="line"> *mode：用来规定对该文件的所有者，文件的用户组及系 统中其他用户的访问权限</span><br><span class="line"> */</span></span><br><span class="line"><span class="comment">/* 两函数的返回值： 若成功，返回文件描述符； 若出错，返回-1 */</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>打开方式</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>O_RDONLY</code></td>
<td style="text-align:left">只读打开.</td>
</tr>
<tr>
<td><code>O_WRONLY</code></td>
<td style="text-align:left">只写打开.</td>
</tr>
<tr>
<td><code>O_RDWR</code></td>
<td style="text-align:left">读、写打开.</td>
</tr>
<tr>
<td><code>O_EXEC</code></td>
<td style="text-align:left">只执行打开.</td>
</tr>
<tr>
<td><code>O_SEARCH</code></td>
<td style="text-align:left">只搜索打开 (应用于目录).</td>
</tr>
<tr>
<td><code>O_APPEND</code></td>
<td style="text-align:left">每次写时都追加到文件的尾端.</td>
</tr>
<tr>
<td><code>O_CLOEXEC</code></td>
<td style="text-align:left">设置<code>FD_CLOEXEC</code>文件描述符.</td>
</tr>
<tr>
<td><code>O_CREAT</code></td>
<td style="text-align:left">若此文件不存在则创建它.</td>
</tr>
<tr>
<td><code>O_DIRECTORY</code></td>
<td style="text-align:left">如果<code>path</code>引用的不是目录，则出错.</td>
</tr>
<tr>
<td><code>O_EXCL</code></td>
<td style="text-align:left">如果同时指定了<code>O_CREAT</code>，而文件已存在，则出错.</td>
</tr>
<tr>
<td><code>O_NOCTTY</code></td>
<td style="text-align:left">如果<code>path</code>引用的是终端设备，则不将该设备分配作为此进程的控制终端.</td>
</tr>
<tr>
<td><code>O_NOFOLLOW</code></td>
<td style="text-align:left">如果<code>path</code>引用的是一个符号连接，则出错.</td>
</tr>
<tr>
<td><code>O_NONBLOCK</code></td>
<td style="text-align:left">如果<code>path</code>引用的是一个<code>FIFO</code>、一个块特殊文件或一个自负特殊文件，则此选项为文件的本次打开操作和后续的I/O操作设置非阻塞方式.</td>
</tr>
<tr>
<td><code>O_SYNC</code></td>
<td style="text-align:left">使每次<code>write</code>等待物理I/O完成，包括由该<code>write</code>操作引起的文件属性更新所需的I/O.</td>
</tr>
<tr>
<td><code>O_TRUNC</code></td>
<td style="text-align:left">如果此文件存在，而且为只写或读-写成功打开，则将其长度截断为0.</td>
</tr>
<tr>
<td><code>O_TTY_INIT</code></td>
<td style="text-align:left">如果打开一个还未打开的终端设备，设置非标准<code>termios</code>参数值，使其符合<code>Single UNIX Specification</code>.</td>
</tr>
<tr>
<td><code>O_DSYNC</code></td>
<td style="text-align:left">使每次<code>write</code>要等待物理I/O完成，但是如果该写操作并不影响读取刚写入的数据，则不需等待文件属性被更新.</td>
</tr>
<tr>
<td><code>O_RSYNC</code></td>
<td style="text-align:left">使每一个一文件描述符作为参数进行的<code>read</code>操作等待，直至所有对文件同一部份挂起的写操作都完成.</td>
</tr>
</tbody>
</table>
<h3 id="fd参数吧open和openat函数区分开，共有3种可能性。"><code>fd</code>参数吧<code>open</code>和<code>openat</code>函数区分开，共有3种可能性。</h3><ol>
<li><code>path</code>参数指定的是绝对路径名，在这种情况下，<code>fd</code>参数被忽略，<code>openat</code>函数就相当于<code>open</code>函数。</li>
<li><code>path</code>参数指定的是相对路径名，<code>fd</code>参数指出了相对路径名在文件系统中的开始地址。<code>fd</code>参数是通过打开相对路径名所在的目录来获取。</li>
<li><code>path</code>参数指定了相对路径名，<code>fd</code>参数具有特殊值<code>AT_FDCWD</code>。在这种情况下，路径名在当前工作目录中获取，<code>openat</code>函数在操作上与<code>open</code>函数类似。</li>
</ol>
<h1 id="函数creat">函数<code>creat</code></h1><h3 id="调用函数creat创建一个新的文件">调用函数<code>creat</code>创建一个新的文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">creat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, mode_t mode)</span></span>;</span><br><span class="line"><span class="comment">/* 返回值： 若成功，返回为只写打开的文件描述符；如出错，返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>等效于：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open(path, O_WRONLY|O_CREAT|O_TRUNC, mode);</span><br></pre></td></tr></table></figure></p>
<h1 id="函数close">函数<code>close</code></h1><h3 id="调用close函数关闭一个打开文件">调用<code>close</code>函数关闭一个打开文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回0；如出错，返回-1 */</span></span><br></pre></td></tr></table></figure>
<h1 id="函数lseek">函数<code>lseek</code></h1><h3 id="当前文件偏移量(current_file_offset)：它通常是一个非负整数，用以度量从文件开始处计算的字节数。">当前文件偏移量(current file offset)：它通常是一个非负整数，用以度量从文件开始处计算的字节数。</h3><h3 id="调用lseek显式的为一个打开文件设置偏移量。">调用<code>lseek</code>显式的为一个打开文件设置偏移量。</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">off_t</span> lseek(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence);</span><br><span class="line"><span class="comment">/* 返回值：若辰宫，返回新的文件偏移量；若出错，返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>对参数<code>offset</code>的解释与参数<code>whence</code>的值有关。</p>
<ul>
<li>若<code>whence</code>是<code>SEEK_SET</code>，则经该文件的偏移量设置为距文件开始处<code>offset</code>个字节。</li>
<li>若<code>whence</code>是<code>SEEK_CUR</code>，则经该文件的偏移量设置为其当前量增加<code>offset</code>，<code>offset</code>可为正或负。</li>
<li>若<code>whence</code>是<code>SEEK_END</code>，则经该文件的偏移量设置为文件长度加<code>offset</code>，<code>offset</code>可正可负。</li>
</ul>
<h1 id="函数read">函数<code>read</code></h1><h3 id="调用read函数从打开文件中读数据。">调用<code>read</code>函数从打开文件中读数据。</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes);</span><br><span class="line"><span class="comment">/* 返回值：读到的字节数，若已到文件尾，返回0；若出错，返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>有多种情况可使实际读到的字节数少于要求读的字节数：</p>
<ul>
<li>读到普通文件时，在读到要求字计数之前已到达了文件微端。</li>
<li>当从终端设备读时，通常一次最多读一行。</li>
<li>当从网络读时，网络中的缓冲机制可能造成返回值小于所要求的字节数。</li>
<li>当从管道或<code>FIFO</code>读时，如若管道包含的字节少于所需的数量，那么<code>read</code>将只返回实际可用的字节数。</li>
<li>当从某些面向记录的设备读时，一次最多返回一个记录。</li>
<li>当一信号造成中断，而已经读到部分数据量时。</li>
</ul>
<h1 id="函数write">函数<code>write</code></h1><h3 id="调用write函数向打开文件写数据。">调用<code>write</code>函数向打开文件写数据。</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> write(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes);</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回已写的字节数；若出错，返回-1 */</span></span><br></pre></td></tr></table></figure>
<h2 id="函数pread和pwrite">函数<code>pread</code>和<code>pwrite</code></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> pread(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes. <span class="keyword">off_t</span> offset);</span><br><span class="line"><span class="comment">/* 返回值：读到的字节数，若已到文件尾，返回0；若出错，返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> pwrite(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes, <span class="keyword">off_t</span> offset);</span><br></pre></td></tr></table></figure>
<p>调用<code>pread</code>相当于调用<code>lseek</code>后调用<code>read</code>，但是<code>pread</code>又与这种顺序调用有下列重要区别。</p>
<ul>
<li>调用<code>pread</code>时，无法中断其定位和都读操作。</li>
<li>不更新当前文件偏移量。<br>调用<code>pwrite</code>相当于调用<code>lseek</code>后调用<code>write</code>，但也与它们有类似的区别。</li>
</ul>
<blockquote>
<p>原子操作(atomic operation)；指的是由多步组成一个一个操作。如果该操作原子地执行，则要么执行所有步骤，要么一步也不执行，不可能只执行所有步骤的一个子集。</p>
</blockquote>
<h1 id="函数dup和dup2">函数<code>dup</code>和<code>dup2</code></h1><h3 id="复制一个现有的文件描述符">复制一个现有的文件描述符</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> fd2)</span></span>;</span><br><span class="line"><span class="comment">/* 两函数的返回值：若成功，返回新的文件描述符；如出错，返回-1 */</span></span><br></pre></td></tr></table></figure>
<h1 id="函数sync、fsync和fdatasync">函数<code>sync</code>、<code>fsync</code>和<code>fdatasync</code></h1><blockquote>
<p>内核通常先将数据复制到缓冲区中，然后排入队列，晚些时候写入磁盘。这种方法被称为<code>延迟写(delayed write)</code>.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unitstd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsync</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fdatasync</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回0；若出错，返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sync</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>sync</code>只是将所有修改过的块缓冲区排入写队列，然后就返回，它并不等待实际写磁盘操作结束。<br><code>fsync</code>函数只对由文件描述符<code>fd</code>指定的一个文件起作用，并且等待写磁盘操作结束才返回。<br><code>fdatasync</code>函数类似于<code>fsync</code>，但它只影响文件的数据部分。</p>
<h1 id="函数fcntl">函数<code>fcntl</code></h1><h3 id="改变已经打开文件的属性。">改变已经打开文件的属性。</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ... <span class="comment">/* int arg */</span>)</span></span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，则依赖cmd，若出错，返回-1 */</span></span><br></pre></td></tr></table></figure>
<h4 id="fcntl函数有以下5种功能。"><code>fcntl</code>函数有以下5种功能。</h4><ol>
<li>复制一个已有的描述符 (<code>cmd=F_DUPFD</code>或<code>F_DUPFD_CLOEXEC</code>)。</li>
<li>获取/设置文件描述符标志 (<code>cmd=F_GETFD</code>或<code>F_SETFD</code>)。</li>
<li>获取/设置文件状态标志 (<code>cmd=F_GETFL</code>或<code>F_SETFL</code>)。</li>
<li>获取/设置异步I/O所有权 (<code>cmd=F_GETOWN</code>或<code>F_SETOWN</code>)。</li>
<li>获取/设置记录锁 (<code>cmd=F_GETLK</code>或<code>F_SETLKW</code>)。</li>
</ol>
<p>|cmd|功能<br>|<br>|——|:—————————————————-|<br>|<code>F_DUPFD</code>|复制文件描述符<code>fd</code>。|<br>|<code>F_DUPFD_CLOEXEC</code>|复制文件描述符，设置与新描述符关联的<code>FD_CLOEXEC</code>文件描述符标志的值，返回新文件描述符。|<br>|<code>F_GETFD</code>|对应于<code>fd</code>的文件描述符标志作为函数值返回。|<br>|<code>F_SETFD</code>|对于<code>fd</code>设置文件描述符标志。|<br>|<code>F_GETFL</code>|对应于<code>fd</code>的文件状态标志作为函数值返回。|<br>|<code>F_SETFL</code>|将文件状态标志设置为第3个参数的值。可以更改的几个标志是：<code>O_APPEND</code>、<code>O_NONBLOCK</code>、<code>O_SYNC</code>、<code>O_DSYNC</code>、<code>O_RSYNC</code>、<code>O_FSYNC</code>、和<code>O_ASYNC</code>。|<br>|<code>F_GETOWN</code>|获取当前接收<code>SIGIO</code>和<code>SIGURG</code>信号进程ID或进程组ID。|<br>|<code>F_SETOWN</code>|设置接收<code>SIGIO</code>和<code>SIGURG</code>信号的进程ID或进程组ID。|</p>
<h1 id="函数ioctl">函数<code>ioctl</code></h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> /* System V */</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span>  /* BSD and Linux */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ioctl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> request, ...)</span></span>;</span><br><span class="line"><span class="comment">/* 返回值：若出错，返回-1；若成功，返回其他值 */</span></span><br></pre></td></tr></table></figure>
<h2 id="/dev/fd"><code>/dev/fd</code></h2><p>较新的系统都提供名为<code>/dev/fd</code>的目录，其目录项是名为0、1、2等的文件。打开文件<code>/dev/fdn</code>等效于复制描述符n(假设描述符n是打开的).</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="文件描述符">文件描述符</h1><p>所有打开的文件都通过文件描述符(一个非负整数)引用。</p>
<p>维基百科上对于文件描述符的解释是这样的：</p>
<blockquote>
<p>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个]]>
    </summary>
    
      <category term="APUE" scheme="https://kaiiak.github.io/tags/APUE/"/>
    
      <category term="Linux" scheme="https://kaiiak.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[编译apue.3e并解决编译错误]]></title>
    <link href="https://kaiiak.github.io/2016/01/28/%E7%BC%96%E8%AF%91apue-3e%E5%B9%B6%E8%A7%A3%E5%86%B3%E7%BC%96%E8%AF%91%E9%94%99%E8%AF%AF/"/>
    <id>https://kaiiak.github.io/2016/01/28/编译apue-3e并解决编译错误/</id>
    <published>2016-01-28T14:38:58.000Z</published>
    <updated>2016-02-12T12:15:10.705Z</updated>
    <content type="html"><![CDATA[<h2 id="下载源代码">下载源代码</h2><p>我们在学习APUE这本书的时候，总会见到书上的源代码总会引用<code>apue.h</code>这个头文件，这个并不是Linux系统自带的。所以，我们要自己编译。<br>我们在<a href="http://www.apuebook.com/src.3e.tar.gz" target="_blank" rel="external">http://www.apuebook.com/src.3e.tar.gz</a>下载源代码后，解压。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf src.3e.tar.gz</span><br></pre></td></tr></table></figure></p>
<p>然后编译<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make</span><br></pre></td></tr></table></figure></p>
<p>但是在编译过程中，会出现错误，错误部分的log是这样的。<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gcc -ansi -I..<span class="regexp">/include -Wall -DLINUX -D_GNU_SOURCE  badexit2.c -o badexit2  -L../</span>lib -lapue -pthread -lrt -lbsd</span><br><span class="line"><span class="regexp">/usr/</span>bin/<span class="string">ld:</span> cannot find -lbsd</span><br><span class="line"><span class="string">collect2:</span> ld returned <span class="number">1</span> exit status</span><br><span class="line"><span class="string">Makefile:</span><span class="number">31</span>: recipe <span class="keyword">for</span> target <span class="string">'badexit2'</span> failed</span><br><span class="line">make[<span class="number">1</span>]: *** [badexit2] Error <span class="number">1</span></span><br><span class="line">make[<span class="number">1</span>]: Leaving directory <span class="string">'/home/pi/apue.3e/threads'</span></span><br><span class="line"><span class="string">Makefile:</span><span class="number">6</span>: recipe <span class="keyword">for</span> target <span class="string">'all'</span> failed</span><br><span class="line"><span class="label"></span><br><span class="line">make:</span> *** [all] Error <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<h2 id="修复">修复</h2><p>出现这个错误是因为，我们缺少一个库。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get inatall libbsd-dev</span><br></pre></td></tr></table></figure></p>
<p>安装完成后，重新进行编译.</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp ./<span class="keyword">include</span>/apue.<span class="keyword">h</span> ./lib/<span class="keyword">error</span>.c /usr/<span class="keyword">include</span></span><br></pre></td></tr></table></figure>
<p>然后，在<code>/usr/include/apue.h</code>的<code>ifdef</code>和<code>endif</code>中间添加<code>#include &quot;error.c&quot;</code>,就可以在编写的程序中，愉快的使用<code>apue.h</code>了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="下载源代码">下载源代码</h2><p>我们在学习APUE这本书的时候，总会见到书上的源代码总会引用<code>apue.h</code>这个头文件，这个并不是Linux系统自带的。所以，我们要自己编译。<br>我们在<a href="http://www.apu]]>
    </summary>
    
      <category term="APUE" scheme="https://kaiiak.github.io/tags/APUE/"/>
    
      <category term="Linux" scheme="https://kaiiak.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Happy New Year]]></title>
    <link href="https://kaiiak.github.io/2016/01/01/Happy-New-Year/"/>
    <id>https://kaiiak.github.io/2016/01/01/Happy-New-Year/</id>
    <published>2016-01-01T06:21:25.000Z</published>
    <updated>2016-01-01T06:44:56.890Z</updated>
    <content type="html"><![CDATA[<h2 id="新年快乐～">新年快乐～</h2><p>在新的一年里，希望我能入门C++，哈哈哈哈哈哈哈哈哈哈哈哈</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="新年快乐～">新年快乐～</h2><p>在新的一年里，希望我能入门C++，哈哈哈哈哈哈哈哈哈哈哈哈</p>
]]>
    </summary>
    
      <category term="随笔" scheme="https://kaiiak.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C#利用VLC播放网络串流]]></title>
    <link href="https://kaiiak.github.io/2015/11/19/using-vlclib-in-vs/"/>
    <id>https://kaiiak.github.io/2015/11/19/using-vlclib-in-vs/</id>
    <published>2015-11-19T13:08:23.000Z</published>
    <updated>2015-12-01T11:31:26.444Z</updated>
    <content type="html"><![CDATA[<p><a href="http://www.videolan.org" target="_blank" rel="external">VLC的官方网站</a>，VLC的源代码是用C语言实现的。我们这里用<code>C#</code>的封装——nVLC。<br><a href="http://www.codeproject.com/Articles/109639/nVLC" target="_blank" rel="external">nVLC</a>。</p>
<h2 id="开始">开始</h2><p>在运行本程序之前，请先安装VLC，或者拷贝<code>libvlc.dll</code>、<code>libvlccode.dll</code>和<code>plugins目录</code>到你的</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using System;&#10;using System.Windows.Forms;&#10;using Declarations;&#10;using Declarations.Enums;&#10;using Declarations.Media;&#10;using Declarations.Players;&#10;using Implementation;&#10;&#10;namespace nVLC_Demo_MemoryInputOutput&#10;&#123;&#10;    public partial class Form1 : Form&#10;    &#123;&#10;        IMediaPlayerFactory m_factory;&#10;        IVideoPlayer m_sourcePlayer;&#10;        IVideoPlayer m_renderPlayer;&#10;        IMemoryInputMedia m_inputMedia;&#10;        const long MicroSecondsInSecomd = 1000 * 1000;&#10;        long MicroSecondsBetweenFrame;&#10;        long frameCounter;&#10;        FrameData data = new FrameData() &#123; DTS = -1 &#125;;&#10;        const int DefaultFps = 24;&#10;        Timer timer = new Timer();&#10;&#10;        public Form1()&#10;        &#123;&#10;            InitializeComponent();&#10;            timer.Tick += new EventHandler(timer_Tick);&#10;            timer.Interval = 1000;&#10;        &#125;&#10;&#10;        void timer_Tick(object sender, EventArgs e)&#10;        &#123;&#10;            this.Text = m_inputMedia.PendingFramesCount.ToString();&#10;        &#125;&#10;&#10;        protected override void OnLoad(EventArgs e)&#10;        &#123;&#10;            base.OnLoad(e);&#10;&#10;            m_factory = new MediaPlayerFactory(true);&#10;            m_sourcePlayer = m_factory.CreatePlayer&#60;IVideoPlayer&#62;();&#10;            m_sourcePlayer.Events.PlayerPlaying += new EventHandler(Events_PlayerPlaying);&#10;            m_sourcePlayer.Mute = true;&#10;            m_renderPlayer = m_factory.CreatePlayer&#60;IVideoPlayer&#62;();&#10;            m_renderPlayer.WindowHandle = panel1.Handle;&#10;            m_inputMedia = m_factory.CreateMedia&#60;IMemoryInputMedia&#62;(MediaStrings.IMEM);&#10;            SetupOutput(m_sourcePlayer.CustomRendererEx);&#10;        &#125;&#10;&#10;        void Events_PlayerPlaying(object sender, EventArgs e)&#10;        &#123;&#10;            MicroSecondsBetweenFrame = (long)(MicroSecondsInSecomd / (m_sourcePlayer.FPS != 0 ? m_sourcePlayer.FPS : DefaultFps));&#10;        &#125;&#10;&#10;        private void SetupOutput(IMemoryRendererEx iMemoryRenderer)&#10;        &#123;&#10;            iMemoryRenderer.SetFormatSetupCallback(OnSetupCallback);&#10;            iMemoryRenderer.SetExceptionHandler(OnErrorCallback);&#10;            iMemoryRenderer.SetCallback(OnNewFrameCallback);&#10;        &#125;&#10;&#10;        private BitmapFormat OnSetupCallback(BitmapFormat format)&#10;        &#123;&#10;            SetupInput(format);&#10;            return new BitmapFormat(format.Width, format.Height, ChromaType.RV24);&#10;        &#125;&#10;&#10;        private void OnErrorCallback(Exception error)&#10;        &#123;&#10;            MessageBox.Show(error.Message);&#10;        &#125;&#10;&#10;        private void OnNewFrameCallback(PlanarFrame frame)&#10;        &#123;          &#10;            data.Data = frame.Planes[0];&#10;            data.DataSize = frame.Lenghts[0];&#10;            data.PTS = frameCounter++ * MicroSecondsBetweenFrame;&#10;            m_inputMedia.AddFrame(data);&#10;&#10;            if (/*m_inputMedia.PendingFramesCount == 10 &#38;&#38; */!m_renderPlayer.IsPlaying)&#10;            &#123;&#10;                m_renderPlayer.Play();&#10;            &#125;&#10;        &#125;&#10;&#10;        private void SetupInput(BitmapFormat format)&#10;        &#123;&#10;            var streamInfo = new StreamInfo();&#10;            streamInfo.Category = StreamCategory.Video;&#10;            streamInfo.Codec = VideoCodecs.BGR24;&#10;            streamInfo.Width = format.Width;&#10;            streamInfo.Height = format.Height;&#10;            streamInfo.Size = format.ImageSize;&#10;&#10;            m_inputMedia.Initialize(streamInfo);&#10;            m_inputMedia.SetExceptionHandler(OnErrorCallback);&#10;            m_renderPlayer.Open(m_inputMedia);           &#10;        &#125;&#10;&#10;        private void OpenSourceMedia(string path)&#10;        &#123;&#10;            //IMediaFromFile media = m_factory.CreateMedia&#60;IMediaFromFile&#62;(path);&#10;            IMedia media = m_factory.CreateMedia&#60;IMedia&#62;(path);&#10;            m_sourcePlayer.Open(media);&#10;            m_sourcePlayer.Play();&#10;            timer.Start();&#10;            &#10;        &#125;&#10;&#10;        private void button1_Click(object sender, EventArgs e)&#10;        &#123;&#10;            OpenSourceMedia(&#34;http://192.168.2.108:8090&#34;);&#10;        &#125;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://www.videolan.org" target="_blank" rel="external">VLC的官方网站</a>，VLC的源代码是用C语言实现的。我们这里用<code>C#</code>的封装——nVLC。<br><a href="]]>
    </summary>
    
      <category term="CSharp" scheme="https://kaiiak.github.io/tags/CSharp/"/>
    
      <category term="vlc" scheme="https://kaiiak.github.io/tags/vlc/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[通过pylirc实现红外控制]]></title>
    <link href="https://kaiiak.github.io/2015/11/14/%E9%80%9A%E8%BF%87pylirc%E5%AE%9E%E7%8E%B0%E7%BA%A2%E5%A4%96%E6%8E%A7%E5%88%B6/"/>
    <id>https://kaiiak.github.io/2015/11/14/通过pylirc实现红外控制/</id>
    <published>2015-11-14T12:39:40.000Z</published>
    <updated>2016-03-07T04:36:58.427Z</updated>
    <content type="html"><![CDATA[<h2 id="官方文档">官方文档</h2><p>在2005年更新的官方文档，点击<a href="http://bazaar.launchpad.net/~rockstar/pylirc2/trunk/view/head:/doc/simple.txt" target="_blank" rel="external">这里</a>.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyLirc v0.0.5&#10;&#10;Introduction&#10;&#10;pyLirc is a module for Python that interacts with lirc to give &#10;Python programs the ability to receive commands from remote &#10;controls.&#10;&#10;This isn&#39;t much of documentation, but at least it&#39;s a start and&#10;there isn&#39;t much to document right now anyway.&#10;&#10;&#10;Initialization&#10;&#10;Before you can receive any commands from lirc, you&#39;ll need to &#10;initialize the module. After importing pyLirc, call the pylirc.init()&#10;function:&#10;&#10;   import pylirc&#10;&#10;   integer = pylirc.init(string name[, string configuration [, integer blocking ]])&#10;&#10;the returnvalue is the returnvalue of lircs client library&#10;lirc_init(), ie a socket, or zero on failure.&#10;&#10;The socket can be used with select.select() to wait for data if you don&#39;t&#10;want to use blocking. This is especially useful in multithreaded programs&#10;as blocking mode of pylirc will blick all threads, whereas select() will&#10;only block the current and with optional timeout.&#10;&#10;name: the name used for your program in the lirc configuration&#10;file, must be supplied.&#10;&#10;configuration:  a filename to a lirc configuration file in case you wish not to&#10;use lircs default configuration file (usually ~/.lircrc).&#10;&#10;blocking: a flag indicating wether you want blocking mode or not. See also &#10;blocking() and select.select() (latter in python docs)&#10;&#10;&#10;Polling&#10;&#10;If initialization was ok, you can poll lirc for commands. To read any commands&#10;in queue call pylirc.nextcode():&#10;&#10;   list = pylirc.nextcode([integer Exteneded])&#10;&#10;The returnvalue is &#39;None&#39;, if no commands was on the queue, or a list&#10;containing the commands read.&#10;&#10;To get the commands one by one enumerate the list:&#10;&#10;   for code in list:&#10;      print code&#10;&#10;If you supply the optional argument Extended as true, code will be a dictionary&#10;otherwise it will be a string (old behaviour).&#10;&#10;The dictionary currently contains:&#10;&#34;config&#34;: The config string from lirc config file - the same string you&#39;d get in&#10;          non-extended mode.&#10;&#34;repeat&#34;: The repeat count of the buttonpress.&#10;      &#10;Note, that there can still be more commands on queue after a call&#10;to pylirc.nextcode(). You should call it in a loop until you get&#10;&#39;None&#39; back.&#10;&#10;&#10;Exiting&#10;&#10;When you&#39;re done using pyLirc and before you exit your program you&#10;should clean up:&#10;&#10;   pylirc.exit()&#10;&#10;&#10;Changing mode&#10;&#10;When you initialize pyLirc, you can chose wether you want blocking or&#10;non-blocking mode. Blocking mode means pylirc.nextcode() waits until&#10;there is a command to be read until it returns.&#10;To change mode after initialization, use blocking():&#10;&#10;   success = pylirc.blocking(int)</span><br></pre></td></tr></table></figure>
<h2 id="中文翻译">中文翻译</h2><p>自己尝试翻译一下，英语渣渣，有不正确的地方请指正。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyLirc v0.0.5&#10;&#10;&#20171;&#32461;&#10;&#10;pyLirc&#26159;&#19968;&#20010;&#19982;LIRC&#20132;&#20114;&#32473;&#10;Python&#31243;&#24207;&#20174;&#36828;&#31243;&#25509;&#25910;&#36828;&#31243;&#21629;&#20196;&#30340;&#33021;&#21147;&#10;&#30340;Python&#27169;&#22359;&#12290;&#10;&#10;&#36825;&#26159;&#27809;&#26377;&#22826;&#22810;&#30340;&#25991;&#26723;&#65292;&#27605;&#31455;&#23427;&#26159;&#19968;&#20010;&#26032;&#39033;&#30446;&#65292;&#10;&#29616;&#22312;&#21453;&#27491;&#27809;&#26377;&#22826;&#22810;&#30340;&#25991;&#26723;&#12290;&#10;&#10;&#21021;&#22987;&#21270;&#10;&#10;&#22312;&#25509;&#21463;&#26469;&#33258;lirc&#30340;&#21629;&#20196;&#20043;&#21069;&#65292;&#20320;&#24212;&#35813;&#21021;&#22987;&#21270;&#26412;&#27169;&#22359;&#12290;&#22312; import pylirc&#20043;&#21518;&#65292;&#20351;&#29992; pylirc.inti()&#20989;&#25968;&#65306;&#10;&#9;import pylirc&#10;&#9;integer = pylirc.init(string name[, string configuration [, integer blocking ]])&#10;&#36820;&#22238;&#20540;&#26159;&#23458;&#25143;&#31471;&#24211;&#20013;lirc_init()&#20989;&#25968;&#30340;&#36820;&#22238;&#20540;&#65292;&#26159;&#19968;&#20010;socket&#65292;&#22914;&#26524;&#36820;&#22238;&#20540;&#26159;0&#65292;&#21017;&#21021;&#22987;&#21270;&#22833;&#36133;&#12290;</span><br></pre></td></tr></table></figure>
<h1 id="示例代码">示例代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> pylirc</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Buttons</span>:</span></span><br><span class="line">    SELECT = <span class="number">0</span></span><br><span class="line">    RIGHT = <span class="number">1</span></span><br><span class="line">    DOWN = <span class="number">2</span></span><br><span class="line">    UP = <span class="number">3</span></span><br><span class="line">    LEFT = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, app, conf)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pylirc.init(app, conf, <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"Unable to init pylirc"</span>);</span><br><span class="line">        pylirc.blocking(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">readButton</span><span class="params">(self)</span>:</span></span><br><span class="line">        btn = pylirc.nextcode()</span><br><span class="line">        <span class="keyword">if</span> btn:</span><br><span class="line">            <span class="keyword">return</span> btn[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="官方文档">官方文档</h2><p>在2005年更新的官方文档，点击<a href="http://bazaar.launchpad.net/~rockstar/pylirc2/trunk/view/head:/doc/simple.txt" target="_b]]>
    </summary>
    
      <category term="pylirc" scheme="https://kaiiak.github.io/tags/pylirc/"/>
    
      <category term="树莓派" scheme="https://kaiiak.github.io/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[为Eclipse本地安装PyDev]]></title>
    <link href="https://kaiiak.github.io/2015/11/09/local-install-pydev-with-eclipse/"/>
    <id>https://kaiiak.github.io/2015/11/09/local-install-pydev-with-eclipse/</id>
    <published>2015-11-09T11:05:57.000Z</published>
    <updated>2015-11-09T11:31:35.282Z</updated>
    <content type="html"><![CDATA[<h3 id="由于众所周知的原因，国内的网络环境一直不是很好。最近我在Eclipse上安装Pydev也不可以了。所以，打算用本地安装的方法来解决。">由于众所周知的原因，国内的网络环境一直不是很好。最近我在Eclipse上安装Pydev也不可以了。所以，打算用本地安装的方法来解决。</h3><p>可以在<a href="http://sourceforge.net/projects/pydev" target="_blank" rel="external">这里</a>下载到最新的PyDev for Eclipse。<br>然后，将压缩包内的<code>features</code>和<code>plugins</code>文件夹拷贝到eclipse的安装目录下。重启eclipse，在<code>Help</code>-&gt;<code>About Eclipse</code>-&gt;<code>Installation Details</code>中看到PyDev的信息。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="由于众所周知的原因，国内的网络环境一直不是很好。最近我在Eclipse上安装Pydev也不可以了。所以，打算用本地安装的方法来解决。">由于众所周知的原因，国内的网络环境一直不是很好。最近我在Eclipse上安装Pydev也不可以了。所以，打算用本地安装的方法来解]]>
    </summary>
    
      <category term="Eclipse" scheme="https://kaiiak.github.io/tags/Eclipse/"/>
    
      <category term="PyDev" scheme="https://kaiiak.github.io/tags/PyDev/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Sqlite创建数据库]]></title>
    <link href="https://kaiiak.github.io/2015/11/04/sqlite-create-datebase/"/>
    <id>https://kaiiak.github.io/2015/11/04/sqlite-create-datebase/</id>
    <published>2015-11-04T13:53:54.000Z</published>
    <updated>2015-11-06T13:30:46.995Z</updated>
    <content type="html"><![CDATA[<p>其实很简单，但刚开始一点都不会。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$sqlite test.db&#10;SQLite version 2.8.17&#10;Enter &#34;.help&#34; for instructions&#10;sqlite&#62; .database&#10;seq  name             file                                                      &#10;---  ---------  -------------------------&#10;0    main        /home/pi/code/testDB.db</span><br></pre></td></tr></table></figure></p>
<p>这样就创建成功了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>其实很简单，但刚开始一点都不会。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="cod]]>
    </summary>
    
      <category term="sqlite" scheme="https://kaiiak.github.io/tags/sqlite/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ZOJ_1003:Crashing Ballon]]></title>
    <link href="https://kaiiak.github.io/2015/11/04/crashing-ballon/"/>
    <id>https://kaiiak.github.io/2015/11/04/crashing-ballon/</id>
    <published>2015-11-04T12:15:01.000Z</published>
    <updated>2015-11-04T13:07:12.484Z</updated>
    <content type="html"><![CDATA[<h1 id="题目">题目</h1><blockquote>
<p>On every June 1st, the Children’s Day, there will be a game named “crashing balloon” on TV.   The rule is very simple.  On the ground there are 100 labeled balloons, with the numbers 1 to 100.  After the referee shouts “Let’s go!” the two players, who each starts with a score of  “1”, race to crash the balloons by their feet and, at the same time, multiply their scores by the numbers written on the balloons they crash.  After a minute, the little audiences are allowed to take the remaining balloons away, and each contestant reports his\her score, the product of the numbers on the balloons he\she’s crashed.  The unofficial winner is the player who announced the highest score.</p>
<p>Inevitably, though, disputes arise, and so the official winner is not determined until the disputes are resolved.  The player who claims the lower score is entitled to challenge his\her opponent’s score.  The player with the lower score is presumed to have told the truth, because if he\she were to lie about his\her score, he\she would surely come up with a bigger better lie.  The challenge is upheld if the player with the higher score has a score that cannot be achieved with balloons not crashed by the challenging player.  So, if the challenge is successful, the player claiming the lower score wins.</p>
<p>So, for example, if one player claims 343 points and the other claims 49, then clearly the first player is lying; the only way to score 343 is by crashing balloons labeled 7 and 49, and the only way to score 49 is by crashing a balloon labeled 49.  Since each of two scores requires crashing the balloon labeled 49, the one claiming 343 points is presumed to be lying.</p>
<p>On the other hand, if one player claims 162 points and the other claims 81, it is possible for both to be telling the truth (e.g. one crashes balloons 2, 3 and 27, while the other crashes balloon 81), so the challenge would not be upheld.</p>
<p>By the way, if the challenger made a mistake on calculating his/her score, then the challenge would not be upheld. For example, if one player claims 10001 points and the other claims 10003, then clearly none of them are telling the truth. In this case, the challenge would not be upheld.</p>
<p>Unfortunately, anyone who is willing to referee a game of crashing balloon is likely to get over-excited in the hot atmosphere that he\she could not reasonably be expected to perform the intricate calculations that refereeing requires.  Hence the need for you, sober programmer, to provide a software solution.</p>
<p>Input</p>
<p>Pairs of unequal, positive numbers, with each pair on a single line, that are claimed scores from a game of crashing balloon.<br>Output</p>
<p>Numbers, one to a line, that are the winning scores, assuming that the player with the lower score always challenges the outcome.<br>Sample Input</p>
<p>343 49<br>3599 610<br>62 36</p>
<p>Sample Output</p>
<p>49<br>610<br>62</p>
</blockquote>
<h1 id="代码">代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=1003</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> f1, f2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> numa, <span class="keyword">int</span> numb, <span class="keyword">int</span> k)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(numb == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        f2 = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(numa == <span class="number">1</span>) f1 = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(k == <span class="number">1</span> || (f1 &amp;&amp; f2)) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(numa % k == <span class="number">0</span>) dfs(numa / k, numb, k - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(numb % k == <span class="number">0</span>) dfs(numa, numb / k, k - <span class="number">1</span>);</span><br><span class="line">	dfs(numa, numb, k - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a, b;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b) != EOF)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(a &lt; b) swap(a, b);</span><br><span class="line">		f1 = f2 = <span class="literal">false</span>;</span><br><span class="line">		dfs(a, b, <span class="number">100</span>);</span><br><span class="line">		<span class="keyword">if</span>(!f1 &amp;&amp; f2) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,b);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="题目">题目</h1><blockquote>
<p>On every June 1st, the Children’s Day, there will be a game named “crashing balloon” on TV.   The rule is]]>
    </summary>
    
      <category term="ACM" scheme="https://kaiiak.github.io/tags/ACM/"/>
    
      <category term="C" scheme="https://kaiiak.github.io/tags/C/"/>
    
      <category term="ZOJ" scheme="https://kaiiak.github.io/tags/ZOJ/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于树莓派lirc的配置]]></title>
    <link href="https://kaiiak.github.io/2015/10/31/%E5%85%B3%E4%BA%8E%E6%A0%91%E8%8E%93%E6%B4%BElirc%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    <id>https://kaiiak.github.io/2015/10/31/关于树莓派lirc的配置/</id>
    <published>2015-10-31T13:10:19.000Z</published>
    <updated>2015-11-01T12:02:55.707Z</updated>
    <content type="html"><![CDATA[<h2 id="记录原因">记录原因</h2><p>这是我正在DIY的一个<a href="https://github.com/kaiiak/NineSky/blob/master/README.md" target="_blank" rel="external">基于树莓派智能家居</a>的过程中，配置lirc的一个小问题的总结。<br>因为在网上搜索到的类似的博客给出的解决方式都不可行，所以打算记录下来，方便后来者。</p>
<h2 id="事情的起因">事情的起因</h2><p>安装lirc——一个开源的红外控制的库<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install lirc</span><br></pre></td></tr></table></figure></p>
<p>配置到这一步时，网络上给出的下一步都是在</p>
<blockquote>
<p>加载内核模块<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo modprobe lirc_rpi gpio_in_pin=23gpio_out_pin=24</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>然而照着做以后，并不能成功。</p>
<h2 id="解决方法">解决方法</h2><p>配置树莓派的lirc，需要在<code>/boot/config.txt</code>中添加，在<a href="https://github.com/raspberrypi/firmware/blob/master/boot/overlays/README" target="_blank" rel="external">这里</a>找到的。<br><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dtoverlay=lirc-rpi,gpio<span class="number">_</span><span class="keyword">in</span><span class="number">_p</span><span class="keyword">in</span>=<span class="number">23</span>,gpio<span class="number">_</span><span class="keyword">out</span><span class="number">_p</span><span class="keyword">in</span>=<span class="number">24</span></span><br></pre></td></tr></table></figure></p>
<p>然后重启就可以了。</p>
<p>加载lir_rpi内核模块<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo modprobe lirc_rpi</span><br></pre></td></tr></table></figure></p>
<p>测试<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mode2 -d /dev/lirc0</span><br></pre></td></tr></table></figure></p>
<p>现在就会看到一大串space和pulse交替产生。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="记录原因">记录原因</h2><p>这是我正在DIY的一个<a href="https://github.com/kaiiak/NineSky/blob/master/README.md" target="_blank" rel="external">基于树莓派智]]>
    </summary>
    
      <category term="Linux" scheme="https://kaiiak.github.io/tags/Linux/"/>
    
      <category term="lirc" scheme="https://kaiiak.github.io/tags/lirc/"/>
    
      <category term="树莓派" scheme="https://kaiiak.github.io/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用Python控制树莓派的GPIO(1)]]></title>
    <link href="https://kaiiak.github.io/2015/10/18/%E4%BD%BF%E7%94%A8Python%E6%8E%A7%E5%88%B6%E6%A0%91%E8%8E%93%E6%B4%BE%E7%9A%84GPIO-1/"/>
    <id>https://kaiiak.github.io/2015/10/18/使用Python控制树莓派的GPIO-1/</id>
    <published>2015-10-18T09:19:07.000Z</published>
    <updated>2016-03-07T04:37:13.411Z</updated>
    <content type="html"><![CDATA[<h3 id="使用的树莓派2B">使用的树莓派2B</h3><p>通过PRI.GPIO来实现Python控制树莓派的GPIO。</p>
<h2 id="安装">安装</h2><p>在<a href="http://pythonhosted.org/RPIO/" target="_blank" rel="external">官方文档</a>中给出了三种按章方式。分别是</p>
<h3 id="用_easy_install或者pip来安装：">用 <code>easy_install</code>或者<code>pip</code>来安装：</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python-setuptools&#10;sudo easy_install -U RPIO</span><br></pre></td></tr></table></figure>
<h3 id="从Github上克隆然后安装">从Github上克隆然后安装</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/metachris/RPIO.git&#10;cd RPIO&#10;sudo python setup.py install</span><br></pre></td></tr></table></figure>
<h3 id="从Github或者别处下载安装">从Github或者别处下载安装</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L https://github.com/metachris/RPIO/archive/master.tar.gz | tar -xz&#10;cd RPIO-master&#10;sudo python setup.py install</span><br></pre></td></tr></table></figure>
<h2 id="使用">使用</h2><p><img src="http://ww1.sinaimg.cn/mw690/ae94c92cgw1ex5fscddh0j20fi0bigqz.jpg" alt="树莓派引脚图"><br><img src="http://ww3.sinaimg.cn/mw690/ae94c92cgw1ex6qv7sjpoj20jq0c6gps.jpg" alt="树莓派2B引脚图"></p>
<p>这是用wiringPi生成的引脚图，用wiringPi控制GPIO会在以后写。</p>
<p>树莓派的GPIO大致可以分为INPUT和OUTPUT两种状态。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> RPIO</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置为输入位无上拉</span></span><br><span class="line">RPIO.setup(<span class="number">7</span>, RPIO.IN)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置为输出位有上拉. 可以设置为</span></span><br><span class="line"><span class="comment"># PUD_UP(上拉), PUD_DOWN(下拉) or PUD_OFF (default)</span></span><br><span class="line">RPIO.setup(<span class="number">7</span>, RPIO.IN, pull_up_down=RPIO.PUD_UP)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取GPIO7的输入状态</span></span><br><span class="line">input_value = RPIO.input(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置GPIO为输出位</span></span><br><span class="line">RPIO.setup(<span class="number">8</span>, RPIO.OUT)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置GPIO8为高电位</span></span><br><span class="line">RPIO.output(<span class="number">8</span>, <span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置为输出位并给予一个初始值</span></span><br><span class="line">RPIO.setup(<span class="number">8</span>, RPIO.OUT, initial=RPIO.LOW)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 改变为BOARD编号模式</span></span><br><span class="line">RPIO.setmode(RPIO.BOARD)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在通道17上设置软件上拉</span></span><br><span class="line">RPIO.set_pullupdn(<span class="number">17</span>, RPIO.PUD_UP)  <span class="comment"># new in RPIO</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得通道8的设置(IN、OUT、ALTo)</span></span><br><span class="line">RPIO.gpio_function(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复位所有由该程序设置过的通道，</span></span><br><span class="line"><span class="comment"># 并清除 GPIO 中断接口</span></span><br><span class="line">RPIO.cleanup()</span><br></pre></td></tr></table></figure>
<p>照着上一篇文章写的那样做，并不能成功。因为RPIO的最后一个release版本是2013年的，并不支持我的树莓派2B。</p>
<p>如果想在树莓派2B上运行，需要做这些工作<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install rpi.gpio&#10;sudo pip freeze</span><br></pre></td></tr></table></figure></p>
<p>如果有一行<code>RPi.GPIO==0.511</code>就说明安装成功了。</p>
<p>然后我们在新建<code>led.py</code>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> RPi.GPIO <span class="keyword">as</span> GPIO</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">LED = <span class="number">4</span> </span><br><span class="line"></span><br><span class="line">GPIO.setmode(GPIO.BCM)</span><br><span class="line">GPIO.setup(LED, GPIO.OUT)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"结束程序，请按CTRL+C"</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	<span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">		GPIO.output(LED, <span class="keyword">False</span>)</span><br><span class="line">		<span class="comment">#延时1s</span></span><br><span class="line">		time.sleep(<span class="number">1</span>)</span><br><span class="line">		GPIO.output(LED, <span class="keyword">True</span>)</span><br><span class="line">		time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">except</span> KeyboardInterrupt: <span class="comment"># 如果程序被CTRL+C结束</span></span><br><span class="line">	GPIO.cleanup()</span><br></pre></td></tr></table></figure></p>
<p>前几天搞不懂GPIO.setmode函数中的参数GPIO.BCM和GPIO.BOARD指的是什么。<br>后来知道BOARD指的是主板引脚编号，而BCM指的是BCM芯片的引脚编号，在本文的配图中有。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="使用的树莓派2B">使用的树莓派2B</h3><p>通过PRI.GPIO来实现Python控制树莓派的GPIO。</p>
<h2 id="安装">安装</h2><p>在<a href="http://pythonhosted.org/RPIO/" target="]]>
    </summary>
    
      <category term="PRI.GPIO" scheme="https://kaiiak.github.io/tags/PRI-GPIO/"/>
    
      <category term="Pyhon" scheme="https://kaiiak.github.io/tags/Pyhon/"/>
    
      <category term="树莓派" scheme="https://kaiiak.github.io/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用Xshell进行上传和下载]]></title>
    <link href="https://kaiiak.github.io/2015/10/12/%E4%BD%BF%E7%94%A8Xshell%E8%BF%9B%E8%A1%8C%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/"/>
    <id>https://kaiiak.github.io/2015/10/12/使用Xshell进行上传和下载/</id>
    <published>2015-10-12T13:13:53.000Z</published>
    <updated>2015-10-12T13:28:27.428Z</updated>
    <content type="html"><![CDATA[<p>在日常使用Xshell进行远程登录的时候，我们想通过Xshell在Windows和Linux之间便捷的进行文件传输，这时候我们可以使用 <code>rz</code> 或 <code>sz</code> 命令。</p>
<p>在树莓派上安装<code>rz</code>和<code>sz</code>命令。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> install lrzsz</span><br></pre></td></tr></table></figure>
<p>下载某个文件或文件夹<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sz</span> filename</span><br></pre></td></tr></table></figure></p>
<p><code>rz</code>直接把文件拖到Xshell上就可以了.</p>
<p><code>sz</code>和<code>rz</code>的帮助文档<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">rz version 0.12.21rc</span><br><span class="line">Usage: rz [options] [filename.if.xmodem]</span><br><span class="line">Receive files with ZMODEM/YMODEM/XMODEM protocol</span><br><span class="line">    (X) = option applies to XMODEM only</span><br><span class="line">    (Y) = option applies to YMODEM only</span><br><span class="line">    (Z) = option applies to ZMODEM only</span><br><span class="line">  -<span class="ruby">+, --append                append to existing files</span><br><span class="line"></span>  -<span class="ruby">a, --ascii                 <span class="constant">ASCII</span> transfer (change <span class="constant">CR</span>/<span class="constant">LF</span> to <span class="constant">LF</span>)</span><br><span class="line"></span>  -<span class="ruby">b, --binary                binary transfer</span><br><span class="line"></span>  -<span class="ruby"><span class="constant">B</span>, --bufsize <span class="constant">N</span>             buffer <span class="constant">N</span> bytes (<span class="constant">N</span>==<span class="symbol">auto:</span> buffer whole file)</span><br><span class="line"></span>  -<span class="ruby">c, --with-crc              <span class="constant">Use</span> <span class="number">16</span> bit <span class="constant">CRC</span> (<span class="constant">X</span>)</span><br><span class="line"></span>  -<span class="ruby"><span class="constant">C</span>, --allow-remote-commands allow execution of remote commands (<span class="constant">Z</span>)</span><br><span class="line"></span>  -<span class="ruby"><span class="constant">D</span>, --null                  write all received data to /dev/null</span><br><span class="line"></span>      -<span class="ruby">-delay-startup <span class="constant">N</span>       sleep <span class="constant">N</span> seconds before doing anything</span><br><span class="line"></span>  -<span class="ruby">e, --escape                <span class="constant">Escape</span> control characters (<span class="constant">Z</span>)</span><br><span class="line"></span>  -<span class="ruby"><span class="constant">E</span>, --rename                rename any files already existing</span><br><span class="line"></span>      -<span class="ruby">-errors <span class="constant">N</span>              generate <span class="constant">CRC</span> error every <span class="constant">N</span> bytes (debugging)</span><br><span class="line"></span>  -<span class="ruby">h, --help                  <span class="constant">Help</span>, print this usage message</span><br><span class="line"></span>  -<span class="ruby">m, --min-bps <span class="constant">N</span>             stop transmission <span class="keyword">if</span> <span class="constant">BPS</span> below <span class="constant">N</span></span><br><span class="line"></span>  -<span class="ruby"><span class="constant">M</span>, --min-bps-time <span class="constant">N</span>          <span class="keyword">for</span> at least <span class="constant">N</span> seconds (<span class="symbol">default:</span> <span class="number">120</span>)</span><br><span class="line"></span>  -<span class="ruby"><span class="constant">O</span>, --disable-timeouts      disable timeout code, wait forever <span class="keyword">for</span> data</span><br><span class="line"></span>      -<span class="ruby">-o-sync                open output file(s) <span class="keyword">in</span> synchronous write mode</span><br><span class="line"></span>  -<span class="ruby">p, --protect               protect existing files</span><br><span class="line"></span>  -<span class="ruby">q, --quiet                 quiet, no progress reports</span><br><span class="line"></span>  -<span class="ruby">r, --resume                try to resume interrupted file transfer (<span class="constant">Z</span>)</span><br><span class="line"></span>  -<span class="ruby"><span class="constant">R</span>, --restricted            restricted, more secure mode</span><br><span class="line"></span>  -<span class="ruby">s, --stop-at &#123;<span class="constant">HH</span><span class="symbol">:MM|+N</span>&#125;    stop transmission at <span class="constant">HH</span><span class="symbol">:MM</span> <span class="keyword">or</span> <span class="keyword">in</span> <span class="constant">N</span> seconds</span><br><span class="line"></span>  -<span class="ruby"><span class="constant">S</span>, --timesync              request remote time (<span class="symbol">twice:</span> set local time)</span><br><span class="line"></span>      -<span class="ruby">-syslog[=off]          turn syslog on <span class="keyword">or</span> off, <span class="keyword">if</span> possible</span><br><span class="line"></span>  -<span class="ruby">t, --timeout <span class="constant">N</span>             set timeout to <span class="constant">N</span> tenths of a second</span><br><span class="line"></span>      -<span class="ruby">-tcp-server            open socket, wait <span class="keyword">for</span> connection (<span class="constant">Z</span>)</span><br><span class="line"></span>      -<span class="ruby">-tcp-client <span class="constant">ADDR</span><span class="symbol">:PORT</span>  open socket, connect to ... (<span class="constant">Z</span>)</span><br><span class="line"></span>  -<span class="ruby">u, --keep-uppercase        keep upper <span class="keyword">case</span> filenames</span><br><span class="line"></span>  -<span class="ruby"><span class="constant">U</span>, --unrestrict            disable restricted mode (<span class="keyword">if</span> allowed to)</span><br><span class="line"></span>  -<span class="ruby">v, --verbose               be verbose, provide debugging information</span><br><span class="line"></span>  -<span class="ruby">w, --windowsize <span class="constant">N</span>          <span class="constant">Window</span> is <span class="constant">N</span> bytes (<span class="constant">Z</span>)</span><br><span class="line"></span>  -<span class="ruby"><span class="constant">X</span>  --xmodem                use <span class="constant">XMODEM</span> protocol</span><br><span class="line"></span>  -<span class="ruby">y, --overwrite             <span class="constant">Yes</span>, clobber existing file <span class="keyword">if</span> any</span><br><span class="line"></span>      -<span class="ruby">-ymodem                use <span class="constant">YMODEM</span> protocol</span><br><span class="line"></span>  -<span class="ruby"><span class="constant">Z</span>, --zmodem                use <span class="constant">ZMODEM</span> protocol</span><br><span class="line"></span></span><br><span class="line">short options use the same arguments as the long ones</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在日常使用Xshell进行远程登录的时候，我们想通过Xshell在Windows和Linux之间便捷的进行文件传输，这时候我们可以使用 <code>rz</code> 或 <code>sz</code> 命令。</p>
<p>在树莓派上安装<code>rz</code>和<]]>
    </summary>
    
      <category term="Linux" scheme="https://kaiiak.github.io/tags/Linux/"/>
    
      <category term="Xshell" scheme="https://kaiiak.github.io/tags/Xshell/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[树莓派直连电脑二三事]]></title>
    <link href="https://kaiiak.github.io/2015/10/11/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%9B%B4%E8%BF%9E%E7%94%B5%E8%84%91%E4%BA%8C%E4%B8%89%E4%BA%8B/"/>
    <id>https://kaiiak.github.io/2015/10/11/树莓派直连电脑二三事/</id>
    <published>2015-10-11T12:09:35.000Z</published>
    <updated>2016-03-07T04:37:04.882Z</updated>
    <content type="html"><![CDATA[<h2 id="解决方法">解决方法</h2><p>因为在学校的实验室网络不是很稳定，所以树莓派一直不能直接用网线连接网络。而且wpa_supplication真的很不稳定，莫名其妙的罢工好几次，每次只能重新写镜像。<br>种种原因选择了直连电脑的方法来联网,而我的电脑连接的是信号很弱的无线网，无奈条件太艰苦。</p>
<p>需要额外准备的东西就是一根直通线啦。好啦，接下来就是设置的时间了。</p>
<p>首先打开网络与共享中心-&gt;更改适配器设置-&gt;右击无线网络连接-&gt;属性-&gt;共享。<br>如图：<br>        <img src="http://ww2.sinaimg.cn/mw690/ae94c92cgw1ewxgxexpm2j20ah0camy8.jpg" alt="无线网络属性共享"><br>根据别人写的教程，做到这步就可以实现远程登录树莓派和树莓派访问外网了。但是我只能实现远程登录树莓派，访问外网实现不了。经过试验，是没有配置DNS服务器的原因，在本地连接的IPV4属性中添加DNS服务器就可以了。这里我使用的是OpenDNS。<br>        <img src="http://ww3.sinaimg.cn/mw690/ae94c92cgw1ewxgxrj8stj20bi0bxgn5.jpg" alt="IPV4属性"></p>
<h2 id="原理">原理</h2><p>windows实现直连访问的技术叫做ICS，百科上的解释如下：</p>
<blockquote>
<p>ICS即Internet连接共享(InternetConnectionSharing)的英文简称，是Windows系统针对家庭网络或小型的Intranet网络提供的一种Internet连接共享服务。它实际上相当于一种网络地址转换器，所谓网络地址转换器就是当数据包向前传递的过程中，可以转换数据包中的IP地址和TCP/UDP端口等地址信息。有了网络地址转换器，家庭网络或小型的办公网络中的电脑就可以使用私有地址，并且通过网络地址转换器将私有地址转换成ISP分配的单一的公用IP地址从而实现对Internet的连接。ICS方式也称之为Internet转换连接。</p>
</blockquote>
<p>这里是<a href="http://windows.microsoft.com/zh-cn/windows/using-internet-connection-sharing#1TC=windows-7" target="_blank" rel="external">在微软的官方帮助文档</a>中对ICS的介绍，使用它也可以连接路由器使用。</p>
<h3 id="推荐阿里和中科大的的树莓派镜像">推荐阿里和中科大的的树莓派镜像</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deb <span class="symbol">http:</span>/<span class="regexp">/mirrors.aliyun.com/raspbian</span><span class="regexp">/raspbian/</span>   wheezy main contrib non-free rpi</span><br><span class="line">deb <span class="symbol">http:</span>/<span class="regexp">/mirrors.ustc.edu.cn/raspbian</span><span class="regexp">/raspbian/</span>   wheezy main contrib non-free rpi</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="解决方法">解决方法</h2><p>因为在学校的实验室网络不是很稳定，所以树莓派一直不能直接用网线连接网络。而且wpa_supplication真的很不稳定，莫名其妙的罢工好几次，每次只能重新写镜像。<br>种种原因选择了直连电脑的方法来联网,而我的电脑连接的是信]]>
    </summary>
    
      <category term="树莓派" scheme="https://kaiiak.github.io/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[打算买个小米路由刷openWRT]]></title>
    <link href="https://kaiiak.github.io/2015/08/05/%E6%89%93%E7%AE%97%E4%B9%B0%E4%B8%AA%E6%9E%81%E8%B7%AF%E7%94%B1%E5%88%B7openWRT/"/>
    <id>https://kaiiak.github.io/2015/08/05/打算买个极路由刷openWRT/</id>
    <published>2015-08-05T09:28:20.000Z</published>
    <updated>2015-08-05T13:07:03.017Z</updated>
    <content type="html"><![CDATA[<p>主要是因为学校的天翼客户端不能用路由器，这样的话我的树莓派就没法用了。<br>所以买个路由器刷openWRT，然后破解客户端，在openWRT上编写破解程序用路由器分享wifi。毕竟动态域名也是要一个外网ip的。<br>哈哈～<br>这是想象之中的，但愿我能坚持下来吧。<br>Thx～<br>然而在极路由和小米路由器mini之间我选择了小米路由mini。<br>毕竟第一次折腾openWRT，不是很敢自己刷。可以直接在他们定制的openWRT系统上折腾。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>主要是因为学校的天翼客户端不能用路由器，这样的话我的树莓派就没法用了。<br>所以买个路由器刷openWRT，然后破解客户端，在openWRT上编写破解程序用路由器分享wifi。毕竟动态域名也是要一个外网ip的。<br>哈哈～<br>这是想象之中的，但愿我能坚持下来吧。<b]]>
    </summary>
    
      <category term="openWRT" scheme="https://kaiiak.github.io/tags/openWRT/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[解决Yilia主题的subnav中链接的问题]]></title>
    <link href="https://kaiiak.github.io/2015/08/01/%E8%A7%A3%E5%86%B3Yilia%E4%B8%BB%E9%A2%98%E7%9A%84subnav%E4%B8%AD%E9%93%BE%E6%8E%A5%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://kaiiak.github.io/2015/08/01/解决Yilia主题的subnav中链接的问题/</id>
    <published>2015-07-31T16:11:23.000Z</published>
    <updated>2016-03-07T04:37:18.578Z</updated>
    <content type="html"><![CDATA[<h2 id="问题说明">问题说明</h2><p>我很喜欢Yilia这个漂亮的主题，但是当我自己用的时候发现在subnav区生成的链接并不是我想要的。比如我的github地址是<code>github.com/kaiiak</code>，但是实际生成的是<code>kaiiak.github.io/github.com/kaiiak</code>。微博地址也是这样，邮箱地址也是。</p>
<h2 id="心路历程">心路历程</h2><p>我一点一点试验嘛，今天一晚上翻来覆去改了有30多次。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">subnav:</span><br><span class="line">  github: "https://github.com/kaiiak"</span><br><span class="line">  weibo:  "http://weibo.com/itkaikai"</span><br><span class="line">  #mail:   "itkaikai@gmail.com"</span><br></pre></td></tr></table></figure>
<p>  这时可以了，我以为是因为链接对齐了呢，可是我把mail那里的<code>#</code>去掉后，发现邮箱那一栏生成的地址还是没变啊。我又陷入了沉思～</p>
<h2 id="问题解决">问题解决</h2><p>解决的原因是我把git生成的diff看了一遍，发现微博那一栏在没加<code>http://</code>时，生成的html代码是这样的<code>/weibo.com/itkaikai</code>，加了<code>http://</code>后生成的html代码就变成了<code>http://weibo.com/itkaikai</code>了。看到这里，大家一定会明白了。<br>把subnav改成这样子就可以了。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">subnav:</span><br><span class="line">  github: "https://github.com/kaiiak"</span><br><span class="line">  weibo:  "http://weibo.com/itkaikai"</span><br><span class="line">  mail:   "mailto:itkaikai@gmail.com"</span><br></pre></td></tr></table></figure></p>
<h2 id="后记">后记</h2><p>把时间花费在打磨工具上有点很吃亏啊，还是等有钱买个vps好了。<br>晚安～</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="问题说明">问题说明</h2><p>我很喜欢Yilia这个漂亮的主题，但是当我自己用的时候发现在subnav区生成的链接并不是我想要的。比如我的github地址是<code>github.com/kaiiak</code>，但是实际生成的是<code>kaiiak]]>
    </summary>
    
      <category term="Hexo主题" scheme="https://kaiiak.github.io/tags/Hexo%E4%B8%BB%E9%A2%98/"/>
    
  </entry>
  
</feed>