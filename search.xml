<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>APUE学习笔记——文件和目录</title>
    <url>//2016/02/29/APUE_study_notes-Files_and_Directories/</url>
    <content><![CDATA[<h1 id="函数stat、fstat、fstatat、lstat"><a href="#函数stat、fstat、fstatat、lstat" class="headerlink" title="函数stat、fstat、fstatat、lstat"></a>函数<code>stat</code>、<code>fstat</code>、<code>fstatat</code>、<code>lstat</code></h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> pathname, <span class="keyword">struct</span> stat *<span class="keyword">restrict</span> buf)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fstat</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> stat *buf)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">lstat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> pathname, <span class="keyword">struct</span> stat *<span class="keyword">restrict</span> buf)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">lstat</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> pathname, <span class="keyword">struct</span> stat *<span class="keyword">restrict</span> buf, <span class="type">int</span> flag)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 所有4个函数的返回值：若成功，返回0；若出错，返回-1 */</span></span><br><span class="line"></span><br><span class="line">sturct stat &#123; </span><br><span class="line">    <span class="type">mode_t</span>          st_mode;        <span class="comment">/* file type &amp; mode (permissions) */</span></span><br><span class="line">    <span class="type">ino_t</span>           st_ino;         <span class="comment">/* i-node number (serial number) */</span></span><br><span class="line">    <span class="type">dev_t</span>           st_dev;         <span class="comment">/* device number (file system) */</span></span><br><span class="line">    <span class="type">dev_t</span>           st_rdev;        <span class="comment">/* device number for special files */</span></span><br><span class="line">    <span class="type">nlink_t</span>         st_nlink;       <span class="comment">/* number of links */</span></span><br><span class="line">    <span class="type">uid_t</span>           st_uid;         <span class="comment">/* user ID of links */</span></span><br><span class="line">    <span class="type">gid_t</span>           st_gid;         <span class="comment">/* group ID of owner */</span></span><br><span class="line">    <span class="type">off_t</span>           st_size;        <span class="comment">/* size in bytes, for regular files  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_atime</span>;</span>       <span class="comment">/* time of last access */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_mtime</span>;</span>       <span class="comment">/* time of last modification */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_ctime</span>;</span>       <span class="comment">/* time of last file status change */</span></span><br><span class="line">    <span class="type">blksize_t</span>       st_blksize;     <span class="comment">/* best I/O block size */</span></span><br><span class="line">    <span class="type">blkcnt_t</span>        st_blocks;      <span class="comment">/* number of disk blocks allocated */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>函数<code>stat</code>:返回<code>pathname</code>命名文件有关的信息结构；</li>
<li>函数<code>fstat</code>:返回在描述符<code>fd</code>上打开文件的有关信息；</li>
<li>函数<code>lstat</code>:类似于函数<code>stat</code>，但当命名的文件是一个符号链接时，<code>lstat</code>返回该符号连接的有关信息；</li>
<li>函数<code>fstatat</code>:为一个相对于当前打开目录(由<code>fd</code>参数指向)的路径名返回文件统计信息。</li>
</ul>
<p>文件信息包含<code>stat</code>结构的<code>st_mode</code>成员中。可以下表中的宏文件确定文件的类型。</p>
<table>
<thead>
<tr>
<th>宏</th>
<th align="left">文件类型</th>
</tr>
</thead>
<tbody><tr>
<td><code>S_ISREG()</code></td>
<td align="left">普通文件</td>
</tr>
<tr>
<td><code>S_ISDIR()</code></td>
<td align="left">目录文件</td>
</tr>
<tr>
<td><code>S_ISCHR()</code></td>
<td align="left">字符特殊文件</td>
</tr>
<tr>
<td><code>S_ISBLK()</code></td>
<td align="left">块特殊文件</td>
</tr>
<tr>
<td><code>S_ISFIFO()</code></td>
<td align="left">管道或FIFO</td>
</tr>
<tr>
<td><code>S_ISLNK()</code></td>
<td align="left">符号链接</td>
</tr>
<tr>
<td><code>S_ISSOCK()</code></td>
<td align="left">套接字</td>
</tr>
</tbody></table>
<h1 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h1><p>文件类型包括如下几类：</p>
<ol>
<li>普通文件(regular file):包含了某种形式的数据；</li>
<li>目录文件(directory file):包含了其他文件的名字以及指向与这些文件有关信息的指针；</li>
<li>块特殊文件(block special file):该类型文件提供对设备(如磁盘)带缓冲的访问，每次访问以固定长度为单位进行；</li>
<li>字符特殊文件(character special file):该文件提供对设备不带缓冲的访问，每次访问长度不变。系统中的所有设备要么是字符特殊文件，要么是块特殊文件。</li>
<li>FIFO:该文件用于进程通信，也称为命名管道(named pipe)；</li>
<li>套接字(socket)：该文件用于进程间的网络通信，也可以用在一台宿主机上进程间的非网络通信。</li>
<li>符号链接(symbolic link):该文件指向另一个文件。</li>
</ol>
<h1 id="设置用户ID和设置组ID"><a href="#设置用户ID和设置组ID" class="headerlink" title="设置用户ID和设置组ID"></a>设置用户ID和设置组ID</h1><ul>
<li>实际用户ID和实际组ID标识我们究竟是谁。</li>
<li>有效用户ID、有效组ID以及附属组ID决定了我们的文件访问权限。</li>
<li>保存的设置用户ID和保存的设置组ID在执行一个程序时包含了有效用户ID和有效组ID的副本。</li>
</ul>
<p>每个文件有一个所有者和组所有者，所有者由<code>stat</code>结构中的<code>st_uid</code>指定，组所有者则由<code>st_gid</code>指定。</p>
<h1 id="文件访问权限"><a href="#文件访问权限" class="headerlink" title="文件访问权限"></a>文件访问权限</h1><p>所有文件类型(目录、字符特别文件等)都有访问权限(access permisiion)。</p>
<table>
<thead>
<tr>
<th><code>st_mode</code>屏蔽</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>S_IRUSR</code></td>
<td align="left">用户都</td>
</tr>
<tr>
<td><code>S_IWUSR</code></td>
<td align="left">用户写</td>
</tr>
<tr>
<td><code>S_IXUSR</code></td>
<td align="left">用户执行</td>
</tr>
<tr>
<td><code>S_IRGRP</code></td>
<td align="left">组读</td>
</tr>
<tr>
<td><code>S_IWGRP</code></td>
<td align="left">组写</td>
</tr>
<tr>
<td><code>S_IXGRP</code></td>
<td align="left">组执行</td>
</tr>
<tr>
<td><code>S_IROTH</code></td>
<td align="left">其他读</td>
</tr>
<tr>
<td><code>S_IWOTH</code></td>
<td align="left">其他写</td>
</tr>
<tr>
<td><code>S_IXOTH</code></td>
<td align="left">其他执行</td>
</tr>
</tbody></table>
<h1 id="函数access和faccessat"><a href="#函数access和faccessat" class="headerlink" title="函数access和faccessat"></a>函数<code>access</code>和<code>faccessat</code></h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">access</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> mode)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">faccessat</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> mode, <span class="type">int</span> flag)</span>;</span><br><span class="line"><span class="comment">/* 两个函数的返回值：若成功，返回0；若出错，返回-1 */</span></span><br></pre></td></tr></table></figure>

<p><code>access</code>和<code>faccessat</code>函数是按实际用户ID和实际组ID进行访问权限测试的。</p>
<table>
<thead>
<tr>
<th><code>mode</code></th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>R_OK</code></td>
<td align="left">测试读权限</td>
</tr>
<tr>
<td><code>W_OK</code></td>
<td align="left">测试写权限</td>
</tr>
<tr>
<td><code>X_OK</code></td>
<td align="left">测试执行权限</td>
</tr>
</tbody></table>
<h1 id="函数umask"><a href="#函数umask" class="headerlink" title="函数umask"></a>函数<code>umask</code></h1><p><code>umask</code>函数为进程设置文件模式创建屏蔽字(mask for the process)，并返回之前的值。(这是少数几个没有出错返回函数中的一个。)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">mode_t</span> <span class="title function_">umask</span><span class="params">(<span class="type">mode_t</span> cmask)</span>;</span><br><span class="line"><span class="comment">/* 返回值：之前的文件模式穿件屏蔽字 */</span></span><br></pre></td></tr></table></figure>
<p>参数<code>cmask</code>是由上上个表列出的9个常量(S_IRUSR、S_IWUSR等)中若干个按位“或”构成的。</p>
<table>
<thead>
<tr>
<th>屏蔽位</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td>0400</td>
<td align="left">用户读</td>
</tr>
<tr>
<td>0200</td>
<td align="left">用户写</td>
</tr>
<tr>
<td>0100</td>
<td align="left">用户执行</td>
</tr>
<tr>
<td>0040</td>
<td align="left">组读</td>
</tr>
<tr>
<td>0020</td>
<td align="left">组写</td>
</tr>
<tr>
<td>0010</td>
<td align="left">组执行</td>
</tr>
<tr>
<td>0004</td>
<td align="left">其他读</td>
</tr>
<tr>
<td>0002</td>
<td align="left">其他写</td>
</tr>
<tr>
<td>0001</td>
<td align="left">其他执行</td>
</tr>
</tbody></table>
<h1 id="函数chmod、fchmod和fchmodat"><a href="#函数chmod、fchmod和fchmodat" class="headerlink" title="函数chmod、fchmod和fchmodat"></a>函数<code>chmod</code>、<code>fchmod</code>和<code>fchmodat</code></h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">chomd</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fchome</span><span class="params">(<span class="type">int</span> fd, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fchomdat</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode, <span class="type">int</span> flag)</span>;</span><br><span class="line"><span class="comment">/* 3个函数返回值：若成功，返回0；若出错，返回-1 */</span></span><br></pre></td></tr></table></figure>

<p><code>chmod</code>函数在指定的文件上进行操作，而<code>fchmod</code>函数则对已打开的文件进行操作。<br><code>fchomdat</code>函数与<code>chmod</code>函数在下面两种情况下是相同的：一种是<code>pathname</code>参数为绝对路径，另一种是<code>fd</code>参数取值为<code>AT_FDCWD</code>而<code>pathname</code>参数为相对路径。否则，<code>fchmodat</code>计算相对于打开目录(由<code>fd</code>参数指向)的pathname。<code>flag</code>参数可以用于改变<code>fchmodat</code>的行为，当设置了<code>AT_SYMLIN_NOFOLLOW</code>标志时，<code>fchmodat</code>并不会跟随符号链接。</p>
<table>
<thead>
<tr>
<th><code>mode</code></th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>S_ISUID</code></td>
<td align="left">执行时设置用户ID</td>
</tr>
<tr>
<td><code>S_ISGID</code></td>
<td align="left">执行时设置组ID</td>
</tr>
<tr>
<td><code>S_ISVTX</code></td>
<td align="left">保存正文(粘着位)</td>
</tr>
<tr>
<td><code>S_IRWXU</code></td>
<td align="left">用户(所有者)读、写和执行</td>
</tr>
<tr>
<td><code>S_IRUSR</code></td>
<td align="left">用户(所有者)读</td>
</tr>
<tr>
<td><code>S_IWUSR</code></td>
<td align="left">用户(所有者)写</td>
</tr>
<tr>
<td><code>S_IXUSR</code></td>
<td align="left">用户(所有者)执行</td>
</tr>
<tr>
<td><code>S_IRWXG</code></td>
<td align="left">组读、写和执行</td>
</tr>
<tr>
<td><code>S_IRGRP</code></td>
<td align="left">组读</td>
</tr>
<tr>
<td><code>S_IWGRP</code></td>
<td align="left">组写</td>
</tr>
<tr>
<td><code>S_IXGRP</code></td>
<td align="left">组执行</td>
</tr>
<tr>
<td><code>S_IRWXO</code></td>
<td align="left">其他读、写和执行</td>
</tr>
<tr>
<td><code>S_IROTH</code></td>
<td align="left">其他读</td>
</tr>
<tr>
<td><code>S_IWOTH</code></td>
<td align="left">其他写</td>
</tr>
<tr>
<td><code>S_IXOTH</code></td>
<td align="left">其他执行</td>
</tr>
</tbody></table>
<h1 id="粘着位-sticky-bit"><a href="#粘着位-sticky-bit" class="headerlink" title="粘着位(sticky bit)"></a>粘着位(sticky bit)</h1><p><code>S_ISVTX</code>位被称为<code>粘着位</code>：如果一个可执行的程序文件的这一位被设置了，那么当程序第一次被执行，在其终止时，程序正文的一个副本仍被保存在交换区。<br>后来的UNIX版本称为它为<code>保存正文位(saved-text bit)</code>，因此也就有了常量<code>S_ISVTX</code>。</p>
<h1 id="函数chown、fchown、fchownat和lchown"><a href="#函数chown、fchown、fchownat和lchown" class="headerlink" title="函数chown、fchown、fchownat和lchown"></a>函数<code>chown</code>、<code>fchown</code>、<code>fchownat</code>和<code>lchown</code></h1><p>下面几个<code>chown</code>函数可用于更改文件的用户ID和组ID。如果两个参数<code>owner</code>或<code>group</code>中的任意一个是-1，则对应的ID不变。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">chown</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">uid_t</span> owner, <span class="type">git_t</span> group)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fchown</span><span class="params">(<span class="type">int</span> fd, <span class="type">uid_t</span> owner, <span class="type">gid_t</span> group)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fchownat</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">uid_t</span> owner, <span class="type">gid_t</span> group, <span class="type">int</span> flag)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">lchown</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">uid_t</span> owner, <span class="type">gid_t</span> group)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 4个函数的返回值：若辰宫，返回0；若出错，返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h1 id="文件长度"><a href="#文件长度" class="headerlink" title="文件长度"></a>文件长度</h1><p><code>stat</code>结构成员<code>st_size</code>表示以字节为单位的单位长度。只对普通文件、目录文件和符号连接有效。</p>
<h1 id="文件中的空洞"><a href="#文件中的空洞" class="headerlink" title="文件中的空洞"></a>文件中的空洞</h1><p>空洞是由所设置的偏移量超过文件端尾，并写入了某些数据后造成的。</p>
<h1 id="文件截断"><a href="#文件截断" class="headerlink" title="文件截断"></a>文件截断</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">truncate</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">off_t</span> length)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">ftruncate</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> length)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 两个函数的返回值：若成功，返回0；若失败，返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>如果该文件以前的长度大于<code>length</code>，则超过<code>length</code>以外的数据就不能再访问。如果以前的长度小于<code>length</code>，文件长度将增加，在以前的文件尾端和新的文件尾端之间的数据将读作0。</p>
<h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><h1 id="函数link、linkat、unlink、unlinkat和remove"><a href="#函数link、linkat、unlink、unlinkat和remove" class="headerlink" title="函数link、linkat、unlink、unlinkat和remove"></a>函数<code>link</code>、<code>linkat</code>、<code>unlink</code>、<code>unlinkat</code>和<code>remove</code></h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">link</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *existingpath, <span class="type">const</span> <span class="type">char</span> *newpath)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">linkat</span><span class="params">(<span class="type">int</span> efd, <span class="type">const</span> <span class="type">char</span> *existingpath, <span class="type">int</span> nfd, <span class="type">const</span> <span class="type">char</span> *newpath, <span class="type">int</span> flag)</span>;</span><br><span class="line"><span class="comment">/* 两个函数的返回值：若成功，返回0；若出错，返回-1 */</span></span><br></pre></td></tr></table></figure>

<p>这两个函数创建一个新目录项<code>newpath</code>，它引用现有文件<code>existingpath</code>。如果<code>newpath</code>已存在，则返回出错。<br>对于<code>linkat</code>函数，现有文件是通过<code>efd</code>和<code>existingpath</code>指定，新的路径名是通过<code>nfd</code>和<code>newpath</code>指定的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">unlinkat</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flag)</span>;</span><br><span class="line"><span class="comment">/* 两个函数的返回值：若成功，返回0；若出错，返回-1 */</span></span><br></pre></td></tr></table></figure>

<p>这两个函数删除目录项，并将由<code>pathname</code>所引用的链接数减1。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">remove</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回0；若失败，返回-1 */</span></span><br></pre></td></tr></table></figure>

<h1 id="函数rename和renameat"><a href="#函数rename和renameat" class="headerlink" title="函数rename和renameat"></a>函数<code>rename</code>和<code>renameat</code></h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">rename</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *oldname, <span class="type">const</span> <span class="type">char</span> *newname)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">renameat</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">const</span> <span class="type">char</span> *oldname, <span class="type">int</span> newfd, <span class="type">const</span> <span class="type">char</span> *newname)</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li>如果<code>oldname</code>指的是一个文件而不是目录，那么为该文件或符号连接重命名。</li>
<li>如果<code>oldname</code>指的是一个空目录，那么为该目录重命名。</li>
<li>如果<code>oldname</code>或<code>newname</code>引用符号连接，则处理的是符号链接本身，而不是它引用的文件。</li>
<li>不能对<code>.</code>和<code>..</code>重命名。</li>
<li>作为一个特例，如果<code>oldname</code>和<code>newname</code>引用同意文件，则函数不做任何更改而成功返回。</li>
</ol>
<h1 id="符号链接"><a href="#符号链接" class="headerlink" title="符号链接"></a>符号链接</h1><p>符号链接是对一个文件的间接指针。符号链接以及它指向何种对象并无任何文件系统限制，任何用户都可以创建指向目录的符号连接。</p>
<h1 id="创建和读取符号连接"><a href="#创建和读取符号连接" class="headerlink" title="创建和读取符号连接"></a>创建和读取符号连接</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">symlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *actualpath, <span class="type">const</span> <span class="type">char</span> *sympath)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">symlinat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *acutalpath, <span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *symptah)</span>;</span><br><span class="line"><span class="comment">/* 两个函数的返回值：若成功，返回0；若出错，返回-1 */</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">readlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *actualpath, <span class="type">const</span> <span class="type">char</span> *symptah)</span>;</span><br><span class="line"><span class="type">sszie_t</span> <span class="title function_">readlinkat</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span>* <span class="keyword">restrict</span> pathname, <span class="type">char</span> *<span class="keyword">restrict</span> buf, <span class="type">size_t</span> bufsize)</span>;</span><br><span class="line"><span class="comment">/* 两个函数的返回值：若成功，返回读取的字节数；若出错，返回-1 */</span></span><br></pre></td></tr></table></figure>

<h1 id="文件时间"><a href="#文件时间" class="headerlink" title="文件时间"></a>文件时间</h1><table>
<thead>
<tr>
<th>字段</th>
<th align="left">说明</th>
<th align="left">例子</th>
<th align="left">ls(1)选项</th>
</tr>
</thead>
<tbody><tr>
<td><code>st_atim</code></td>
<td align="left">文件数据的最后访问时间</td>
<td align="left"><code>read</code></td>
<td align="left"><code>-u</code></td>
</tr>
<tr>
<td><code>st_mtim</code></td>
<td align="left">文件数据的最后修改时间</td>
<td align="left"><code>write</code></td>
<td align="left"><code>默认</code></td>
</tr>
<tr>
<td><code>st_ctim</code></td>
<td align="left">i节点状态的最后更改时间</td>
<td align="left"><code>chomd、chown</code></td>
<td align="left"><code>-c</code></td>
</tr>
</tbody></table>
<h1 id="函数futimens、utimensat和utimes"><a href="#函数futimens、utimensat和utimes" class="headerlink" title="函数futimens、utimensat和utimes"></a>函数<code>futimens</code>、<code>utimensat</code>和<code>utimes</code></h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">futimens</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> timespec times[<span class="number">2</span>])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">utimensat</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="keyword">struct</span> timespec times[<span class="number">2</span>], <span class="type">int</span> flag)</span>;</span><br><span class="line"><span class="comment">/* 两个函数返回值：若成功，返回0；若出错，返回-1 */</span></span><br></pre></td></tr></table></figure>

<h1 id="函数mkdir、mkdirat和rmdir"><a href="#函数mkdir、mkdirat和rmdir" class="headerlink" title="函数mkdir、mkdirat和rmdir"></a>函数<code>mkdir</code>、<code>mkdirat</code>和<code>rmdir</code></h1><p>两个函数创建一个新目录。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mkdir</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line"><span class="comment">/* 两个函数返回值：若成功，返回0；若出错，返回-1 */</span></span><br></pre></td></tr></table></figure>

<p>用<code>rmdir</code>函数可以创建一个空目录。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">rmdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回0；若失败，返回-1 */</span></span><br></pre></td></tr></table></figure>


<h1 id="读目录"><a href="#读目录" class="headerlink" title="读目录"></a>读目录</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">DIR *<span class="title function_">opendir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br><span class="line">DIR *<span class="title function_">fdopendir</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="comment">/* 两个函数返回值：若成功，返回指针；若出错，返回NULL */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> dirent *<span class="title function_">readdir</span><span class="params">(DIR *dp)</span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回指针；若在目录尾或出错，返回NULL */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rewinddir</span><span class="params">(DIR *dp)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">closeddir</span><span class="params">(DIR *dp)</span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回0；若失败，返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">telldir</span><span class="params">(DIR *dp)</span>;</span><br><span class="line"><span class="comment">/* 返回值：与dp关联的相关位置 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">seekdir</span><span class="params">(DIR *dp, <span class="type">long</span> loc)</span>;</span><br></pre></td></tr></table></figure>

<h1 id="函数chdir、fchdir和getcwd"><a href="#函数chdir、fchdir和getcwd" class="headerlink" title="函数chdir、fchdir和getcwd"></a>函数<code>chdir</code>、<code>fchdir</code>和<code>getcwd</code></h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">chdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fchdir</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>进程调用<code>chdir</code>和<code>fchdir</code>函数更改当前工作目录。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">getcwd</span><span class="params">(<span class="type">char</span> *buf, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure>
<p>逐层上移，直到遇到根，得到当前工作目录完整的绝对路径。<br>必须像此函数传递两个函数，一个是缓冲区地址<code>buf</code>(要有足够的长度容纳绝对路径再加上一个终止<code>null</code>字节)，另一个是缓冲区的长度<code>size</code>(以字节为单位)。</p>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>APUE</tag>
      </tags>
  </entry>
  <entry>
    <title>APUE学习笔记——文件IO</title>
    <url>//2016/02/25/APUE_study_notes-Files_IO/</url>
    <content><![CDATA[<h1 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h1><p>所有打开的文件都通过文件描述符(一个非负整数)引用。</p>
<p>维基百科上对于文件描述符的解释是这样的：</p>
<blockquote>
<p>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。</p>
</blockquote>
<p>当读、写一个文件时，使用<code>open</code>或<code>creat</code>返回的文件描述符标识该文件，将其作为参数传给<code>read</code>或<code>write</code>。</p>
<p>在POSIX.1的应用程序中，文件描述符0与进程的标准输入关联(STDIN_FILENO)、文件描述符1与进程的标准输出关联(STDOUT_FILENO)、文件描述符2与进程的标准错误关联(STDERR_FILENO)，且已经确定化。<br>文件描述符的变化范围是<code>0~OPEN_MAX-1</code>。</p>
<h1 id="函数open和openat"><a href="#函数open和openat" class="headerlink" title="函数open和openat"></a>函数<code>open</code>和<code>openat</code></h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">int</span> oflag, ... <span class="comment">/* mode_t mode */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">openat</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *path, <span class="type">int</span> oflag, ... <span class="comment">/* mode_t mode */</span>)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *path ：文件的名称，可以包含（绝对和相对）路径</span></span><br><span class="line"><span class="comment"> *flags：文件打开模式</span></span><br><span class="line"><span class="comment"> *mode：用来规定对该文件的所有者，文件的用户组及系 统中其他用户的访问权限</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* 两函数的返回值： 若成功，返回文件描述符； 若出错，返回-1 */</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>打开方式</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>O_RDONLY</code></td>
<td align="left">只读打开.</td>
</tr>
<tr>
<td><code>O_WRONLY</code></td>
<td align="left">只写打开.</td>
</tr>
<tr>
<td><code>O_RDWR</code></td>
<td align="left">读、写打开.</td>
</tr>
<tr>
<td><code>O_EXEC</code></td>
<td align="left">只执行打开.</td>
</tr>
<tr>
<td><code>O_SEARCH</code></td>
<td align="left">只搜索打开 (应用于目录).</td>
</tr>
<tr>
<td><code>O_APPEND</code></td>
<td align="left">每次写时都追加到文件的尾端.</td>
</tr>
<tr>
<td><code>O_CLOEXEC</code></td>
<td align="left">设置<code>FD_CLOEXEC</code>文件描述符.</td>
</tr>
<tr>
<td><code>O_CREAT</code></td>
<td align="left">若此文件不存在则创建它.</td>
</tr>
<tr>
<td><code>O_DIRECTORY</code></td>
<td align="left">如果<code>path</code>引用的不是目录，则出错.</td>
</tr>
<tr>
<td><code>O_EXCL</code></td>
<td align="left">如果同时指定了<code>O_CREAT</code>，而文件已存在，则出错.</td>
</tr>
<tr>
<td><code>O_NOCTTY</code></td>
<td align="left">如果<code>path</code>引用的是终端设备，则不将该设备分配作为此进程的控制终端.</td>
</tr>
<tr>
<td><code>O_NOFOLLOW</code></td>
<td align="left">如果<code>path</code>引用的是一个符号连接，则出错.</td>
</tr>
<tr>
<td><code>O_NONBLOCK</code></td>
<td align="left">如果<code>path</code>引用的是一个<code>FIFO</code>、一个块特殊文件或一个自负特殊文件，则此选项为文件的本次打开操作和后续的I&#x2F;O操作设置非阻塞方式.</td>
</tr>
<tr>
<td><code>O_SYNC</code></td>
<td align="left">使每次<code>write</code>等待物理I&#x2F;O完成，包括由该<code>write</code>操作引起的文件属性更新所需的I&#x2F;O.</td>
</tr>
<tr>
<td><code>O_TRUNC</code></td>
<td align="left">如果此文件存在，而且为只写或读-写成功打开，则将其长度截断为0.</td>
</tr>
<tr>
<td><code>O_TTY_INIT</code></td>
<td align="left">如果打开一个还未打开的终端设备，设置非标准<code>termios</code>参数值，使其符合<code>Single UNIX Specification</code>.</td>
</tr>
<tr>
<td><code>O_DSYNC</code></td>
<td align="left">使每次<code>write</code>要等待物理I&#x2F;O完成，但是如果该写操作并不影响读取刚写入的数据，则不需等待文件属性被更新.</td>
</tr>
<tr>
<td><code>O_RSYNC</code></td>
<td align="left">使每一个一文件描述符作为参数进行的<code>read</code>操作等待，直至所有对文件同一部份挂起的写操作都完成.</td>
</tr>
</tbody></table>
<h3 id="fd参数吧open和openat函数区分开，共有3种可能性。"><a href="#fd参数吧open和openat函数区分开，共有3种可能性。" class="headerlink" title="fd参数吧open和openat函数区分开，共有3种可能性。"></a><code>fd</code>参数吧<code>open</code>和<code>openat</code>函数区分开，共有3种可能性。</h3><ol>
<li><code>path</code>参数指定的是绝对路径名，在这种情况下，<code>fd</code>参数被忽略，<code>openat</code>函数就相当于<code>open</code>函数。</li>
<li><code>path</code>参数指定的是相对路径名，<code>fd</code>参数指出了相对路径名在文件系统中的开始地址。<code>fd</code>参数是通过打开相对路径名所在的目录来获取。</li>
<li><code>path</code>参数指定了相对路径名，<code>fd</code>参数具有特殊值<code>AT_FDCWD</code>。在这种情况下，路径名在当前工作目录中获取，<code>openat</code>函数在操作上与<code>open</code>函数类似。</li>
</ol>
<h1 id="函数creat"><a href="#函数creat" class="headerlink" title="函数creat"></a>函数<code>creat</code></h1><h3 id="调用函数creat创建一个新的文件"><a href="#调用函数creat创建一个新的文件" class="headerlink" title="调用函数creat创建一个新的文件"></a>调用函数<code>creat</code>创建一个新的文件</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">creat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line"><span class="comment">/* 返回值： 若成功，返回为只写打开的文件描述符；如出错，返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>等效于：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">open(path, O_WRONLY|O_CREAT|O_TRUNC, mode);</span><br></pre></td></tr></table></figure>

<h1 id="函数close"><a href="#函数close" class="headerlink" title="函数close"></a>函数<code>close</code></h1><h3 id="调用close函数关闭一个打开文件"><a href="#调用close函数关闭一个打开文件" class="headerlink" title="调用close函数关闭一个打开文件"></a>调用<code>close</code>函数关闭一个打开文件</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回0；如出错，返回-1 */</span></span><br></pre></td></tr></table></figure>

<h1 id="函数lseek"><a href="#函数lseek" class="headerlink" title="函数lseek"></a>函数<code>lseek</code></h1><h3 id="当前文件偏移量-current-file-offset-：它通常是一个非负整数，用以度量从文件开始处计算的字节数。"><a href="#当前文件偏移量-current-file-offset-：它通常是一个非负整数，用以度量从文件开始处计算的字节数。" class="headerlink" title="当前文件偏移量(current file offset)：它通常是一个非负整数，用以度量从文件开始处计算的字节数。"></a>当前文件偏移量(current file offset)：它通常是一个非负整数，用以度量从文件开始处计算的字节数。</h3><h3 id="调用lseek显式的为一个打开文件设置偏移量。"><a href="#调用lseek显式的为一个打开文件设置偏移量。" class="headerlink" title="调用lseek显式的为一个打开文件设置偏移量。"></a>调用<code>lseek</code>显式的为一个打开文件设置偏移量。</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br><span class="line"><span class="comment">/* 返回值：若辰宫，返回新的文件偏移量；若出错，返回-1 */</span></span><br></pre></td></tr></table></figure>

<p>对参数<code>offset</code>的解释与参数<code>whence</code>的值有关。</p>
<ul>
<li>若<code>whence</code>是<code>SEEK_SET</code>，则经该文件的偏移量设置为距文件开始处<code>offset</code>个字节。</li>
<li>若<code>whence</code>是<code>SEEK_CUR</code>，则经该文件的偏移量设置为其当前量增加<code>offset</code>，<code>offset</code>可为正或负。</li>
<li>若<code>whence</code>是<code>SEEK_END</code>，则经该文件的偏移量设置为文件长度加<code>offset</code>，<code>offset</code>可正可负。</li>
</ul>
<h1 id="函数read"><a href="#函数read" class="headerlink" title="函数read"></a>函数<code>read</code></h1><h3 id="调用read函数从打开文件中读数据。"><a href="#调用read函数从打开文件中读数据。" class="headerlink" title="调用read函数从打开文件中读数据。"></a>调用<code>read</code>函数从打开文件中读数据。</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> nbytes)</span>;</span><br><span class="line"><span class="comment">/* 返回值：读到的字节数，若已到文件尾，返回0；若出错，返回-1 */</span></span><br></pre></td></tr></table></figure>

<p>有多种情况可使实际读到的字节数少于要求读的字节数：</p>
<ul>
<li>读到普通文件时，在读到要求字计数之前已到达了文件微端。</li>
<li>当从终端设备读时，通常一次最多读一行。</li>
<li>当从网络读时，网络中的缓冲机制可能造成返回值小于所要求的字节数。</li>
<li>当从管道或<code>FIFO</code>读时，如若管道包含的字节少于所需的数量，那么<code>read</code>将只返回实际可用的字节数。</li>
<li>当从某些面向记录的设备读时，一次最多返回一个记录。</li>
<li>当一信号造成中断，而已经读到部分数据量时。</li>
</ul>
<h1 id="函数write"><a href="#函数write" class="headerlink" title="函数write"></a>函数<code>write</code></h1><h3 id="调用write函数向打开文件写数据。"><a href="#调用write函数向打开文件写数据。" class="headerlink" title="调用write函数向打开文件写数据。"></a>调用<code>write</code>函数向打开文件写数据。</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> nbytes)</span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回已写的字节数；若出错，返回-1 */</span></span><br></pre></td></tr></table></figure>

<h2 id="函数pread和pwrite"><a href="#函数pread和pwrite" class="headerlink" title="函数pread和pwrite"></a>函数<code>pread</code>和<code>pwrite</code></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">pread</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> nbytes. <span class="type">off_t</span> offset)</span>;</span><br><span class="line"><span class="comment">/* 返回值：读到的字节数，若已到文件尾，返回0；若出错，返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">pwrite</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> nbytes, <span class="type">off_t</span> offset)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>调用<code>pread</code>相当于调用<code>lseek</code>后调用<code>read</code>，但是<code>pread</code>又与这种顺序调用有下列重要区别。</p>
<ul>
<li>调用<code>pread</code>时，无法中断其定位和都读操作。</li>
<li>不更新当前文件偏移量。<br>调用<code>pwrite</code>相当于调用<code>lseek</code>后调用<code>write</code>，但也与它们有类似的区别。</li>
</ul>
<blockquote>
<p>原子操作(atomic operation)；指的是由多步组成一个一个操作。如果该操作原子地执行，则要么执行所有步骤，要么一步也不执行，不可能只执行所有步骤的一个子集。</p>
</blockquote>
<h1 id="函数dup和dup2"><a href="#函数dup和dup2" class="headerlink" title="函数dup和dup2"></a>函数<code>dup</code>和<code>dup2</code></h1><h3 id="复制一个现有的文件描述符"><a href="#复制一个现有的文件描述符" class="headerlink" title="复制一个现有的文件描述符"></a>复制一个现有的文件描述符</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> fd2)</span>;</span><br><span class="line"><span class="comment">/* 两函数的返回值：若成功，返回新的文件描述符；如出错，返回-1 */</span></span><br></pre></td></tr></table></figure>

<h1 id="函数sync、fsync和fdatasync"><a href="#函数sync、fsync和fdatasync" class="headerlink" title="函数sync、fsync和fdatasync"></a>函数<code>sync</code>、<code>fsync</code>和<code>fdatasync</code></h1><blockquote>
<p>内核通常先将数据复制到缓冲区中，然后排入队列，晚些时候写入磁盘。这种方法被称为<code>延迟写(delayed write)</code>.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unitstd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fsync</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fdatasync</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回0；若出错，返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sync</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p><code>sync</code>只是将所有修改过的块缓冲区排入写队列，然后就返回，它并不等待实际写磁盘操作结束。<br><code>fsync</code>函数只对由文件描述符<code>fd</code>指定的一个文件起作用，并且等待写磁盘操作结束才返回。<br><code>fdatasync</code>函数类似于<code>fsync</code>，但它只影响文件的数据部分。</p>
<h1 id="函数fcntl"><a href="#函数fcntl" class="headerlink" title="函数fcntl"></a>函数<code>fcntl</code></h1><h3 id="改变已经打开文件的属性。"><a href="#改变已经打开文件的属性。" class="headerlink" title="改变已经打开文件的属性。"></a>改变已经打开文件的属性。</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, ... <span class="comment">/* int arg */</span>)</span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，则依赖cmd，若出错，返回-1 */</span></span><br></pre></td></tr></table></figure>

<h4 id="fcntl函数有以下5种功能。"><a href="#fcntl函数有以下5种功能。" class="headerlink" title="fcntl函数有以下5种功能。"></a><code>fcntl</code>函数有以下5种功能。</h4><ol>
<li>复制一个已有的描述符 (<code>cmd=F_DUPFD</code>或<code>F_DUPFD_CLOEXEC</code>)。</li>
<li>获取&#x2F;设置文件描述符标志 (<code>cmd=F_GETFD</code>或<code>F_SETFD</code>)。</li>
<li>获取&#x2F;设置文件状态标志 (<code>cmd=F_GETFL</code>或<code>F_SETFL</code>)。</li>
<li>获取&#x2F;设置异步I&#x2F;O所有权 (<code>cmd=F_GETOWN</code>或<code>F_SETOWN</code>)。</li>
<li>获取&#x2F;设置记录锁 (<code>cmd=F_GETLK</code>或<code>F_SETLKW</code>)。</li>
</ol>
<p>|cmd|功能<br>|<br>|——|:—————————————————-|<br>|<code>F_DUPFD</code>|复制文件描述符<code>fd</code>。|<br>|<code>F_DUPFD_CLOEXEC</code>|复制文件描述符，设置与新描述符关联的<code>FD_CLOEXEC</code>文件描述符标志的值，返回新文件描述符。|<br>|<code>F_GETFD</code>|对应于<code>fd</code>的文件描述符标志作为函数值返回。|<br>|<code>F_SETFD</code>|对于<code>fd</code>设置文件描述符标志。|<br>|<code>F_GETFL</code>|对应于<code>fd</code>的文件状态标志作为函数值返回。|<br>|<code>F_SETFL</code>|将文件状态标志设置为第3个参数的值。可以更改的几个标志是：<code>O_APPEND</code>、<code>O_NONBLOCK</code>、<code>O_SYNC</code>、<code>O_DSYNC</code>、<code>O_RSYNC</code>、<code>O_FSYNC</code>、和<code>O_ASYNC</code>。|<br>|<code>F_GETOWN</code>|获取当前接收<code>SIGIO</code>和<code>SIGURG</code>信号进程ID或进程组ID。|<br>|<code>F_SETOWN</code>|设置接收<code>SIGIO</code>和<code>SIGURG</code>信号的进程ID或进程组ID。|</p>
<h1 id="函数ioctl"><a href="#函数ioctl" class="headerlink" title="函数ioctl"></a>函数<code>ioctl</code></h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> <span class="comment">/* System V */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span>  <span class="comment">/* BSD and Linux */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ioctl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> request, ...)</span>;</span><br><span class="line"><span class="comment">/* 返回值：若出错，返回-1；若成功，返回其他值 */</span></span><br></pre></td></tr></table></figure>

<h2 id="dev-fd"><a href="#dev-fd" class="headerlink" title="/dev/fd"></a><code>/dev/fd</code></h2><p>较新的系统都提供名为<code>/dev/fd</code>的目录，其目录项是名为0、1、2等的文件。打开文件<code>/dev/fdn</code>等效于复制描述符n(假设描述符n是打开的).</p>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>APUE</tag>
      </tags>
  </entry>
  <entry>
    <title>APUE学习笔记——进程控制</title>
    <url>//2016/04/27/APUE_study_notes-process-control/</url>
    <content><![CDATA[<h1 id="进程标识"><a href="#进程标识" class="headerlink" title="进程标识"></a>进程标识</h1><p>每个进程都有一个非负整型表示的唯一进程ID。</p>
<ul>
<li>ID为0的进程通常是调度进程，常常被称为<code>交换进程(swapper)</code>。该进程是内核的一部分，它并不执行任何磁盘上的程序，因此被称为系统进程。</li>
<li>进程ID为1的通常是<code>init</code>进程，在自举过程结束时由内核调用。<code>init</code>进程决不会终止。它是一个普通的用户进程，但它以超级用户特权运行。</li>
<li>进程ID2是<code>页守护进程(page daemon)</code>，此进程负责支持虚拟存储器系统的分页操作。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpid</span><span class="params">(<span class="type">void</span>)</span>;     <span class="comment">/* 返回值：调用进程的进程ID */</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getppid</span><span class="params">(<span class="type">void</span>)</span>;    <span class="comment">/* 返回值：调用进程的父进程ID */</span></span><br><span class="line"><span class="type">uid_t</span> <span class="title function_">getuid</span><span class="params">(<span class="type">void</span>)</span>;     <span class="comment">/* 返回值：调用进程的实际用户ID */</span></span><br><span class="line"><span class="type">uid_t</span> <span class="title function_">geteuid</span><span class="params">(<span class="type">void</span>)</span>;    <span class="comment">/* 返回值：调用进程的有效用户ID */</span></span><br><span class="line"><span class="type">gid_t</span> <span class="title function_">getgid</span><span class="params">(<span class="type">void</span>)</span>;     <span class="comment">/* 返回值：调用进程的实际组ID */</span></span><br><span class="line"><span class="type">gid_t</span> <span class="title function_">getegid</span><span class="params">(<span class="type">void</span>)</span>;    <span class="comment">/* 返回值：调用进程的有效组ID */</span> </span><br></pre></td></tr></table></figure>

<h1 id="函数fork"><a href="#函数fork" class="headerlink" title="函数fork"></a>函数<code>fork</code></h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">/* 返回值：子进程返回0，父进程返回子进程ID；若出错，返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>由<code>fork</code>创建的新进程被称为<code>子进程(child process)</code>。<br>两次返回的区别是子进程的返回值是0，而父进程的返回值则是新建子进程的进程ID。<br>子进程和父进程继续执行<code>fork</code>调用之后的指令。子进程是父进程的副本。父进程和子进程共享正文段。<br>一般来说，<code>fork</code>之后是父进程先执行还是子进程先执行是不确定的。<br>在重定向父进程的标准输出时，子进程的标准输出也被重定向。<br>子进程和父进程共享一个文件偏移量。</p>
<h1 id="函数vfork"><a href="#函数vfork" class="headerlink" title="函数vfork"></a>函数<code>vfork</code></h1><p>父进程和子进程共享数据段，并且先保诚子进程先运行，只有当子进程调用<code>exec</code>或<code>exit</code>后父进程才可能被调用运行。<br><em>调用vfork()后，子程序要么_exit(),要么调用exec()，否则都是未定义行为(UB)</em></p>
<h1 id="函数exit"><a href="#函数exit" class="headerlink" title="函数exit"></a>函数<code>exit</code></h1><p>5种正常终止方式：</p>
<ol>
<li>在<code>main</code>函数内执行<code>return</code>语句。</li>
<li>调用<code>exit</code>函数。</li>
<li>调用<code>_exit</code>或<code>_Exit</code>函数。</li>
<li>进程的最后一个线程在其启动例程中执行<code>return</code>语句。</li>
<li>进程的最后一个线程调用<code>pthread_exit</code>函数。</li>
</ol>
<p>3种异常终止：</p>
<ol>
<li>调用<code>abort</code>。</li>
<li>当进程接收到某些信号时。</li>
<li>最后一个线程对“取消”(cancellation)请求作出响应。</li>
</ol>
<p>对于父进程已经终止的所有进程，它们的父进程都改为<code>init</code>进程，我们称为这些进程由<code>init</code>进程收养。</p>
<p>在UNIX术语中，一个已经终止、但是其父进程尚未对其进行善后处理(获取终止子进程的有关信息、释放它仍占用的资源)的进程被称为<code>僵死进程(zombie)</code>。</p>
<h1 id="函数wait和waitpid"><a href="#函数wait和waitpid" class="headerlink" title="函数wait和waitpid"></a>函数<code>wait</code>和<code>waitpid</code></h1><p>当一个进程正常或异常终止时，内核就向其父进程发送<code>SIGCHLD</code>信号。</p>
<ul>
<li><p>如果其所有子进程都还在运行，则阻塞。</p>
</li>
<li><p>如果一个子进程终止，正等待父进程获取其终止状态，则取得该子进程的终止状态立即返回。</p>
</li>
<li><p>如果没有任何子进程，则立即出错返回。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *statloc)</span>;</span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *statloc, <span class="type">int</span> options)</span>;</span><br><span class="line"><span class="comment">/* 两个函数返回值：若成功，返回进程ID；若出错，返回0或-1 */</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在一个子进程终止前，<code>wait</code>使其调用者阻塞，而<code>waitpid</code>有一选项，可使调用者不阻塞。</p>
</li>
<li><p><code>waitpid</code>并不等待在其调用之后的第一个终止子进程，可以控制它所等待的进程。</p>
</li>
</ul>
<p>这两个函数的参数<code>statloc</code>是一个整型指针。如果<code>statloc</code>不是一个空指针，则终止进程的终止状态就存放在它所指向的单元内。</p>
<table>
<thead>
<tr>
<th align="center">宏</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">WIFEXITED(status)</td>
<td align="center">若为正常正常终止子进程返回的状态，则为真。对于这种情况可执行WIFEXITED(status)，获取子进程传送给exit或_exit参数的低8位</td>
</tr>
<tr>
<td align="center">WIFSIGNALED(status)</td>
<td align="center">若为异常终止子进程返回的状态，则为真(接到一个不捕捉的信号)。对于这种情况，可执行WIFSIGNALED(status)，则为真(接到一个不捕捉的信号)。对于这种情况，可执行()WTERMSIG(status),获取使子进程终止的信号编号。另外，有些实现(非Single UNIX Specification)定义宏WCOREDUMP(status),若已产生终止进程core文件，则它返回真</td>
</tr>
<tr>
<td align="center">WIFSTOPPED(status)</td>
<td align="center">若为当前暂停子进程的返回的状态，则为真。对于这种情况，可执行WSTOPSIG(status),获取使子进程暂停的信号编号</td>
</tr>
<tr>
<td align="center">WIFCONTINUED(status)</td>
<td align="center">若在作业控制暂停后已经继续的子进程返回了状态，则为真</td>
</tr>
</tbody></table>
<p><code>waitpid</code>函数中pid参数的作用解释如下：</p>
<ul>
<li>pid &#x3D;&#x3D; -1 等待任一子进程。此种情况下，<code>wait</code>和<code>waitpid</code>等效。</li>
<li>pid &gt; 0   等待进程ID与pid相等的子进程。</li>
<li>pid &#x3D;&#x3D; 0  等待组ID等于调用进程组ID的任一子进程。</li>
<li>pid &lt; -1  等待组ID等于pid绝对值的任一子进程。</li>
</ul>
<table>
<thead>
<tr>
<th align="center">options常量</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">WCONTINUED</td>
<td align="center">若实现支持罪业控制，那么由pid制定的任一子进程在停止后已经继续，但其状态尚未报告，则返回其状态</td>
</tr>
<tr>
<td align="center">WNOHANG</td>
<td align="center">若由pid指定的子进程并不是立即可用的，则waitpid不阻塞，此时其返回值为0</td>
</tr>
<tr>
<td align="center">WUNTRACED</td>
<td align="center">若某实现支持作业控制，而由pid指定的任一子进程已处于停止状态，并且其状态由停止以来还没报告过，则返回其状态。WIFSTOPPED宏确定返回值是否对应于一个停止的子进程。</td>
</tr>
</tbody></table>
<h1 id="函数waittid"><a href="#函数waittid" class="headerlink" title="函数waittid"></a>函数<code>waittid</code></h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">waittid</span><span class="params">(<span class="type">idtype_t</span> idtype, <span class="type">id_t</span> id, <span class="type">siginfo_t</span> *infop, <span class="type">int</span> options)</span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回0；若出错，返回-1 */</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">idtype常量</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">P_PID</td>
<td align="center">等待一特定进程：id包含要等待子进程的进程ID</td>
</tr>
<tr>
<td align="center">P_PGID</td>
<td align="center">等待一特定进程组中的任一子进程：id包含要等待子进程的进程组ID</td>
</tr>
<tr>
<td align="center">P_ALL</td>
<td align="center">等待任一子进程：忽略id</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">options常量</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">WCONTINUED</td>
<td align="center">等待一进程，它以前曾被停止，此后又已继续，但其状态尚未报告</td>
</tr>
<tr>
<td align="center">WEXITED</td>
<td align="center">等待已退出的进程</td>
</tr>
<tr>
<td align="center">WNOHANG</td>
<td align="center">如无可用的子进程推出状态，立即返回而非阻塞</td>
</tr>
<tr>
<td align="center">WNOWAIT</td>
<td align="center">不破坏子进程退出状态。该子进程退出状态可由后续的wait、waitid或waitpid调用取得</td>
</tr>
<tr>
<td align="center">WSTOPPED</td>
<td align="center">等待一进程，它已经停止，但其状态尚未报告</td>
</tr>
</tbody></table>
<h1 id="函数wait3和wait4"><a href="#函数wait3和wait4" class="headerlink" title="函数wait3和wait4"></a>函数<code>wait3</code>和<code>wait4</code></h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait3</span><span class="params">(<span class="type">int</span> *statloc, <span class="type">int</span> options, <span class="keyword">struct</span> rusage *rusage)</span>;</span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait4</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *statloc, <span class="type">int</span> options, <span class="keyword">struct</span> rusage *rusage)</span>;</span><br><span class="line"><span class="comment">/* 两个函数返回值：若成功，返回进程ID；若出错，返回-1 */</span></span><br></pre></td></tr></table></figure>

<h1 id="函数exec"><a href="#函数exec" class="headerlink" title="函数exec"></a>函数<code>exec</code></h1><p>调用<code>exec</code>并不创建新进程，所以前后的进程ID并没有改变。<code>exec</code>只是用磁盘上的一个新程序替换了当前进程的正文段、数据段、堆栈和栈段。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="type">char</span> *arg0, ... <span class="comment">/* (char *)0 */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="type">char</span> *arg0, ...</span></span><br><span class="line"><span class="params">    <span class="comment">/* (char *)0, char *const envp[] */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *arg0, ... <span class="comment">/* (char *)0 */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fexecve</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br><span class="line"><span class="comment">/* 7个函数返回值：若出错，返回-1；若成功，不返回 */</span></span><br></pre></td></tr></table></figure>

<p>当<code>filename</code>作为参数时：</p>
<ul>
<li>如果<code>filename</code>中包含<code>/</code>，则将其设为路径名；</li>
<li>否则就按<code>PATH</code>环境变量，在她所指定的各目录搜寻可执行文件。</li>
</ul>
<p>execl,execle,execlp(结尾带l)要在可变参数结尾添加<code>(char *)0</code>。<br>execlp,execvp(结尾带p)表示第一个参数path不用输入完整路径，只有给出命令名即可，它会在环境变量PATH当中查找命令。<br>execv,execvp(不带l)表示命令所需的参数以char *arg[]形式给出且arg最后一个元素必须是NULL。</p>
<h1 id="更改用户ID和更改组ID"><a href="#更改用户ID和更改组ID" class="headerlink" title="更改用户ID和更改组ID"></a>更改用户ID和更改组ID</h1><p>可以用<code>setuid</code>函数设置实际用户ID和有效用户ID；可以用<code>setgid</code>函数设置实际组ID和有效组ID。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setuid</span><span class="params">(<span class="type">uid_t</span> uid)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setgit</span><span class="params">(<span class="type">gid_t</span> gid)</span>;</span><br><span class="line"><span class="comment">/* 两个函数返回值：若成功，返回0；若出错，返回-1 */</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>若进程拥有超级用户权限，则setuid函数将实际用户ID、有效用户ID以及保存的设置用户ID设置为uid；</p>
</li>
<li><p>若进程没有超级用户权限，但是uid等于实际用户ID或保存的设置用户ID，则<code>setuid</code>只将有效用户ID设置为uid。不更改实际用户ID和保存的设置用户ID；</p>
</li>
<li><p>若以上两个条件都不满足，则<code>errno</code>设置为<code>EPERM</code>，并返回-1.</p>
</li>
<li><p>只有超级用户进程可以更改实际用户ID；</p>
</li>
<li><p>仅当对程序文件设置了设置用户ID位时，<code>exec</code>函数才设置有效用户ID；</p>
</li>
<li><p>保存的设置用户ID是由<code>ecec</code>复制有效用户ID而得到的。</p>
</li>
</ol>
<h2 id="函数setreuid和setregid"><a href="#函数setreuid和setregid" class="headerlink" title="函数setreuid和setregid"></a>函数<code>setreuid</code>和<code>setregid</code></h2><p>功能是交换实际用户ID和有效用户ID</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setreuid</span><span class="params">(<span class="type">uid_t</span> ruid, <span class="type">uid_t</span> euid)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setregid</span><span class="params">(<span class="type">gid_t</span> rgid, <span class="type">gid_t</span> egid)</span>;</span><br><span class="line"><span class="comment">/* 两个函数的返回值：若成功，返回0；若出错，返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>如若其中任一参数的值为-1，则表示相应的ID应当保持不变。</p>
<h2 id="函数seteuid和setegid"><a href="#函数seteuid和setegid" class="headerlink" title="函数seteuid和setegid"></a>函数<code>seteuid</code>和<code>setegid</code></h2><p>类似于<code>setuid</code>和<code>setgid</code>，但只更改有效用户ID和有效组ＩＤ。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">seteuid</span><span class="params">(<span class="type">uid_t</span> uid)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setegid</span><span class="params">(<span class="type">uid_t</span> gid)</span>;</span><br><span class="line"><span class="comment">/* 两个函数的返回值：若成功，返回0；若出错，返回-1 */</span></span><br></pre></td></tr></table></figure>

<h1 id="函数system"><a href="#函数system" class="headerlink" title="函数system"></a>函数<code>system</code></h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">system</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cmdstring)</span>;</span><br></pre></td></tr></table></figure>
<p>如果<code>cmdstring</code>是一个空指针，则仅当命令程序可用时，<code>system</code>返回非0值，这一特征可以确定在一个给定的操作系统上是否支持<code>system</code>函数。</p>
<ol>
<li><code>fork</code>失败或者<code>waitpid</code>返回处<code>EINTR</code>之外的出错，则<code>system</code>返回-1，并且设置<code>errno</code>以指示错误类型。</li>
<li>如果<code>exec</code>失败，则返回值如同shell执行了<code>exit(127)</code>一样。</li>
<li>否则所有3个函数(<code>fork</code>、<code>exec</code>和<code>waitpid</code>)都成功，那么<code>system</code>的返回值是shell的终止状态，其格式已在<code>waitpid</code>中说明。</li>
</ol>
<h1 id="进程会计-process-accounting"><a href="#进程会计-process-accounting" class="headerlink" title="进程会计(process accounting)"></a>进程会计(process accounting)</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> u_short <span class="type">comp_t</span>; <span class="comment">/* 3-bit base 8 exponent; 13-bit fraction */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">acct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> ac_flag;   <span class="comment">/* flag (see Figure 8.26) */</span></span><br><span class="line">    <span class="type">char</span> ac_stat;   <span class="comment">/* termination status (signal &amp; core flag only) */</span></span><br><span class="line">                    <span class="comment">/* (Solaris only) */</span></span><br><span class="line">    <span class="type">uid_t</span> ac_uid;   <span class="comment">/* real user ID */</span></span><br><span class="line">    <span class="type">gid_t</span> ac_gid;   <span class="comment">/* real group ID */</span></span><br><span class="line">    <span class="type">dev_t</span> ac_tty;   <span class="comment">/* controlling terminal */</span></span><br><span class="line">    <span class="type">time_t</span> ac_btime; <span class="comment">/* starting calendar time */</span></span><br><span class="line">    <span class="type">comp_t</span> ac_utime; <span class="comment">/* user CPU time */</span></span><br><span class="line">    <span class="type">comp_t</span> ac_stime; <span class="comment">/* system CPU time */</span></span><br><span class="line">    <span class="type">comp_t</span> ac_etime; <span class="comment">/* elapsed time */</span></span><br><span class="line">    <span class="type">comp_t</span> ac_mem;  <span class="comment">/* average memory usage */</span></span><br><span class="line">    <span class="type">comp_t</span> ac_io;   <span class="comment">/* bytes transferred (by read and write) */</span></span><br><span class="line">                    <span class="comment">/* &quot;blocks&quot; on BSD systems */</span></span><br><span class="line">    <span class="type">comp_t</span> ac_rw;   <span class="comment">/* blocks read or written */</span></span><br><span class="line">                    <span class="comment">/* (not present on BSD systems) */</span></span><br><span class="line">    <span class="type">char</span> ac_comm[<span class="number">8</span>]; <span class="comment">/* command name: [8] for Solaris, */</span></span><br><span class="line">                     <span class="comment">/* [10] for Mac OS X, [16] for FreeBSD, and */</span></span><br><span class="line">                     <span class="comment">/* [17] for Linux */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol>
<li>我们不能获取永远不终止的进程的会计记录；</li>
<li>在会计文件记录的顺序对应于进程终止的顺序，而不是它们启动的顺序；</li>
<li>会计记录对应于进程而不是程序。<code>exec</code>并不创建一个新的会计记录，但相应记录中的命令名称改变了，<code>AFORK</code>标志被清除。</li>
</ol>
<h1 id="用户标识"><a href="#用户标识" class="headerlink" title="用户标识"></a>用户标识</h1><p>得到运行该程序的用户的登录名，当有多个用户名对应着一个用户ID时，通常返回用户登录时用的用户名。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">getlogin</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回指向登陆名字符串的指针；若出错，返回NULL */</span></span><br></pre></td></tr></table></figure>

<h1 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h1><p>进程可以通过调整<code>nice</code>值选择以最低优先级运行，只有特权进程允许提高调度权限。<br><code>nice</code>值的大小在0<del>(2*NZERO)-1之间，有些实现支持0</del>2<em>NZERO。</em>nice值越小，优先级越高*。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">nice</span><span class="params">(<span class="type">int</span> incr)</span>;</span><br><span class="line"><span class="comment">/*返回值：若成功，返回新的nice值NZERO；若出错，返回-18*/</span></span><br></pre></td></tr></table></figure>

<p><code>getpriority</code>函数可以像<code>nice</code>函数那样用户获取进程的<code>nice</code>值，但是<code>getpriority</code>还可以获取一组相关进程的<code>nice</code>值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getpriority</span><span class="params">(<span class="type">int</span> which, <span class="type">id_t</span> who)</span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回-NZERO~NZERO-1之间的nice值；若出错，返回-1 */</span></span><br></pre></td></tr></table></figure>

<p><code>setpriority</code>函数可以用于为进程、进程组和属于特定用户ID的所有进程设置优先级。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setpriority</span><span class="params">(<span class="type">int</span> which, <span class="type">id_t</span> who, <span class="type">int</span> value)</span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回0；若出错，返回-1 */</span></span><br></pre></td></tr></table></figure>

<h1 id="进程时间"><a href="#进程时间" class="headerlink" title="进程时间"></a>进程时间</h1><p><code>times</code>函数获得它自己以及已终止子进程的墙上时钟时间、用户CPU时间和系统CPU时间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/times.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">clock_t</span> <span class="title function_">times</span><span class="params">(<span class="keyword">struct</span> tms *buf)</span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回墙上时钟时间(以时钟滴答数为单位)；若出错，返回-1 */</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tms</span> &#123;</span></span><br><span class="line">    <span class="type">clock_t</span> tms_utime;  <span class="comment">/* 用户CPU时间 */</span></span><br><span class="line">    <span class="type">clock_t</span> tms_stime;  <span class="comment">/* 系统CPU时间 */</span></span><br><span class="line">    <span class="type">clock_t</span> tms_cutime; <span class="comment">/* 子进程的用户CPU时间 */</span></span><br><span class="line">    <span class="type">clock_t</span> tms_cstiem; <span class="comment">/* 子进程的系统CPU时间 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>















]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>APUE</tag>
      </tags>
  </entry>
  <entry>
    <title>APUE学习笔记——进程环境</title>
    <url>//2016/04/07/APUE_study_notes-process-environment/</url>
    <content><![CDATA[<h1 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h1><ol>
<li><p>退出函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span>;</span><br><span class="line"><span class="type">void</span> _Exit(<span class="type">int</span> status);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _exit(<span class="type">int</span> status);</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数<code>atexit</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">atexit</span><span class="params">(<span class="type">void</span> (*func)(<span class="type">void</span>))</span>;</span><br></pre></td></tr></table></figure>
<p>其中，<code>atexit</code>的参数是一个函数地址，当调用此函数时无需向它传递任何参数，也不期望它返回一个值。<code>exit</code>调用这些函数的顺序与它们等级时候的顺序相反。同一函数如若登记多次也会被调用多次。</p>
</li>
</ol>
<h1 id="环境表"><a href="#环境表" class="headerlink" title="环境表"></a>环境表</h1><p>环境表也是一个字符指针数组，其中每个指针包含一个以<code>null</code>结束的C字符串的地址。全局变量<code>environ</code>则包含了该指针的数组的地址：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ;</span><br></pre></td></tr></table></figure>
<p>我们称<code>environ</code>为<code>环境指针(environment pointer)</code>，指针数组为环境表，其中各指针指向的字符串为环境字符串。<br>通常用<code>getenv</code>和<code>putenv</code>函数来访问特定的环境变量，而不是<code>environ</code>变量。</p>
<h1 id="C程序的存储空间布局"><a href="#C程序的存储空间布局" class="headerlink" title="C程序的存储空间布局"></a>C程序的存储空间布局</h1><ul>
<li>正文段。</li>
<li>初始化数据段。</li>
<li>未初始化数据段。</li>
<li>栈。</li>
<li>堆。</li>
</ul>
<h1 id="存储空间分配"><a href="#存储空间分配" class="headerlink" title="存储空间分配"></a>存储空间分配</h1><ol>
<li><code>malloc</code>，分配指定字节的存储区。此存储区中的初始值不确定。</li>
<li><code>calloc</code>,为指定数量指定长度的对象分配存储空间。该空间中的每一位(bit)都初始化为0。</li>
<li><code>realloc</code>,增加或减少以前分配区的长度。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">calloc</span><span class="params">(<span class="type">size_t</span> nobj, <span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">realloc</span><span class="params">(<span class="type">size_t</span> nobj, <span class="type">size_t</span> newsize)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 3个函数返回值：若成功，返回非空指针；若出错，返回NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *ptr)</span>;</span><br></pre></td></tr></table></figure>

<h1 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> **<span class="title function_">getenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="comment">/* 返回值：指向与name关联的value的指针；若未找到，返回NULL */</span></span><br></pre></td></tr></table></figure>

<p><code>getenv</code>,可以用其取环境变量值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">putenv</span><span class="params">(<span class="type">char</span> *str)</span>;</span><br><span class="line"><span class="comment">/* 函数返回值：若成功，返回0；若出错，返回非0 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">char</span> *value, <span class="type">int</span> rewrite)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">unsetenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="comment">/* 两个函数返回值：若成功，返回0；若出错，返回-1 */</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>putenv</code>取形式为<code>name=value</code>的字符串，将其放到环境中。</li>
<li><code>setenv</code>将<code>name</code>设置为<code>value</code>。如果在环境中<code>name</code>已存在,那么(a)若<code>rewrite</code>非0，则首先删除其现有的定义;(b)若<code>rewrite</code>为0，则不删除其现有定义(<code>name</code>不设置为新<code>value</code>,而且也不出错)。</li>
<li><code>unsetenv</code>删除<code>name</code>的定义。即使不存在这种定义与不出错。</li>
</ul>
<h1 id="函数setjmp和longjmp"><a href="#函数setjmp和longjmp" class="headerlink" title="函数setjmp和longjmp"></a>函数<code>setjmp</code>和<code>longjmp</code></h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setjmp</span><span class="params">(jmp_buf env)</span>;</span><br><span class="line"><span class="comment">/* 返回值：若直接调用，返回0；若从longjmp返回，则为非0 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">longjmp</span><span class="params">(jmp_buf env, <span class="type">int</span> val)</span>;</span><br></pre></td></tr></table></figure>

<p>在希望返回到的位置调用<code>setjmp</code>。当调用<code>longjmp</code>是，第一个参数是调用<code>setjmp</code>时的<code>env</code>;第二个参数是具有非0值的<code>val</code>,它将称为从<code>setjmp</code>处返回的值。<br>在课本的<a target="_blank" rel="noopener" href="https://github.com/kaiiak/APUE/blob/master/chapter7/7.13.c">例程7.13</a>中，全局变量、静态变量和易失变量(volatile variables)不受优化的影响。如果要编写一个使用非局部跳转的可移植程序，则必须使用<code>volatile</code>属性。但是一个系统移植到另一个系统，其他任何事情都可能改变。</p>
<h1 id="函数getrlimit和setrlimit"><a href="#函数getrlimit和setrlimit" class="headerlink" title="函数getrlimit和setrlimit"></a>函数<code>getrlimit</code>和<code>setrlimit</code></h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getrlimit</span><span class="params">(<span class="type">int</span> resource, <span class="keyword">struct</span> rlimit *rlptr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setrlimit</span><span class="params">(<span class="type">int</span> resource, <span class="type">const</span> <span class="keyword">struct</span> rlimit *rlptr)</span>;</span><br><span class="line"><span class="comment">/* 两个函数返回值：若成功，返回0；若出错，返回非0 */</span></span><br></pre></td></tr></table></figure>
<p>这两个函数的每一次调用都指定一个资源以及一个指向下列结构的指针。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> &#123;</span></span><br><span class="line">    <span class="type">rlim_t</span> rlim_cur;    <span class="comment">/* soft limit: current limit */</span></span><br><span class="line">    <span class="type">rlim_t</span> rlim_max;    <span class="comment">/* hard limit: maximum value for rlim_cur */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol>
<li>任何一个进程都可以将一个限制值更改为小于或等于其硬限制值。</li>
<li>任何一个进程都可以降低其硬限制值，但它必须大于或等于其软限制值。</li>
<li>只有超级用户进程才可以提高硬限制值。</li>
</ol>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>APUE</tag>
      </tags>
  </entry>
  <entry>
    <title>APUE学习笔记——格式化I/O</title>
    <url>//2016/03/29/APUE_study_notes-standard_IO_libray/</url>
    <content><![CDATA[<h1 id="流和FILE对象"><a href="#流和FILE对象" class="headerlink" title="流和FILE对象"></a>流和FILE对象</h1><p>对于<code>ASCII</code>字符集，一个字符用于一个字节表示。对于国际字符集，一个字符可用于多个字节表示。标准I&#x2F;O文件流可用于单字节或多字节(“宽”)字符集。流的定向(stream’s orientation)决定了所读、所写的字符是单字节还是多字节。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wchar.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fwide</span><span class="params">(FILE *fp, <span class="type">int</span> mode)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 返回值：若流是宽定向的，返回正值；</span></span><br><span class="line"><span class="comment"> * 若流是字节定向的，返回负值；若流是未定向的，返回0</span></span><br><span class="line"><span class="comment"> * 如果mode参数值为负，fwide将试图使指定的流是字节定向的。</span></span><br><span class="line"><span class="comment"> * 如果mode参数值为正，fwide将试图使指定的流是宽定向的。</span></span><br><span class="line"><span class="comment"> * 如果mode参数值为0，fwide将不试图设置流的定向，但返回标识该流定向的值。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h1 id="标准输入、标准输出和标准错误"><a href="#标准输入、标准输出和标准错误" class="headerlink" title="标准输入、标准输出和标准错误"></a>标准输入、标准输出和标准错误</h1><p>可以通过预定义文件指针<code>stdin</code>、<code>stdout</code>和<code>stderr</code>加以引用。</p>
<h1 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h1><ul>
<li>全缓冲。在这种情况下，在填满标准I&#x2F;O缓冲区才进行实际I&#x2F;O操作。<br>  冲洗(flush)说明标准I&#x2F;O缓冲区的写操作。也可以直接调用<code>fflush</code>函数冲洗一个流。在终端驱动程序中，<code>flush(刷清)</code>表示丢弃已存储在缓冲区中的数据。</li>
<li>行缓冲。在这种情况下，当在输入和输出中遇到换行符时，标准I&#x2F;O库执行I&#x2F;O操作。</li>
<li>不带缓冲。标准I&#x2F;O库不对字符进行缓冲存储。标准错误流<code>stderr</code>通常是不带缓冲的。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setbuf</span><span class="params">(FILE *<span class="keyword">restrict</span> fp, <span class="type">char</span> *<span class="keyword">restrict</span> buf)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">setvbuf</span><span class="params">(FILE *<span class="keyword">restrict</span> fp, <span class="type">char</span> *<span class="keyword">restrict</span> buf, <span class="type">int</span> mode, <span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 返回值：若成功，返回0；若出错，返回非0</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>这两个函数可用于更改缓冲类型。</p>
<ul>
<li><code>_IOFBF</code> 全缓冲 </li>
<li><code>_IOLBF</code> 行缓冲</li>
<li><code>_IONBF</code> 不带缓冲</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fflush</span><span class="params">(FILE *fp)</span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回0；若出错，返回EOF */</span></span><br></pre></td></tr></table></figure>

<h1 id="打开流"><a href="#打开流" class="headerlink" title="打开流"></a>打开流</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">FILE *<span class="title function_">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> ptahname, <span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> type)</span>;</span><br><span class="line">FILE *<span class="title function_">freopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> pathname, <span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> type, FILE *<span class="keyword">restrict</span> fp)</span>;</span><br><span class="line">FILE *<span class="title function_">fdopen</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *type)</span>;</span><br><span class="line"><span class="comment">/* 3个函数的返回值：若成功，返回文件指针；若出错，返回NULL */</span></span><br></pre></td></tr></table></figure>

<ol>
<li><code>fopen</code>函数打开路径名为<code>pathname</code>的一个指定的文件。</li>
<li><code>freopen</code>函数在一个指定的流上打开一个指定的文件，如若该流已经打开，则先关闭该流。</li>
<li><code>fdopen</code>函数取一个已有的文件描述符，并使一个标准的I&#x2F;O流与该描述符相结合。</li>
</ol>
<p>调用<code>fclose</code>关闭一个打开的流。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fclose</span><span class="params">(FILE *fp)</span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回0；若返回，返回EOF */</span></span><br></pre></td></tr></table></figure>
<p><strong>在该文件被关闭之前，冲洗缓冲区中的输出数据。</strong></p>
<h1 id="读和写流"><a href="#读和写流" class="headerlink" title="读和写流"></a>读和写流</h1><ol>
<li>输入函数<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getc</span><span class="params">(FILE *fp)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fgetc</span><span class="params">(FILE *fp)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getchar</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">/* 3个函数的返回值：若成功，返回下一个字符；若已到达文件尾端或出错，返回EOF */</span></span><br></pre></td></tr></table></figure>
函数<code>getchar</code>等同于<code>getc(stdin)</code>。前两个函数的区别是，<code>getc</code>可被实现为宏，而<code>fgetc</code>不能实现为宏。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ferror</span><span class="params">(FILE *fp)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">feof</span><span class="params">(FILE *fp)</span>;</span><br><span class="line"><span class="comment">/* 两个函数返回值：若条件为真，返回非0(真)；否则，返回0(假) */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">clearerr</span><span class="params">(FILE *fp)</span>;</span><br></pre></td></tr></table></figure>
<p>为了区别是到达文件结尾还是出错。<br>例程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE*stream;</span><br><span class="line">    <span class="comment">/*openafileforwriting*/</span></span><br><span class="line">    stream=</span><br><span class="line">    fopen(<span class="string">&quot;DUMMY.FIL&quot;</span>,<span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="comment">/*forceanerrorconditionbyattemptingtoread*/</span></span><br><span class="line">    (<span class="type">void</span>)</span><br><span class="line">    getc(stream);</span><br><span class="line">    <span class="keyword">if</span>(ferror(stream))<span class="comment">/*testforanerroronthestream*/</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">/*displayanerrormessage*/</span></span><br><span class="line">     </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ErrorreadingfromDUMMY.FIL\n&quot;</span>);</span><br><span class="line">    <span class="comment">/*resettheerrorandEOFindicators*/</span></span><br><span class="line">     </span><br><span class="line">    clearerr(stream);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    fclose(stream);</span><br><span class="line">    return0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从流中读取数据后，可以调用<code>ungetc</code>将字符再压送回流中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ungetc</span><span class="params">(<span class="type">int</span> c, FILE *fp)</span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回c；若出错，返回EOF */</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>输出函数<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">putc</span><span class="params">(<span class="type">int</span> c, FILE *fp)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> c, FILE *fp)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">putchar</span><span class="params">(<span class="type">int</span> c)</span>;</span><br><span class="line"><span class="comment">/* 3个函数返回值：若成功，返回c;若出错，返回EOF */</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="每次一行I-x2F-O"><a href="#每次一行I-x2F-O" class="headerlink" title="每次一行I&#x2F;O"></a>每次一行I&#x2F;O</h1><p>下面两个函数提供每次输入一行的功能。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">fgets</span><span class="params">(<span class="type">char</span> *<span class="keyword">restrict</span> buf, <span class="type">int</span> n, FILE *<span class="keyword">restrict</span> fp)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">gets</span><span class="params">(<span class="type">char</span> *buf)</span>;</span><br><span class="line"><span class="comment">/* 两个函数返回值：若成功，返回buf；若已到达文件尾端或出错，返回NULL */</span></span><br></pre></td></tr></table></figure>

<p><code>fgets</code>函数一直读到下一个换行符为止，但是不超过n-1个字符，读入的字符被送入缓冲区。</p>
<p><code>fputs</code>和<code>puts</code>提供每次输入一行的功能。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputs</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> str, FILE *<span class="keyword">restrict</span> fp)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">puts</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>;</span><br><span class="line"><span class="comment">/* 两个函数返回值：若成功，返回非负值；若出错，返回EOF */</span></span><br></pre></td></tr></table></figure>
<p>函数<code>fputs</code>将一个以null字节终止的字符串写到指定的流，尾端的终止符null不写出。</p>
<h1 id="二进制I-x2F-O"><a href="#二进制I-x2F-O" class="headerlink" title="二进制I&#x2F;O"></a>二进制I&#x2F;O</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fread</span><span class="params">(<span class="type">void</span> *<span class="keyword">restrict</span> ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nboj, FILE *<span class="keyword">restrict</span> fp)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *<span class="keyword">restrict</span> ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nobj, FILE *<span class="keyword">restrict</span> fp)</span>;</span><br><span class="line"><span class="comment">/* 两个函数的返回值：读或写的对象数 */</span></span><br></pre></td></tr></table></figure>
<p><strong>指定size为每个数组元素的长度，nobj为欲写元素个数</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 写数组 */</span></span><br><span class="line"><span class="type">float</span> data[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fwrite(&amp;data[<span class="number">2</span>], <span class="keyword">sizeof</span>(<span class="type">float</span>), <span class="number">4</span>, fp) != <span class="number">4</span>)</span><br><span class="line">    err_sys(<span class="string">&quot;fwrite error&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 写一个结构体 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">short</span>   count;</span><br><span class="line">    <span class="type">long</span>    total;</span><br><span class="line">    <span class="type">char</span>    name[NAMESIZE];</span><br><span class="line">&#125; item;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fwrite(&amp;item, <span class="keyword">sizeof</span>(item), <span class="number">1</span>, fp) != <span class="number">1</span>)</span><br><span class="line">    err_sys(<span class="string">&quot;fwrite error&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>使用二进制I&#x2F;O的基本问题，它只能用于读在同一个系统上已写的数据</strong></p>
<h1 id="定位流-Positioning-a-Stream"><a href="#定位流-Positioning-a-Stream" class="headerlink" title="定位流(Positioning a Stream)"></a>定位流(Positioning a Stream)</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">ftell</span><span class="params">(FILE *fp)</span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回当前文件位置指示；若出错，返回-1L */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fseek</span><span class="params">(FILE *fp, <span class="type">long</span> offset, <span class="type">int</span> whence)</span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回0；若出错，返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rewind</span><span class="params">(FILE *fp)</span>;</span><br></pre></td></tr></table></figure>

<p><code>whence</code>的值与<code>lseek</code>函数的相同：<code>SEEK_SET</code>表示从文件的起始位置开始，<code>SEEK_CUR</code>表示从当前文件位置开始，<code>SEEK_END</code>表示从文件的尾端开始。<code>offset</code>，文件偏移量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">off_t</span> <span class="title function_">ftello</span><span class="params">(FILE *fp)</span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回当前文件位置；若出错，返回(off_t)-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fseeko</span><span class="params">(FILE *fp, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回0；若出错，返回-1 */</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fgetpos</span><span class="params">(FILE *<span class="keyword">restrict</span> fp, <span class="type">fpos_t</span> *<span class="keyword">restrict</span> pos)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fsetpos</span><span class="params">(FILE *fp, <span class="type">const</span> <span class="type">fpos_t</span> *pos)</span>;</span><br><span class="line"><span class="comment">/* 两个函数返回值：若成功，返回0；若出错，返回非0 */</span></span><br></pre></td></tr></table></figure>

<h1 id="格式化I-x2F-O"><a href="#格式化I-x2F-O" class="headerlink" title="格式化I&#x2F;O"></a>格式化I&#x2F;O</h1><ol>
<li>格式化输出<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fprintf</span><span class="params">(FILE *<span class="keyword">restrict</span> fp, <span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dprintf</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> format, ...)</span>;</span><br><span class="line"><span class="comment">/* 3个函数返回值：若成功，返回输入字符数；若出错，返回负值 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sprintf</span><span class="params">(<span class="type">char</span> *<span class="keyword">restrict</span> buf, <span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> format, ...)</span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回输入数组的字符数；若编码出错，返回负值 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">snprintf</span><span class="params">(<span class="type">char</span> *<span class="keyword">restrict</span> buf, <span class="type">size_t</span> n, <span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> format, ...)</span>;</span><br><span class="line"><span class="comment">/* 返回值：若缓冲区足够大，返回将要存入数组的字符数；若编码出错，返回负值 */</span></span><br></pre></td></tr></table></figure>
<strong>printf将格式化数据写到标准输出，fprintf写至指定的流，dprintf写至制定的文件描述符，sprintf将格式化的字符送入数组buf。</strong></li>
</ol>
<p>下面5种<code>printf</code>族的变体，将可变参数表(…)替换成了arg。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">vprintf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> format, va_list arg)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vfprintf</span><span class="params">(FILE *<span class="keyword">restrict</span> fp, <span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> format, va_list arg)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vdprintf</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> format, va_list arg)</span>;</span><br><span class="line"><span class="comment">/* 3个函数返回值：若成功，返回输入字符数；若出错，返回负值 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">vsprintf</span><span class="params">(<span class="type">char</span> *<span class="keyword">restrict</span> buf, <span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> format, va_list arg)</span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回输入数组的字符数；若编码出错，返回负值 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">vsnprintf</span><span class="params">(<span class="type">char</span> *<span class="keyword">restrict</span> buf, <span class="type">size_t</span> n, <span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> format, va_list arg)</span>;</span><br><span class="line"><span class="comment">/* 返回值：若缓冲区足够大，返回将要存入数组的字符数；若编码出错，返回负值 */</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>格式化输入<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">scanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fscanf</span><span class="params">(FILE *<span class="keyword">restrict</span> fp, <span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sscanf</span><span class="params">(<span class="type">const</span> *<span class="keyword">restrict</span> buf, <span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> format, ...)</span>;</span><br><span class="line"><span class="comment">/* 3个函数返回值：赋值的输入项数；若输入出错或在任一转换前已到达文件尾端，返回EOF */</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="临时文件"><a href="#临时文件" class="headerlink" title="临时文件"></a>临时文件</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">tmpnam</span><span class="params">(<span class="type">char</span> *ptr)</span>;</span><br><span class="line"><span class="comment">/* 返回值：指向唯一路径名的指针 */</span></span><br><span class="line"></span><br><span class="line">FILE *<span class="title function_">tmpfile</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回文件指针；若出错，返回NULL */</span></span><br></pre></td></tr></table></figure>

<p><code>tmpnam</code>函数产生一个与现有文件名不同的一个有效路径名字符串。如果<code>ptr</code>是NULL，则产生的路径名存放在一个静态区中，指向该静态区的指针作为函数值返回。后续调用<code>tmpnam</code>会从写该静态区。如过<code>ptr</code>不是NULL，则认为它应该指向长度至少是<code>L_tmpnam</code>个字符的数组。所产生的路径名存放在该数组中，<code>ptr</code>也作为函数值返回。<br><code>tmpfile</code>创建一个临时二进制文件(wb+)，在关闭该文件或程序结束时将自动删除这种文件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">mkdtemp</span><span class="params">(<span class="type">char</span> *template)</span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回指向目录名的指针；若出错，返回NULL */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkstemp</span><span class="params">(<span class="type">char</span> *template)</span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回文件描述符；若出错，返回-1 */</span></span><br></pre></td></tr></table></figure>
<p><code>mkdtemp</code>函数创建了一个目录，该目录有唯一的名字；<code>mkstemp</code>函数创建了一个文件，该文件有一个唯一的名字。<strong>名字是通过template字符串进行选择的。这个字符串后6位设置为XXXXXX的路径名。</strong></p>
<h1 id="内存流"><a href="#内存流" class="headerlink" title="内存流"></a>内存流</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">FILE *<span class="title function_">fmemopen</span><span class="params">(<span class="type">void</span> *<span class="keyword">restrict</span> buf, <span class="type">size_t</span> size, <span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> type)</span>;</span><br><span class="line"><span class="comment">/* 返回值：若成功，返回流指针；若出错，返回NULL */</span></span><br></pre></td></tr></table></figure>

<p><code>fmemopen</code>函数允许调用者提供缓冲区用于内存流：<code>buf</code>参数指向缓冲区的开始位置，<code>size</code>参数指定了缓冲区大小的字节数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">FILE *<span class="title function_">open_memstream</span><span class="params">(<span class="type">char</span> **bufp, <span class="type">size_t</span> *sizep)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wchar.h&gt;</span></span></span><br><span class="line">FILE *<span class="title function_">open_wmemstream</span><span class="params">(<span class="type">wchar_t</span> **bufp, <span class="type">size_t</span> *sizep)</span>;</span><br><span class="line"><span class="comment">/* 两个函数的返回值：若成功，返回流指针；若出错，返回NULL */</span></span><br></pre></td></tr></table></figure>
<p><code>open_memstream</code>函数创建的流是面向字节的，<code>open_wmemstream</code>函数创建的流是面向宽字节的。</p>
<ul>
<li>创建的流只能打开；</li>
<li>不能指定自己的缓冲区，但可以分别通过<code>bufp</code>和<code>sizep</code>参数访问缓冲区地址和大小；</li>
<li>关闭后需要自行释放缓冲区；</li>
<li>对流添加字节会增加缓冲区大小。</li>
</ul>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>APUE</tag>
      </tags>
  </entry>
  <entry>
    <title>Happy New Year</title>
    <url>//2016/01/01/Happy-New-Year/</url>
    <content><![CDATA[<h2 id="新年快乐～"><a href="#新年快乐～" class="headerlink" title="新年快乐～"></a>新年快乐～</h2><p>在新的一年里，希望我能入门C++，哈哈哈哈哈哈哈哈哈哈哈哈</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>安装vim插件YouCompleteMe</title>
    <url>//2016/03/06/compile_YouCompleteMe_in_Ubuntu_64/</url>
    <content><![CDATA[<p><code>YouCompleteMe</code>是<code>vim</code>上非常好用的代码自动补全的插件。但是必须自己本机编译他，提高了门槛。<br>我的环境是<code>ubuntu15.10</code>，照着教程来：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git submodule add https://github.com/Valloric/YouCompleteMe bundle/YouCompleteMe</span><br><span class="line">git submodule update --init --recursive -- bundle/YouCompleteMe</span><br></pre></td></tr></table></figure>
<p>然后编译：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cd bundle/YouCompleteMe</span><br><span class="line">./install.sh --clang-completer</span><br></pre></td></tr></table></figure>
<p>但是我编译的时候出现了错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ 87%] Building CXX object ycm/CMakeFiles/ycm_core.dir/ClangCompleter/ClangCompleter.cpp.o</span><br><span class="line">In file included from /home/kai/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/BoostParts/boost/type_traits/ice.hpp:15:0,</span><br><span class="line">                 from /home/kai/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/BoostParts/boost/python/detail/def_helper.hpp:9,</span><br><span class="line">                 from /home/kai/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/BoostParts/boost/python/class.hpp:29,</span><br><span class="line">                 from /home/kai/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/BoostParts/boost/python.hpp:18,</span><br><span class="line">                 from /home/kai/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/ycm/ReleaseGil.h:21,</span><br><span class="line">                 from /home/kai/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/ycm/ClangCompleter/ClangCompleter.cpp:28:</span><br><span class="line">/home/kai/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/BoostParts/boost/type_traits/detail/ice_or.hpp:17:71: note: #pragma message: NOTE: Use of this header (ice_or.hpp) is deprecated</span><br><span class="line"> # pragma message(&quot;NOTE: Use of this header (ice_or.hpp) is deprecated&quot;)</span><br><span class="line">                                                                       ^</span><br></pre></td></tr></table></figure>

<p>然后一直到最后。<br>这个是因为在编译<code>boost</code>时，出现了错误。</p>
<p>在这之前，脚本会自动下载<code>clang</code>，然后编译编译<code>boost</code>，而且编译出现了错误。这时我想为什么不用本机上已经安装好的的<code>clang</code>和<code>boost</code>呢？</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get instll clang</span><br><span class="line">sudo apt-get install libboost-all-dev</span><br></pre></td></tr></table></figure>

<p>然后执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./install.sh --clang-completer --system-libclang --system-boost</span><br></pre></td></tr></table></figure>

<p>而这一切都在<a target="_blank" rel="noopener" href="https://github.com/Valloric/YouCompleteMe#freebsdopenbsd">官方文档里有说明</a>，我折腾完才看到，所以认真读说明是很重要的。 :(</p>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>vim</tag>
        <tag>YouCompleteMe</tag>
      </tags>
  </entry>
  <entry>
    <title>在Ubuntu上编译libprotobuf.so.17和boost1.53</title>
    <url>//2023/02/13/compiling_dynamic_link_libraries_libprotobuf_so_17_and_boost_1_53_0_on_ubuntu_20_04/</url>
    <content><![CDATA[<p>最近在迁移服务器的时候，涉及到操作系统的替换和升级，导致一些C++依赖的项目无法在新系统中运行。由于某些原因，无法在新环境编译旧的服务，只能安装旧的依赖。<br>在Ubuntu20.04中，没有那么旧的依赖可以直接安装，只能自己编译。因为Gcc5.x中添加了对某些C++11的支持，更改了ABI，所以必须使用4.X编译依赖库，需要使用Ubuntu14.04。<br>下面是编译使用的<code>Dockerfile</code>。</p>
<h2 id="libprotobuf-so-17-0"><a href="#libprotobuf-so-17-0" class="headerlink" title="libprotobuf.so.17.0"></a>libprotobuf.so.17.0</h2><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">14.04</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; apt-get install -y git \</span></span><br><span class="line"><span class="language-bash">                        g++ \</span></span><br><span class="line"><span class="language-bash">                        make \</span></span><br><span class="line"><span class="language-bash">                        wget \</span></span><br><span class="line"><span class="language-bash">                        autoconf \</span></span><br><span class="line"><span class="language-bash">                        libtool \</span></span><br><span class="line"><span class="language-bash">                        automake</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文档地址：https://github.com/protocolbuffers/protobuf/tree/v3.6.1.3/src</span></span><br><span class="line"><span class="comment"># 如果因为网络原因导致压缩包下载缓慢，可以下载到本地再使用COPY命令，复制Docker中</span></span><br><span class="line"><span class="comment"># COPY protobuf-3.6.1.3.tar.gz /home</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cd</span> /home &amp;&amp; wget -O protobuf-3.6.1.3.tar.gz https://github.com/protocolbuffers/protobuf/archive/refs/tags/v3.6.1.3.tar.gz \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; tar xfz protobuf-3.6.1.3.tar.gz \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; <span class="built_in">rm</span> protobuf-3.6.1.3.tar.gz \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; <span class="built_in">cd</span> protobuf-3.6.1.3 \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; ./autogen.sh \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; ./configure --prefix=/usr/ \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; make \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; make install \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; <span class="built_in">cd</span> /home \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; <span class="built_in">rm</span> -rf protobuf-3.6.1.3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;bash&quot;</span>]</span></span><br></pre></td></tr></table></figure>
<h2 id="boost-1-53-0"><a href="#boost-1-53-0" class="headerlink" title="boost 1.53.0"></a>boost 1.53.0</h2><p>例如<code>boost_thread-mt.so.1.53.0</code>直接可以软连接到<code>boost_thread.so.1.53.0</code>上。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">14.04</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; apt-get install -y git \</span></span><br><span class="line"><span class="language-bash">                        g++ \</span></span><br><span class="line"><span class="language-bash">                        make \</span></span><br><span class="line"><span class="language-bash">                        wget</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果因为网络原因导致压缩包下载缓慢，可以下载到本地再使用COPY命令，复制Docker中</span></span><br><span class="line"><span class="comment"># COPY boost_1_53_0.tar.gz /home</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cd</span> /home &amp;&amp; wegt http://downloads.sourceforge.net/project/boost/boost/1.53.0/boost_1_53_0.tar.gz \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; tar xfz boost_1_53_0.tar.gz \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; <span class="built_in">rm</span> boost_1_53_0.tar.gz \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; <span class="built_in">cd</span> boost_1_53_0 \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; ./bootstrap.sh --prefix=/usr/local --with-libraries=program_options,regex,date_time,filesystem,system,thread \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; ./b2 install \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; <span class="built_in">cd</span> /home \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; <span class="built_in">rm</span> -rf boost_1_53_0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;bash&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<h2 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h2><ul>
<li>使用<code>docker run</code>启动容器以后，再使用<code>docker cp</code>命令复制容器中的文件</li>
<li>使用<code>docker save</code>命令压缩<code>image</code>，然后解压缩</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.pkslow.com/archives/extract-files-from-docker-image">如何从Docker镜像中导出文件</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/pblischak/boost-docker-test">boost docker</a></li>
<li><a target="_blank" rel="noopener" href="https://medium.com/@joe.tsai8207/c-abi-changed-in-gcc-5-x-4fca239c36b6">C++ ABI changed in GCC 5.x</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/kaiiak/libprotobuf-docker">libprotobuf docker</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/kaiiak/boost-docker">boost docker</a></li>
</ul>
]]></content>
      <tags>
        <tag>Ubuntu</tag>
        <tag>C++</tag>
        <tag>gcc</tag>
        <tag>编译</tag>
        <tag>protobuf</tag>
        <tag>boost</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>ZOJ_1003:Crashing Ballon</title>
    <url>//2015/11/04/crashing-ballon/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>On every June 1st, the Children’s Day, there will be a game named “crashing balloon” on TV.   The rule is very simple.  On the ground there are 100 labeled balloons, with the numbers 1 to 100.  After the referee shouts “Let’s go!” the two players, who each starts with a score of  “1”, race to crash the balloons by their feet and, at the same time, multiply their scores by the numbers written on the balloons they crash.  After a minute, the little audiences are allowed to take the remaining balloons away, and each contestant reports his\her score, the product of the numbers on the balloons he\she’s crashed.  The unofficial winner is the player who announced the highest score.</p>
</blockquote>
<blockquote>
<p>Inevitably, though, disputes arise, and so the official winner is not determined until the disputes are resolved.  The player who claims the lower score is entitled to challenge his\her opponent’s score.  The player with the lower score is presumed to have told the truth, because if he\she were to lie about his\her score, he\she would surely come up with a bigger better lie.  The challenge is upheld if the player with the higher score has a score that cannot be achieved with balloons not crashed by the challenging player.  So, if the challenge is successful, the player claiming the lower score wins.</p>
</blockquote>
<blockquote>
<p>So, for example, if one player claims 343 points and the other claims 49, then clearly the first player is lying; the only way to score 343 is by crashing balloons labeled 7 and 49, and the only way to score 49 is by crashing a balloon labeled 49.  Since each of two scores requires crashing the balloon labeled 49, the one claiming 343 points is presumed to be lying.</p>
</blockquote>
<blockquote>
<p>On the other hand, if one player claims 162 points and the other claims 81, it is possible for both to be telling the truth (e.g. one crashes balloons 2, 3 and 27, while the other crashes balloon 81), so the challenge would not be upheld.</p>
</blockquote>
<blockquote>
<p>By the way, if the challenger made a mistake on calculating his&#x2F;her score, then the challenge would not be upheld. For example, if one player claims 10001 points and the other claims 10003, then clearly none of them are telling the truth. In this case, the challenge would not be upheld.</p>
</blockquote>
<blockquote>
<p>Unfortunately, anyone who is willing to referee a game of crashing balloon is likely to get over-excited in the hot atmosphere that he\she could not reasonably be expected to perform the intricate calculations that refereeing requires.  Hence the need for you, sober programmer, to provide a software solution.</p>
</blockquote>
<blockquote>
<p>Input</p>
</blockquote>
<blockquote>
<p>Pairs of unequal, positive numbers, with each pair on a single line, that are claimed scores from a game of crashing balloon.<br>Output</p>
</blockquote>
<blockquote>
<p>Numbers, one to a line, that are the winning scores, assuming that the player with the lower score always challenges the outcome.<br>Sample Input</p>
</blockquote>
<blockquote>
<p>343 49<br>3599 610<br>62 36</p>
</blockquote>
<blockquote>
<p>Sample Output</p>
</blockquote>
<blockquote>
<p>49<br>610<br>62</p>
</blockquote>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=1003</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> f1, f2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> numa, <span class="type">int</span> numb, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(numb == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        f2 = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(numa == <span class="number">1</span>) f1 = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(k == <span class="number">1</span> || (f1 &amp;&amp; f2)) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(numa % k == <span class="number">0</span>) <span class="built_in">dfs</span>(numa / k, numb, k - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(numb % k == <span class="number">0</span>) <span class="built_in">dfs</span>(numa, numb / k, k - <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">dfs</span>(numa, numb, k - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a, b;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b) != EOF)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(a &lt; b) <span class="built_in">swap</span>(a, b);</span><br><span class="line">		f1 = f2 = <span class="literal">false</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(a, b, <span class="number">100</span>);</span><br><span class="line">		<span class="keyword">if</span>(!f1 &amp;&amp; f2) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,b);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C</tag>
        <tag>ACM</tag>
        <tag>ZOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang踩坑小结之SMTP</title>
    <url>//2017/02/28/golang_smtp/</url>
    <content><![CDATA[<h1 id="smtp之golang标准库"><a href="#smtp之golang标准库" class="headerlink" title="smtp之golang标准库"></a>smtp之golang标准库</h1><p>函数<code>SendMail</code>就是标准库里面最简单的发送邮件的方法。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SendMail</span><span class="params">(addr <span class="type">string</span>, a Auth, from <span class="type">string</span>, to []<span class="type">string</span>, msg []<span class="type">byte</span>)</span></span> <span class="type">error</span></span><br></pre></td></tr></table></figure>
<p>对不熟悉smtp协议的小伙伴来说，最难的地方就是构造<code>msg</code>了。<br>在指定<code>smtp</code>的<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc5321">RFC531</a>中，定义了<code>smtp</code>客户端和服务器的通讯方式和报文的格式。</p>
<h2 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h2><p>现在的邮件服务器除了<code>25</code>端口外，还采用了其他的默认采用TLS的端口（只能TLS连接）。<br>但是标准库还会发送<code>STARTTLS</code>命令，但是服务器不会回应，这样就产生了阻塞。<br>以下是直接通过tls端口发送邮件的代码。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SendMailTLS not use STARTTLS commond</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SendMailTLS</span><span class="params">(addr <span class="type">string</span>, auth smtp.Auth, from <span class="type">string</span>, to []<span class="type">string</span>, msg []<span class="type">byte</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	host, _, err := net.SplitHostPort(addr)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	tlsconfig := &amp;tls.Config&#123;ServerName: host&#125;</span><br><span class="line">	<span class="keyword">if</span> err = validateLine(from); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, recp := <span class="keyword">range</span> to &#123;</span><br><span class="line">		<span class="keyword">if</span> err = validateLine(recp); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	conn, err := tls.Dial(<span class="string">&quot;tcp&quot;</span>, addr, tlsconfig)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line">	c, err := smtp.NewClient(conn, host)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> c.Close()</span><br><span class="line">	<span class="keyword">if</span> err = c.Hello(<span class="string">&quot;localhost&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err = c.Auth(auth); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err = c.Mail(from); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, addr := <span class="keyword">range</span> to &#123;</span><br><span class="line">		<span class="keyword">if</span> err = c.Rcpt(addr); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	w, err := c.Data()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	_, err = w.Write(msg)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	err = w.Close()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c.Quit()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// validateLine checks to see if a line has CR or LF as per RFC 5321</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">validateLine</span><span class="params">(line <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> strings.ContainsAny(line, <span class="string">&quot;\n\r&quot;</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;a line must not contain CR or LF&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="MIME"><a href="#MIME" class="headerlink" title="MIME"></a>MIME</h1><blockquote>
<p>多用途互联网邮件扩展（MIME，Multipurpose Internet Mail Extensions）是一个互联网标准，它扩展了电子邮件标准，使其能够支援：<br>非ASCII字符文本；<br>非文本格式附件（二进制、声音、图像等）；<br>由多部分（multiple parts）组成的消息体；<br>包含非ASCII字符的头信息（Header information）。这个标准被定义在RFC 2045、RFC 2046、RFC 2047、RFC 2048、RFC 2049等RFC中。<br>MIME改善了由RFC 822转变而来的RFC 2822，这些旧标准规定电子邮件标准并不允许在邮件消息中使用7位ASCII字符集以外的字符。正因如此，一些非英语字符消息和二进制文件，图像，声音等非文字消息原本都不能在电子邮件中传输（MIME可以）。MIME规定了用于表示各种各样的数据类型的符号化方法。此外，在万维网中使用的HTTP协议中也使用了MIME的框架，标准被扩展为互联网媒体类型。</p>
</blockquote>
<h2 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MIME-Version: 1.0</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Content-transfer-encoding: base64</span><br><span class="line">boundary = XXXXXXXXXXXXXXXXX</span><br><span class="line">--XXXXXXXXXXXXXXXXX</span><br><span class="line">base64 string</span><br><span class="line">--XXXXXXXXXXXXXXXXX</span><br><span class="line">base64 string</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="邮件格式"><a href="#邮件格式" class="headerlink" title="邮件格式"></a>邮件格式</h1><h2 id="基本字段"><a href="#基本字段" class="headerlink" title="基本字段"></a>基本字段</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">From:来自测试发送&lt;aNxFi37X@outlook.com&gt;</span><br><span class="line">To:aNxFi37X@outlook.com</span><br><span class="line">Date:27 Mar 17 00:45 +0800</span><br><span class="line">Cc:aNxFi37X@outlook.com</span><br><span class="line">Subject: TEST</span><br></pre></td></tr></table></figure>
<h2 id="bcc"><a href="#bcc" class="headerlink" title="bcc"></a>bcc</h2><p>密送的实现很好玩，在邮件内容里不填写信息，但是发送的时候发送给密送的那个人。<br>这里的设计很巧妙。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><CRLF></h2><p>以上的每一项都以<code>&lt;CRLF&gt;</code>结束，即<code>\r\n</code>。</p>
<h2 id="邮件内容"><a href="#邮件内容" class="headerlink" title="邮件内容"></a>邮件内容</h2><p>这里使用MIME，当然也可以使用<code>8BITMIME</code>发送多媒体内容。<br>具体的方式是创建一个MIME part，每个part里面设置自己的<code>Content-Disposition</code>、<code>Content-Transfer-Encoding</code>、<code>Content-Type</code>。<br><code>Content-Transfer-Encoding</code>使用base64编码，不然直接发送<code>ascii</code>中含有<code>\r\n.\r\n</code>，邮件就直接结束了。<br>虽然编码率高了不少，但是简单，易操作，不依赖服务器支持<code>8BITMIME</code>。</p>
<h2 id="邮件样例"><a href="#邮件样例" class="headerlink" title="邮件样例"></a>邮件样例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">From:来自测试发送&lt;aNxFi37X@outlook.com&gt;</span><br><span class="line">To:aNxFi37X@outlook.com</span><br><span class="line">Date:27 Mar 17 00:45 +0800</span><br><span class="line">Cc:aNxFi37X@outlook.com</span><br><span class="line">Subject:=?UTF-8?B?5rWL6K+V?=</span><br><span class="line">Content-Type: multipart/mixed; boundary=5b83f06665140150554c5847a8a3b05a5a9d64f5ec6a42fec16a4460223c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MIME-Version: 1.0</span><br><span class="line">--5b83f06665140150554c5847a8a3b05a5a9d64f5ec6a42fec16a4460223c</span><br><span class="line">Content-Transfer-Encoding: base64</span><br><span class="line">Content-Type: text/html</span><br><span class="line"></span><br><span class="line">PHA+6L+Z5piv5LiA5bCB5rWL6K+V6YKu5Lu2PC9wPg==</span><br><span class="line">--5b83f06665140150554c5847a8a3b05a5a9d64f5ec6a42fec16a4460223c</span><br><span class="line">Content-Disposition: attachment; filename=&quot;=?UTF-8?B?MS50eHQ=?=&quot;</span><br><span class="line">Content-Transfer-Encoding: base64</span><br><span class="line">Content-Type: application/application/octet-stream</span><br><span class="line"></span><br><span class="line">MS50eHQ=</span><br><span class="line"></span><br><span class="line">--5b83f06665140150554c5847a8a3b05a5a9d64f5ec6a42fec16a4460223c</span><br><span class="line">Content-Disposition: attachment; filename=&quot;=?UTF-8?B?Mi50eHQ=?=&quot;</span><br><span class="line">Content-Transfer-Encoding: base64</span><br><span class="line">Content-Type: application/application/octet-stream</span><br><span class="line"></span><br><span class="line">Mi50eHQ=</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="发送过程"><a href="#发送过程" class="headerlink" title="发送过程"></a>发送过程</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">S: 220 xyz.com Simple Mail Transfer Service Ready</span><br><span class="line">C: EHLO foo.com</span><br><span class="line">S: 250 xyz.com is on the air</span><br><span class="line">C: MAIL FROM:&lt;@foo.com:JQP@bar.com&gt;</span><br><span class="line">S: 250 OK</span><br><span class="line">C: RCPT TO:&lt;Jones@XYZ.COM&gt;</span><br><span class="line">S: 250 OK</span><br><span class="line">C: DATA</span><br><span class="line">S: 354 Start mail input; end with &lt;CRLF&gt;.&lt;CRLF&gt;</span><br><span class="line">C: Received: from bar.com by foo.com ; Thu, 21 May 1998</span><br><span class="line">C:     05:33:29 -0700</span><br><span class="line">C: Date: Thu, 21 May 1998 05:33:22 -0700</span><br><span class="line">C: From: John Q. Public &lt;JQP@bar.com&gt;</span><br><span class="line">C: Subject:  The Next Meeting of the Board</span><br><span class="line">C: To: Jones@xyz.com</span><br><span class="line">C:</span><br><span class="line">C: Bill:</span><br><span class="line">C: The next meeting of the board of directors will be</span><br><span class="line">C: on Tuesday.</span><br><span class="line">C:                         John.</span><br><span class="line">C: .</span><br><span class="line">S: 250 OK</span><br><span class="line">C: QUIT</span><br><span class="line">S: 221 foo.com Service closing transmission channel</span><br></pre></td></tr></table></figure>
<h2 id="HELO-or-EHLO"><a href="#HELO-or-EHLO" class="headerlink" title="HELO or EHLO"></a>HELO or EHLO</h2><p>确定服务器可用</p>
<h2 id="MAIL"><a href="#MAIL" class="headerlink" title="MAIL"></a>MAIL</h2><p>声明发信邮箱</p>
<h2 id="RCPT"><a href="#RCPT" class="headerlink" title="RCPT"></a>RCPT</h2><p>声明收件邮箱。密送的邮箱就是在这里声明，但是不写在邮件内容里面。</p>
<h2 id="DATA"><a href="#DATA" class="headerlink" title="DATA"></a>DATA</h2><p>发送邮件的内容。</p>
<h2 id="QUIT"><a href="#QUIT" class="headerlink" title="QUIT"></a>QUIT</h2><p>结束发送，并关闭连接。</p>
<h1 id="拓展命令"><a href="#拓展命令" class="headerlink" title="拓展命令"></a>拓展命令</h1><h2 id="STARTLTLS"><a href="#STARTLTLS" class="headerlink" title="STARTLTLS"></a>STARTLTLS</h2><p>试探服务器是否支持TLS。</p>
<h2 id="8BITMIME"><a href="#8BITMIME" class="headerlink" title="8BITMIME"></a>8BITMIME</h2><p>试探服务器是否支持8字长的编码。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>其他的命令没有使用，这里挖个坑。</p>
<center>
一篇文章从一号拖到现在，真的好丢人啊。
多谢您花费时间阅读我的文章，有不好的地方欢迎指正。
</center>]]></content>
      <tags>
        <tag>Golang</tag>
        <tag>Smtp</tag>
      </tags>
  </entry>
  <entry>
    <title>为Eclipse本地安装PyDev</title>
    <url>//2015/11/09/local-install-pydev-with-eclipse/</url>
    <content><![CDATA[<h3 id="由于众所周知的原因，国内的网络环境一直不是很好。最近我在Eclipse上安装Pydev也不可以了。所以，打算用本地安装的方法来解决。"><a href="#由于众所周知的原因，国内的网络环境一直不是很好。最近我在Eclipse上安装Pydev也不可以了。所以，打算用本地安装的方法来解决。" class="headerlink" title="由于众所周知的原因，国内的网络环境一直不是很好。最近我在Eclipse上安装Pydev也不可以了。所以，打算用本地安装的方法来解决。"></a>由于众所周知的原因，国内的网络环境一直不是很好。最近我在Eclipse上安装Pydev也不可以了。所以，打算用本地安装的方法来解决。</h3><p>可以在<a target="_blank" rel="noopener" href="http://sourceforge.net/projects/pydev">这里</a>下载到最新的PyDev for Eclipse。<br>然后，将压缩包内的<code>features</code>和<code>plugins</code>文件夹拷贝到eclipse的安装目录下。重启eclipse，在<code>Help</code>-&gt;<code>About Eclipse</code>-&gt;<code>Installation Details</code>中看到PyDev的信息。</p>
]]></content>
      <tags>
        <tag>Eclipse</tag>
        <tag>PyDev</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang调用FFMPEG实现MP3转PCM</title>
    <url>//2020/06/06/mp3-to-pcm/</url>
    <content><![CDATA[<p><em>如果代码加载不出来，请科学上网来使用Github Gist</em></p>
<script src="https://gist.github.com/kaiiak/4e5f058f4289153a525a54fbc43e756a.js"></script>]]></content>
      <tags>
        <tag>Golang</tag>
        <tag>Ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>自用vim配置文件</title>
    <url>//2016/03/05/personal_vimrc/</url>
    <content><![CDATA[<h1 id="使用Pathogen管理插件"><a href="#使用Pathogen管理插件" class="headerlink" title="使用Pathogen管理插件"></a>使用<code>Pathogen</code>管理插件</h1><p>推荐<a target="_blank" rel="noopener" href="http://lostjs.com/2012/02/04/use-pathogen-and-git-to-manage-vimfiles/">这篇教程</a>，使用<code>Pahtogen</code>+<code>Git</code>的方式管理插件和vim配置，方便vim的迁移和团队配置的统一。</p>
<h1 id="自用的vim配置文件"><a href="#自用的vim配置文件" class="headerlink" title="自用的vim配置文件"></a>自用的vim配置文件</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot; 编码</span><br><span class="line">set encoding=utf-8</span><br><span class="line"></span><br><span class="line">&quot; 避免以前版本的一些bug和局限</span><br><span class="line">set nocompatible</span><br><span class="line"></span><br><span class="line">&quot; 逐步搜索模式，对当前键入的字符进行搜索而不必等待键入完成,/b寻找b开头的。</span><br><span class="line">set incsearch</span><br><span class="line"></span><br><span class="line">&quot;自动识别文件类型</span><br><span class="line">&quot; set filetype</span><br><span class="line"></span><br><span class="line">&quot; 搜索时高亮显示找到文本</span><br><span class="line">set hlsearch</span><br><span class="line"></span><br><span class="line">&quot; 在Insert模式下退格键何时可以删除光标之前的字符。三项内容分别指定了Vim可以删除位于行首的空格,断行,以及开始进入Insert模式之前的位置。</span><br><span class="line">set backspace=indent,eol,start</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot; 设置tab键为4个空格，设置当行之间交错时使用4个空格</span><br><span class="line">set tabstop=4</span><br><span class="line">set shiftwidth=4</span><br><span class="line"></span><br><span class="line">&quot; 匹配模式，左括号匹配右括号</span><br><span class="line">set showmatch</span><br><span class="line"></span><br><span class="line">&quot; 在覆盖一个文件之前备份该文件。但是对VMS系统除外,因为该系统已经为文件保存了老的版本。备份文件名由当前文件名加后辍&quot;~&quot;组成。</span><br><span class="line">&quot; if has(&quot;vms&quot;)</span><br><span class="line">&quot; set nobackup</span><br><span class="line">&quot; else</span><br><span class="line">&quot; set backup</span><br><span class="line">&quot; endif</span><br><span class="line"></span><br><span class="line">&quot; 设置冒号命令和搜索命令的命令历史列表的长度。</span><br><span class="line">set history=1000</span><br><span class="line"></span><br><span class="line">&quot; 总是在Vim窗口的右下角显示当前光标的行列信息。</span><br><span class="line">set ruler</span><br><span class="line"></span><br><span class="line">&quot; 在Vim窗口的右下角显示一个完整的命令已经完成的部分。比如说你键入&quot;2f&quot;,Vim就会在你键入下一个要查找的字符之前显示已经键入的&quot;2f&quot;。一旦你接下来再键入一个字符比如&quot;w&quot;,那么一个完整的命令&quot;2fw&quot;就会被Vim 执行,同时刚才显示的&quot;2f&quot;也将消失。</span><br><span class="line">set showcmd</span><br><span class="line"></span><br><span class="line">&quot; 语法高亮</span><br><span class="line">syntax on</span><br><span class="line"></span><br><span class="line">&quot; 显示行号</span><br><span class="line">set nu</span><br><span class="line"></span><br><span class="line">&quot; 显示空格和TAB</span><br><span class="line">set list</span><br><span class="line">set listchars=tab:&gt;-,trail:-</span><br><span class="line"></span><br><span class="line">&quot; 凸显当前行</span><br><span class="line">set cursorline</span><br><span class="line"></span><br><span class="line">&quot; 检测文件类型</span><br><span class="line">filetype on</span><br><span class="line"></span><br><span class="line">&quot; 启用鼠标</span><br><span class="line">set mouse=a</span><br><span class="line"></span><br><span class="line">&quot; 配色方案</span><br><span class="line">&quot;colorscheme torte</span><br><span class="line"></span><br><span class="line">&quot; 以下为插件</span><br><span class="line"></span><br><span class="line">&quot; 管理插件的插件pathogen</span><br><span class="line">call pathogen#infect()</span><br><span class="line"></span><br><span class="line">&quot; Powerline</span><br><span class="line">set guifont=PowerlineSymbols\ for\ Powerline</span><br><span class="line">set nocompatible</span><br><span class="line">set laststatus=2</span><br><span class="line">set t_Co=256</span><br><span class="line">let g:Powerline_symbols = &#x27;fancy&#x27;</span><br><span class="line"></span><br><span class="line">&quot; NERDTree</span><br><span class="line">map &lt;F10&gt; :NERDTreeToggle&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">&quot; C的编译和运行 </span><br><span class="line">map &lt;F5&gt; :call CompileRunGcc()&lt;CR&gt; </span><br><span class="line">func! CompileRunGcc() </span><br><span class="line">exec &quot;w&quot; </span><br><span class="line">exec &quot;!gcc % -o %&lt;&quot; </span><br><span class="line">exec &quot;! ./%&lt;&quot; </span><br><span class="line">endfunc </span><br><span class="line"></span><br><span class="line">&quot; C++的编译和运行 </span><br><span class="line">map &lt;F6&gt; :call CompileRunGpp()&lt;CR&gt; </span><br><span class="line">func! CompileRunGpp() </span><br><span class="line">exec &quot;w&quot; </span><br><span class="line">exec &quot;!g++ % -o %&lt;&quot; </span><br><span class="line">exec &quot;! ./%&lt;&quot; </span><br><span class="line">endfunc </span><br></pre></td></tr></table></figure>

<h1 id="插件列表"><a href="#插件列表" class="headerlink" title="插件列表"></a>插件列表</h1><table>
<thead>
<tr>
<th>插件名称</th>
<th align="left">项目地址</th>
<th align="left">教程地址</th>
</tr>
</thead>
<tbody><tr>
<td><code>pathogen</code></td>
<td align="left"><a target="_blank" rel="noopener" href="http://www.vim.org/scripts/script.php?script_id=2332">项目地址</a></td>
<td align="left"><a target="_blank" rel="noopener" href="https://github.com/tpope/vim-pathogen">教程地址</a></td>
</tr>
<tr>
<td><code>NERDTree</code></td>
<td align="left"><a target="_blank" rel="noopener" href="http://www.vim.org/scripts/script.php?script_id=1658">项目地址</a></td>
<td align="left"><a target="_blank" rel="noopener" href="http://my.oschina.net/VASKS/blog/388907?fromerr=ktE2belY">教程地址</a></td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>NSQ环境的搭建和简单的使用</title>
    <url>//2018/07/25/set_nsq_env_and_use/</url>
    <content><![CDATA[<h2 id="NSQ安装说明"><a href="#NSQ安装说明" class="headerlink" title="NSQ安装说明"></a>NSQ安装说明</h2><h3 id="使用docker-compose运行"><a href="#使用docker-compose运行" class="headerlink" title="使用docker-compose运行"></a>使用docker-compose运行</h3><p>如果使用<code>docker-compose</code>的方式运行<code>nsq</code>,首先要保证<code>Consumer</code>要与nsq服务在一个docker网络环境中。<br>如果不能保证在一个网络环境中，则需要从源代码安装。<br>如果要存储<code>nsq</code>的消息，需要在启动<code>nsqd</code>的时候加上<code>--data-path=/data</code>命令，并在<code>docker</code>配置文件中将<code>/data</code>使用<code>-v</code>或<code>--volume</code>命令挂载到本地。<br>使用<code>docker-compose up -d</code>后台运行。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">nsqlookupd:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nsqio/nsq</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">nsq-network</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">nsqlookupd</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;4161:4161&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;4160:4160&quot;</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">/nsqlookupd</span></span><br><span class="line">  <span class="attr">nsqd:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nsqio/nsq</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">nsqlookupd</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">nsqd</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data:/data</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">nsq-network</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;4151:4151&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;4150:4150&quot;</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">/nsqd</span> <span class="string">--broadcast-address=nsqd</span> <span class="string">--lookupd-tcp-address=nsqlookupd:4160</span> <span class="string">--data-path=/data</span></span><br><span class="line">  <span class="attr">nsqadmin:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nsqio/nsq</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">nsqlookupd</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">nsqadmin</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;4171:4171&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">nsq-network</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">/nsqadmin</span> <span class="string">--lookupd-http-address=nsqlookupd:4161</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">nsq-network:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></table></figure>

<h3 id="运行的独立的docker"><a href="#运行的独立的docker" class="headerlink" title="运行的独立的docker"></a>运行的独立的docker</h3><ol>
<li>从dokcer hub拉取最新的镜像<code>docker pull nsqio/nsq</code></li>
<li>运行<code>nsqlookupd</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name lookupd -p 4160:4160 -p 4161:4161 nsqio/nsq /nsqlookupd</span><br></pre></td></tr></table></figure></li>
<li>运行<code>nsqd</code>,需要手动挂载<code>volume</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -v ./data:/data --name nsqd -p 4150:4150 -p 4151:4151 \</span><br><span class="line">    nsqio/nsq /nsqd \</span><br><span class="line">    --broadcast-address=127.0.0.1 \</span><br><span class="line">    --lookupd-tcp-address=127.0.0.1:4160 \</span><br><span class="line">    --data-path=/data</span><br></pre></td></tr></table></figure></li>
<li>运行<code>nsqadmin</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name nsqadmin -p 4171:4171 \</span><br><span class="line">    nsqio/nsq /nsqadmin \</span><br><span class="line">    --lookupd-http-address=127.0.0.1:4161</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="从源代码安装"><a href="#从源代码安装" class="headerlink" title="从源代码安装"></a>从源代码安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/nsqio/nsq $GOPATH/src/github.com/nsqio/nsq</span><br><span class="line">cd $GOPATH/src/github.com/nsqio/nsq</span><br><span class="line">dep ensure</span><br><span class="line">go install</span><br></pre></td></tr></table></figure>

<h4 id="启动nsqlookupd"><a href="#启动nsqlookupd" class="headerlink" title="启动nsqlookupd"></a>启动nsqlookupd</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nsqlookupd</span><br></pre></td></tr></table></figure>
<h4 id="启动nsq"><a href="#启动nsq" class="headerlink" title="启动nsq"></a>启动nsq</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nsqd –lookupd-tcp-address=127.0.0.1:4160 --broadcast-address=127.0.0.1 --data-path=/data </span><br></pre></td></tr></table></figure>

<h4 id="启动nsqadmin"><a href="#启动nsqadmin" class="headerlink" title="启动nsqadmin"></a>启动nsqadmin</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nsqadmin --lookupd-http-address=127.0.0.1:4161</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Docker</tag>
        <tag>Nsq</tag>
      </tags>
  </entry>
  <entry>
    <title>Sqlite创建数据库</title>
    <url>//2015/11/04/sqlite-create-datebase/</url>
    <content><![CDATA[<p>其实很简单，但刚开始一点都不会。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">sqlite test.db</span></span><br><span class="line">SQLite version 2.8.17</span><br><span class="line">Enter &quot;.help&quot; for instructions</span><br><span class="line"><span class="meta prompt_">sqlite&gt; </span><span class="language-bash">.database</span></span><br><span class="line">seq  name             file                                                      </span><br><span class="line">---  ---------  -------------------------</span><br><span class="line">0    main        /home/pi/code/testDB.db</span><br></pre></td></tr></table></figure>
<p>这样就创建成功了。</p>
]]></content>
      <tags>
        <tag>sqlite</tag>
      </tags>
  </entry>
  <entry>
    <title>C#利用VLC播放网络串流</title>
    <url>//2015/11/19/using-vlclib-in-vs/</url>
    <content><![CDATA[<p><a target="_blank" rel="noopener" href="http://www.videolan.org/">VLC的官方网站</a>，VLC的源代码是用C语言实现的。我们这里用<code>C#</code>的封装——nVLC。<br><a target="_blank" rel="noopener" href="http://www.codeproject.com/Articles/109639/nVLC">nVLC</a>。</p>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>在运行本程序之前，请先安装VLC，或者拷贝<code>libvlc.dll</code>、<code>libvlccode.dll</code>和<code>plugins目录</code>到你的</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"><span class="keyword">using</span> Declarations;</span><br><span class="line"><span class="keyword">using</span> Declarations.Enums;</span><br><span class="line"><span class="keyword">using</span> Declarations.Media;</span><br><span class="line"><span class="keyword">using</span> Declarations.Players;</span><br><span class="line"><span class="keyword">using</span> Implementation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">nVLC_Demo_MemoryInputOutput</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Form1</span> : <span class="title">Form</span></span><br><span class="line">    &#123;</span><br><span class="line">        IMediaPlayerFactory m_factory;</span><br><span class="line">        IVideoPlayer m_sourcePlayer;</span><br><span class="line">        IVideoPlayer m_renderPlayer;</span><br><span class="line">        IMemoryInputMedia m_inputMedia;</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">long</span> MicroSecondsInSecomd = <span class="number">1000</span> * <span class="number">1000</span>;</span><br><span class="line">        <span class="built_in">long</span> MicroSecondsBetweenFrame;</span><br><span class="line">        <span class="built_in">long</span> frameCounter;</span><br><span class="line">        FrameData data = <span class="keyword">new</span> FrameData() &#123; DTS = <span class="number">-1</span> &#125;;</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">int</span> DefaultFps = <span class="number">24</span>;</span><br><span class="line">        Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Form1</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            InitializeComponent();</span><br><span class="line">            timer.Tick += <span class="keyword">new</span> EventHandler(timer_Tick);</span><br><span class="line">            timer.Interval = <span class="number">1000</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">timer_Tick</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.Text = m_inputMedia.PendingFramesCount.ToString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnLoad</span>(<span class="params">EventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">base</span>.OnLoad(e);</span><br><span class="line"></span><br><span class="line">            m_factory = <span class="keyword">new</span> MediaPlayerFactory(<span class="literal">true</span>);</span><br><span class="line">            m_sourcePlayer = m_factory.CreatePlayer&lt;IVideoPlayer&gt;();</span><br><span class="line">            m_sourcePlayer.Events.PlayerPlaying += <span class="keyword">new</span> EventHandler(Events_PlayerPlaying);</span><br><span class="line">            m_sourcePlayer.Mute = <span class="literal">true</span>;</span><br><span class="line">            m_renderPlayer = m_factory.CreatePlayer&lt;IVideoPlayer&gt;();</span><br><span class="line">            m_renderPlayer.WindowHandle = panel1.Handle;</span><br><span class="line">            m_inputMedia = m_factory.CreateMedia&lt;IMemoryInputMedia&gt;(MediaStrings.IMEM);</span><br><span class="line">            SetupOutput(m_sourcePlayer.CustomRendererEx);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Events_PlayerPlaying</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            MicroSecondsBetweenFrame = (<span class="built_in">long</span>)(MicroSecondsInSecomd / (m_sourcePlayer.FPS != <span class="number">0</span> ? m_sourcePlayer.FPS : DefaultFps));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SetupOutput</span>(<span class="params">IMemoryRendererEx iMemoryRenderer</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            iMemoryRenderer.SetFormatSetupCallback(OnSetupCallback);</span><br><span class="line">            iMemoryRenderer.SetExceptionHandler(OnErrorCallback);</span><br><span class="line">            iMemoryRenderer.SetCallback(OnNewFrameCallback);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> BitmapFormat <span class="title">OnSetupCallback</span>(<span class="params">BitmapFormat format</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            SetupInput(format);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> BitmapFormat(format.Width, format.Height, ChromaType.RV24);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnErrorCallback</span>(<span class="params">Exception error</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            MessageBox.Show(error.Message);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnNewFrameCallback</span>(<span class="params">PlanarFrame frame</span>)</span></span><br><span class="line">        &#123;          </span><br><span class="line">            data.Data = frame.Planes[<span class="number">0</span>];</span><br><span class="line">            data.DataSize = frame.Lenghts[<span class="number">0</span>];</span><br><span class="line">            data.PTS = frameCounter++ * MicroSecondsBetweenFrame;</span><br><span class="line">            m_inputMedia.AddFrame(data);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="comment">/*m_inputMedia.PendingFramesCount == 10 &amp;&amp; */</span>!m_renderPlayer.IsPlaying)</span><br><span class="line">            &#123;</span><br><span class="line">                m_renderPlayer.Play();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SetupInput</span>(<span class="params">BitmapFormat format</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> streamInfo = <span class="keyword">new</span> StreamInfo();</span><br><span class="line">            streamInfo.Category = StreamCategory.Video;</span><br><span class="line">            streamInfo.Codec = VideoCodecs.BGR24;</span><br><span class="line">            streamInfo.Width = format.Width;</span><br><span class="line">            streamInfo.Height = format.Height;</span><br><span class="line">            streamInfo.Size = format.ImageSize;</span><br><span class="line"></span><br><span class="line">            m_inputMedia.Initialize(streamInfo);</span><br><span class="line">            m_inputMedia.SetExceptionHandler(OnErrorCallback);</span><br><span class="line">            m_renderPlayer.Open(m_inputMedia);           </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OpenSourceMedia</span>(<span class="params"><span class="built_in">string</span> path</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//IMediaFromFile media = m_factory.CreateMedia&lt;IMediaFromFile&gt;(path);</span></span><br><span class="line">            IMedia media = m_factory.CreateMedia&lt;IMedia&gt;(path);</span><br><span class="line">            m_sourcePlayer.Open(media);</span><br><span class="line">            m_sourcePlayer.Play();</span><br><span class="line">            timer.Start();</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">button1_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            OpenSourceMedia(<span class="string">&quot;http://192.168.2.108:8090&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>vlc</tag>
        <tag>CSharp</tag>
      </tags>
  </entry>
  <entry>
    <title>tree命令源码分析</title>
    <url>//2016/03/27/tree_command_source_code_analyze/</url>
    <content><![CDATA[<h1 id="为什么选择tree这个命令？"><a href="#为什么选择tree这个命令？" class="headerlink" title="为什么选择tree这个命令？"></a>为什么选择tree这个命令？</h1><p>学完APUE的前几章，学完了IO和文件与目录，我们可以做点东西出来了。而借鉴别人的程序就是做出东西的选择之一。</p>
<h1 id="如何下载源代码"><a href="#如何下载源代码" class="headerlink" title="如何下载源代码"></a>如何下载源代码</h1><p><a target="_blank" rel="noopener" href="http://mama.indstate.edu/users/ice/tree/src/tree-1.7.0.tgz]">http://mama.indstate.edu/users/ice/tree/src/tree-1.7.0.tgz</a>这个链接可以下载到最新的tree源代码，也可以编译成功。</p>
<h1 id="怎么分析源代码"><a href="#怎么分析源代码" class="headerlink" title="怎么分析源代码"></a>怎么分析源代码</h1><p>这是个很大的问题，暂时我还没有太多的经验 :(</p>
<h1 id="我们的目的"><a href="#我们的目的" class="headerlink" title="我们的目的"></a>我们的目的</h1><p>我们的目的暂时定为搞懂如何遍历所有的目录，并输出。</p>
<h1 id="各部分的作用"><a href="#各部分的作用" class="headerlink" title="各部分的作用"></a>各部分的作用</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tree-1.7.0</span><br><span class="line">├── color.c</span><br><span class="line">├── hash.c</span><br><span class="line">├── html.c</span><br><span class="line">├── INSTALL</span><br><span class="line">├── json.c</span><br><span class="line">├── LICENSE</span><br><span class="line">├── Makefile</span><br><span class="line">├── strverscmp.c</span><br><span class="line">├── tree.c</span><br><span class="line">├── tree.h</span><br><span class="line">├── unix.c</span><br><span class="line">└── xml.c</span><br></pre></td></tr></table></figure>
<p>核心的就是这几个文件。其中<code>unix.c</code>和<code>tree.c</code>是遍历功能的主要函数的所在地。</p>
<h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><figure class="highlight mk"><table><tr><td class="code"><pre><span class="line">prefix = /usr</span><br><span class="line"></span><br><span class="line">CC=gcc</span><br><span class="line"></span><br><span class="line">VERSION=1.7.0</span><br><span class="line">TREE_DEST=tree</span><br><span class="line">BINDIR=$&#123;prefix&#125;/bin</span><br><span class="line">MAN=tree.1</span><br><span class="line">MANDIR=$&#123;prefix&#125;/man/man1</span><br><span class="line">OBJS=tree.o unix.o html.o xml.o json.o hash.o color.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment options below for your particular OS:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Linux defaults:</span></span><br><span class="line">CFLAGS=-ggdb -Wall -DLINUX -D_LARGEFILE64_SOURCE -D_FILE_OFFSET_BITS=64</span><br><span class="line"><span class="comment">#CFLAGS=-O4 -Wall  -DLINUX -D_LARGEFILE64_SOURCE -D_FILE_OFFSET_BITS=64</span></span><br><span class="line"><span class="comment">#LDFLAGS=-s</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:    tree</span></span><br><span class="line"></span><br><span class="line"><span class="section">tree:   <span class="variable">$(OBJS)</span></span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(LDFLAGS)</span> -o <span class="variable">$(TREE_DEST)</span> <span class="variable">$(OBJS)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(OBJS)</span>: %.o:   %.c tree.h</span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    if [ -x <span class="variable">$(TREE_DEST)</span> ]; then rm <span class="variable">$(TREE_DEST)</span>; fi</span><br><span class="line">    if [ -f tree.o ]; then rm *.o; fi</span><br><span class="line">    rm -f *~</span><br><span class="line"></span><br><span class="line"><span class="section">install: tree</span></span><br><span class="line">    install -d <span class="variable">$(BINDIR)</span></span><br><span class="line">    install -d <span class="variable">$(MANDIR)</span></span><br><span class="line">    if [ -e <span class="variable">$(TREE_DEST)</span> ]; then \</span><br><span class="line">        install <span class="variable">$(TREE_DEST)</span> <span class="variable">$(BINDIR)</span>/<span class="variable">$(TREE_DEST)</span>; \</span><br><span class="line">    fi</span><br><span class="line">    install doc/<span class="variable">$(MAN)</span> <span class="variable">$(MANDIR)</span>/<span class="variable">$(MAN)</span></span><br><span class="line"></span><br><span class="line"><span class="section">distclean:</span></span><br><span class="line">    if [ -f tree.o ]; then rm *.o; fi</span><br><span class="line">    rm -f *~</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="section">dist:   distclean</span></span><br><span class="line">    tar zcf ../tree-<span class="variable">$(VERSION)</span>.tgz -C .. `cat .tarball`</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="核心程序-遍历目录"><a href="#核心程序-遍历目录" class="headerlink" title="核心程序-遍历目录"></a>核心程序-遍历目录</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//存储文件和文件夹信息的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">info</span> &#123;</span></span><br><span class="line">  <span class="type">char</span> *name;   /</span><br><span class="line">  <span class="type">char</span> *lnk;</span><br><span class="line">  <span class="type">bool</span> isdir;</span><br><span class="line">  <span class="type">bool</span> issok;</span><br><span class="line">  <span class="type">bool</span> isfifo;</span><br><span class="line">  <span class="type">bool</span> isexe;</span><br><span class="line">  <span class="type">bool</span> orphan;</span><br><span class="line">  <span class="type">mode_t</span> mode, lnkmode;</span><br><span class="line">  <span class="type">uid_t</span> uid;</span><br><span class="line">  <span class="type">gid_t</span> gid;</span><br><span class="line">  <span class="type">off_t</span> size;</span><br><span class="line">  <span class="type">time_t</span> atime, ctime, mtime;</span><br><span class="line">  <span class="type">dev_t</span> dev;</span><br><span class="line">  <span class="type">ino_t</span> inode;</span><br><span class="line">  <span class="meta">#<span class="keyword">ifdef</span> __EMX__</span></span><br><span class="line">  <span class="type">long</span> attr;</span><br><span class="line">  <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="type">char</span> *err;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">info</span> **<span class="title">child</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">off_t</span> <span class="title function_">unix_listdir</span><span class="params">(<span class="type">char</span> *d, <span class="type">int</span> *dt, <span class="type">int</span> *ft, u_long lev, <span class="type">dev_t</span> dev)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *path;</span><br><span class="line">  <span class="type">bool</span> nlf = FALSE, colored = FALSE;</span><br><span class="line">  <span class="type">long</span> pathsize = <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">info</span> **<span class="title">dir</span>, **<span class="title">sav</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sb</span>;</span></span><br><span class="line">  <span class="type">int</span> n, c;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> ((Level &gt;= <span class="number">0</span>) &amp;&amp; (lev &gt; Level)) &#123;</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>,outfile);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (xdev &amp;&amp; lev == <span class="number">0</span>) &#123;</span><br><span class="line">    stat(d,&amp;sb);</span><br><span class="line">    dev = sb.st_dev;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  sav = dir = read_dir(d,&amp;n);</span><br><span class="line">  <span class="keyword">if</span> (!dir &amp;&amp; n) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(outfile,<span class="string">&quot; [error opening dir]\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!n) &#123;</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>, outfile);</span><br><span class="line">    free_dir(sav);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (flimit &gt; <span class="number">0</span> &amp;&amp; n &gt; flimit) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(outfile,<span class="string">&quot; [%d entries exceeds filelimit, not opening dir]\n&quot;</span>,n);</span><br><span class="line">    free_dir(sav);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cmpfunc) qsort(dir,n,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> _info *), cmpfunc);</span><br><span class="line">  <span class="keyword">if</span> (lev &gt;= maxdirs<span class="number">-1</span>) &#123;</span><br><span class="line">    dirs = xrealloc(dirs,<span class="keyword">sizeof</span>(<span class="type">int</span>) * (maxdirs += <span class="number">1024</span>));</span><br><span class="line">    <span class="built_in">memset</span>(dirs+(maxdirs<span class="number">-1024</span>), <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">1024</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  dirs[lev] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (!*(dir+<span class="number">1</span>)) dirs[lev] = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">fprintf</span>(outfile,<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  path = <span class="built_in">malloc</span>(pathsize=<span class="number">4096</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(*dir) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!noindent) indent(lev);</span><br><span class="line"></span><br><span class="line">    fillinfo(path,*dir);</span><br><span class="line">    <span class="keyword">if</span> (path[<span class="number">0</span>] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">      path[<span class="number">0</span>] = <span class="string">&#x27;[&#x27;</span>;</span><br><span class="line">      <span class="built_in">fprintf</span>(outfile, <span class="string">&quot;%s]  &quot;</span>,path);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (colorize) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((*dir)-&gt;lnk &amp;&amp; linktargetcolor) colored = color((*dir)-&gt;lnkmode,(*dir)-&gt;name,(*dir)-&gt;orphan,FALSE);</span><br><span class="line">      <span class="keyword">else</span> colored = color((*dir)-&gt;mode,(*dir)-&gt;name,(*dir)-&gt;orphan,FALSE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (fflag) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">sizeof</span>(<span class="type">char</span>) * (<span class="built_in">strlen</span>(d)+<span class="built_in">strlen</span>((*dir)-&gt;name)+<span class="number">2</span>) &gt; pathsize)</span><br><span class="line">    path=xrealloc(path,pathsize=(<span class="keyword">sizeof</span>(<span class="type">char</span>) * (<span class="built_in">strlen</span>(d)+<span class="built_in">strlen</span>((*dir)-&gt;name)+<span class="number">1024</span>)));</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(d,<span class="string">&quot;/&quot;</span>)) <span class="built_in">sprintf</span>(path,<span class="string">&quot;%s%s&quot;</span>,d,(*dir)-&gt;name);</span><br><span class="line">      <span class="keyword">else</span> <span class="built_in">sprintf</span>(path,<span class="string">&quot;%s/%s&quot;</span>,d,(*dir)-&gt;name);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">sizeof</span>(<span class="type">char</span>) * (<span class="built_in">strlen</span>((*dir)-&gt;name)+<span class="number">1</span>) &gt; pathsize)</span><br><span class="line">    path=xrealloc(path,pathsize=(<span class="keyword">sizeof</span>(<span class="type">char</span>) * (<span class="built_in">strlen</span>((*dir)-&gt;name)+<span class="number">1024</span>)));</span><br><span class="line">      <span class="built_in">sprintf</span>(path,<span class="string">&quot;%s&quot;</span>,(*dir)-&gt;name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printit(path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (colored) <span class="built_in">fprintf</span>(outfile,<span class="string">&quot;%s&quot;</span>,endcode);</span><br><span class="line">    <span class="keyword">if</span> (Fflag &amp;&amp; !(*dir)-&gt;lnk) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((c = Ftype((*dir)-&gt;mode))) fputc(c, outfile);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((*dir)-&gt;lnk) &#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(outfile,<span class="string">&quot; -&gt; &quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (colorize) colored = color((*dir)-&gt;lnkmode,(*dir)-&gt;lnk,(*dir)-&gt;orphan,TRUE);</span><br><span class="line">      printit((*dir)-&gt;lnk);</span><br><span class="line">      <span class="keyword">if</span> (colored) <span class="built_in">fprintf</span>(outfile,<span class="string">&quot;%s&quot;</span>,endcode);</span><br><span class="line">      <span class="keyword">if</span> (Fflag) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((c = Ftype((*dir)-&gt;lnkmode))) fputc(c, outfile);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((*dir)-&gt;isdir) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((*dir)-&gt;lnk) &#123;</span><br><span class="line">    <span class="keyword">if</span> (lflag &amp;&amp; !(xdev &amp;&amp; dev != (*dir)-&gt;dev)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (findino((*dir)-&gt;inode,(*dir)-&gt;dev)) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(outfile,<span class="string">&quot;  [recursive, not followed]&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        saveino((*dir)-&gt;inode, (*dir)-&gt;dev);</span><br><span class="line">        <span class="keyword">if</span> (*(*dir)-&gt;lnk == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">          listdir((*dir)-&gt;lnk,dt,ft,lev+<span class="number">1</span>,dev);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">strlen</span>(d)+<span class="built_in">strlen</span>((*dir)-&gt;lnk)+<span class="number">2</span> &gt; pathsize) path=xrealloc(path,pathsize=(<span class="built_in">strlen</span>(d)+<span class="built_in">strlen</span>((*dir)-&gt;name)+<span class="number">1024</span>));</span><br><span class="line">          <span class="keyword">if</span> (fflag &amp;&amp; !<span class="built_in">strcmp</span>(d,<span class="string">&quot;/&quot;</span>)) <span class="built_in">sprintf</span>(path,<span class="string">&quot;%s%s&quot;</span>,d,(*dir)-&gt;lnk);</span><br><span class="line">          <span class="keyword">else</span> <span class="built_in">sprintf</span>(path,<span class="string">&quot;%s/%s&quot;</span>,d,(*dir)-&gt;lnk);</span><br><span class="line">          listdir(path,dt,ft,lev+<span class="number">1</span>,dev);</span><br><span class="line">        &#125;</span><br><span class="line">        nlf = TRUE;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(xdev &amp;&amp; dev != (*dir)-&gt;dev)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(d)+<span class="built_in">strlen</span>((*dir)-&gt;name)+<span class="number">2</span> &gt; pathsize) path=xrealloc(path,pathsize=(<span class="built_in">strlen</span>(d)+<span class="built_in">strlen</span>((*dir)-&gt;name)+<span class="number">1024</span>));</span><br><span class="line">    <span class="keyword">if</span> (fflag &amp;&amp; !<span class="built_in">strcmp</span>(d,<span class="string">&quot;/&quot;</span>)) <span class="built_in">sprintf</span>(path,<span class="string">&quot;%s%s&quot;</span>,d,(*dir)-&gt;name);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">sprintf</span>(path,<span class="string">&quot;%s/%s&quot;</span>,d,(*dir)-&gt;name);</span><br><span class="line">    saveino((*dir)-&gt;inode, (*dir)-&gt;dev);</span><br><span class="line">    listdir(path,dt,ft,lev+<span class="number">1</span>,dev);</span><br><span class="line">    nlf = TRUE;</span><br><span class="line">      &#125;</span><br><span class="line">      *dt += <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> *ft += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (*(dir+<span class="number">1</span>) &amp;&amp; !*(dir+<span class="number">2</span>)) dirs[lev] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (nlf) nlf = FALSE;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">fprintf</span>(outfile,<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    dir++;</span><br><span class="line">  &#125;</span><br><span class="line">  dirs[lev] = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">free</span>(path);</span><br><span class="line">  free_dir(sav);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">off_t</span> <span class="title function_">unix_rlistdir</span><span class="params">(<span class="type">char</span> *d, <span class="type">int</span> *dt, <span class="type">int</span> *ft, u_long lev, <span class="type">dev_t</span> dev)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">info</span> **<span class="title">dir</span>;</span></span><br><span class="line">  <span class="type">off_t</span> size = <span class="number">0</span>;</span><br><span class="line">  <span class="type">char</span> *err;</span><br><span class="line">  </span><br><span class="line">  dir = getfulltree(d, lev, dev, &amp;size, &amp;err);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(dirs, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>) * maxdirs);</span><br><span class="line"></span><br><span class="line">  r_listdir(dir, d, dt, ft, lev);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">r_listdir</span><span class="params">(<span class="keyword">struct</span> _info **dir, <span class="type">char</span> *d, <span class="type">int</span> *dt, <span class="type">int</span> *ft, u_long lev)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *path;</span><br><span class="line">  <span class="type">long</span> pathsize = <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">info</span> **<span class="title">sav</span> =</span> dir;</span><br><span class="line">  <span class="type">bool</span> nlf = FALSE, colored = FALSE;</span><br><span class="line">  <span class="type">int</span> c;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (dir == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  dirs[lev] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (!*(dir+<span class="number">1</span>)) dirs[lev] = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">fprintf</span>(outfile,<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  path = <span class="built_in">malloc</span>(pathsize=<span class="number">4096</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(*dir) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!noindent) indent(lev);</span><br><span class="line">    </span><br><span class="line">    fillinfo(path,*dir);</span><br><span class="line">    <span class="keyword">if</span> (path[<span class="number">0</span>] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">      path[<span class="number">0</span>] = <span class="string">&#x27;[&#x27;</span>;</span><br><span class="line">      <span class="built_in">fprintf</span>(outfile, <span class="string">&quot;%s]  &quot;</span>,path);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (colorize) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((*dir)-&gt;lnk &amp;&amp; linktargetcolor) colored = color((*dir)-&gt;lnkmode,(*dir)-&gt;name,(*dir)-&gt;orphan,FALSE);</span><br><span class="line">      <span class="keyword">else</span> colored = color((*dir)-&gt;mode,(*dir)-&gt;name,(*dir)-&gt;orphan,FALSE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (fflag) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">sizeof</span>(<span class="type">char</span>) * (<span class="built_in">strlen</span>(d)+<span class="built_in">strlen</span>((*dir)-&gt;name)+<span class="number">2</span>) &gt; pathsize)</span><br><span class="line">    path=xrealloc(path,pathsize=(<span class="keyword">sizeof</span>(<span class="type">char</span>) * (<span class="built_in">strlen</span>(d)+<span class="built_in">strlen</span>((*dir)-&gt;name)+<span class="number">1024</span>)));</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(d,<span class="string">&quot;/&quot;</span>)) <span class="built_in">sprintf</span>(path,<span class="string">&quot;%s%s&quot;</span>,d,(*dir)-&gt;name);</span><br><span class="line">      <span class="keyword">else</span> <span class="built_in">sprintf</span>(path,<span class="string">&quot;%s/%s&quot;</span>,d,(*dir)-&gt;name);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">sizeof</span>(<span class="type">char</span>) * (<span class="built_in">strlen</span>((*dir)-&gt;name)+<span class="number">1</span>) &gt; pathsize)</span><br><span class="line">    path=xrealloc(path,pathsize=(<span class="keyword">sizeof</span>(<span class="type">char</span>) * (<span class="built_in">strlen</span>((*dir)-&gt;name)+<span class="number">1024</span>)));</span><br><span class="line">      <span class="built_in">sprintf</span>(path,<span class="string">&quot;%s&quot;</span>,(*dir)-&gt;name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    printit(path);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (colored) <span class="built_in">fprintf</span>(outfile,<span class="string">&quot;%s&quot;</span>,endcode);</span><br><span class="line">    <span class="keyword">if</span> (Fflag &amp;&amp; !(*dir)-&gt;lnk) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((c = Ftype((*dir)-&gt;mode))) fputc(c, outfile);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((*dir)-&gt;lnk) &#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(outfile,<span class="string">&quot; -&gt; &quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (colorize) colored = color((*dir)-&gt;lnkmode,(*dir)-&gt;lnk,(*dir)-&gt;orphan,TRUE);</span><br><span class="line">      printit((*dir)-&gt;lnk);</span><br><span class="line">      <span class="keyword">if</span> (colored) <span class="built_in">fprintf</span>(outfile,<span class="string">&quot;%s&quot;</span>,endcode);</span><br><span class="line">      <span class="keyword">if</span> (Fflag) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((c = Ftype((*dir)-&gt;lnkmode))) fputc(c, outfile);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((*dir)-&gt;err) &#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(outfile,<span class="string">&quot; [%s]&quot;</span>, (*dir)-&gt;err);</span><br><span class="line">      <span class="built_in">free</span>((*dir)-&gt;err);</span><br><span class="line">      (*dir)-&gt;err = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((*dir)-&gt;child) &#123;</span><br><span class="line">      <span class="keyword">if</span> (fflag) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(d)+<span class="built_in">strlen</span>((*dir)-&gt;name)+<span class="number">2</span> &gt; pathsize) path=xrealloc(path,pathsize=(<span class="built_in">strlen</span>(d)+<span class="built_in">strlen</span>((*dir)-&gt;name)+<span class="number">1024</span>));</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(d,<span class="string">&quot;/&quot;</span>)) <span class="built_in">sprintf</span>(path,<span class="string">&quot;%s%s&quot;</span>,d,(*dir)-&gt;name);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">sprintf</span>(path,<span class="string">&quot;%s/%s&quot;</span>,d,(*dir)-&gt;name);</span><br><span class="line">      &#125;</span><br><span class="line">      r_listdir((*dir)-&gt;child, fflag? path : <span class="literal">NULL</span>, dt, ft, lev+<span class="number">1</span>);</span><br><span class="line">      nlf = TRUE;</span><br><span class="line">      *dt += <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> ((*dir)-&gt;isdir) *dt += <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">else</span> *ft += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*(dir+<span class="number">1</span>) &amp;&amp; !*(dir+<span class="number">2</span>)) dirs[lev] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (nlf) nlf = FALSE;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">fprintf</span>(outfile,<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    dir++;</span><br><span class="line">  &#125;</span><br><span class="line">  dirs[lev] = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">free</span>(path);</span><br><span class="line">  free_dir(sav);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Python控制树莓派的GPIO(1)</title>
    <url>//2015/10/18/%E4%BD%BF%E7%94%A8Python%E6%8E%A7%E5%88%B6%E6%A0%91%E8%8E%93%E6%B4%BE%E7%9A%84GPIO-1/</url>
    <content><![CDATA[<h3 id="使用的树莓派2B"><a href="#使用的树莓派2B" class="headerlink" title="使用的树莓派2B"></a>使用的树莓派2B</h3><p>通过PRI.GPIO来实现Python控制树莓派的GPIO。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在<a target="_blank" rel="noopener" href="http://pythonhosted.org/RPIO/">官方文档</a>中给出了三种按章方式。分别是</p>
<h3 id="用-easy-install或者pip来安装："><a href="#用-easy-install或者pip来安装：" class="headerlink" title="用 easy_install或者pip来安装："></a>用 <code>easy_install</code>或者<code>pip</code>来安装：</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install python-setuptools</span><br><span class="line">sudo easy_install -U RPIO</span><br></pre></td></tr></table></figure>

<h3 id="从Github上克隆然后安装"><a href="#从Github上克隆然后安装" class="headerlink" title="从Github上克隆然后安装"></a>从Github上克隆然后安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/metachris/RPIO.git</span><br><span class="line">cd RPIO</span><br><span class="line">sudo python setup.py install</span><br></pre></td></tr></table></figure>

<h3 id="从Github或者别处下载安装"><a href="#从Github或者别处下载安装" class="headerlink" title="从Github或者别处下载安装"></a>从Github或者别处下载安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -L https://github.com/metachris/RPIO/archive/master.tar.gz | tar -xz</span><br><span class="line">cd RPIO-master</span><br><span class="line">sudo python setup.py install</span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><img src="http://ww1.sinaimg.cn/mw690/ae94c92cgw1ex5fscddh0j20fi0bigqz.jpg" alt="树莓派引脚图"><br><img src="http://ww3.sinaimg.cn/mw690/ae94c92cgw1ex6qv7sjpoj20jq0c6gps.jpg" alt="树莓派2B引脚图"></p>
<p>这是用wiringPi生成的引脚图，用wiringPi控制GPIO会在以后写。</p>
<p>树莓派的GPIO大致可以分为INPUT和OUTPUT两种状态。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> RPIO</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置为输入位无上拉</span></span><br><span class="line">RPIO.setup(<span class="number">7</span>, RPIO.IN)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置为输出位有上拉. 可以设置为</span></span><br><span class="line"><span class="comment"># PUD_UP(上拉), PUD_DOWN(下拉) or PUD_OFF (default)</span></span><br><span class="line">RPIO.setup(<span class="number">7</span>, RPIO.IN, pull_up_down=RPIO.PUD_UP)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取GPIO7的输入状态</span></span><br><span class="line">input_value = RPIO.<span class="built_in">input</span>(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置GPIO为输出位</span></span><br><span class="line">RPIO.setup(<span class="number">8</span>, RPIO.OUT)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置GPIO8为高电位</span></span><br><span class="line">RPIO.output(<span class="number">8</span>, <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置为输出位并给予一个初始值</span></span><br><span class="line">RPIO.setup(<span class="number">8</span>, RPIO.OUT, initial=RPIO.LOW)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 改变为BOARD编号模式</span></span><br><span class="line">RPIO.setmode(RPIO.BOARD)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在通道17上设置软件上拉</span></span><br><span class="line">RPIO.set_pullupdn(<span class="number">17</span>, RPIO.PUD_UP)  <span class="comment"># new in RPIO</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得通道8的设置(IN、OUT、ALTo)</span></span><br><span class="line">RPIO.gpio_function(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复位所有由该程序设置过的通道，</span></span><br><span class="line"><span class="comment"># 并清除 GPIO 中断接口</span></span><br><span class="line">RPIO.cleanup()</span><br></pre></td></tr></table></figure>

<p>照着上一篇文章写的那样做，并不能成功。因为RPIO的最后一个release版本是2013年的，并不支持我的树莓派2B。</p>
<p>如果想在树莓派2B上运行，需要做这些工作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install rpi.gpio</span><br><span class="line">sudo pip freeze</span><br></pre></td></tr></table></figure>
<p>如果有一行<code>RPi.GPIO==0.511</code>就说明安装成功了。</p>
<p>然后我们在新建<code>led.py</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> RPi.GPIO <span class="keyword">as</span> GPIO</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">LED = <span class="number">4</span> </span><br><span class="line"></span><br><span class="line">GPIO.setmode(GPIO.BCM)</span><br><span class="line">GPIO.setup(LED, GPIO.OUT)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;结束程序，请按CTRL+C&quot;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	<span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">		GPIO.output(LED, <span class="literal">False</span>)</span><br><span class="line">		<span class="comment">#延时1s</span></span><br><span class="line">		time.sleep(<span class="number">1</span>)</span><br><span class="line">		GPIO.output(LED, <span class="literal">True</span>)</span><br><span class="line">		time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">except</span> KeyboardInterrupt: <span class="comment"># 如果程序被CTRL+C结束</span></span><br><span class="line">	GPIO.cleanup()</span><br></pre></td></tr></table></figure>

<p>前几天搞不懂GPIO.setmode函数中的参数GPIO.BCM和GPIO.BOARD指的是什么。<br>后来知道BOARD指的是主板引脚编号，而BCM指的是BCM芯片的引脚编号，在本文的配图中有。</p>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>树莓派</tag>
        <tag>PRI.GPIO</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Xshell进行上传和下载</title>
    <url>//2015/10/12/%E4%BD%BF%E7%94%A8Xshell%E8%BF%9B%E8%A1%8C%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/</url>
    <content><![CDATA[<p>在日常使用Xshell进行远程登录的时候，我们想通过Xshell在Windows和Linux之间便捷的进行文件传输，这时候我们可以使用 <code>rz</code> 或 <code>sz</code> 命令。</p>
<p>在树莓派上安装<code>rz</code>和<code>sz</code>命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install lrzsz</span><br></pre></td></tr></table></figure>


<p>下载某个文件或文件夹</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sz filename</span><br></pre></td></tr></table></figure>

<p><code>rz</code>直接把文件拖到Xshell上就可以了.</p>
<p><code>sz</code>和<code>rz</code>的帮助文档</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rz version 0.12.21rc</span><br><span class="line">Usage: rz [options] [filename.if.xmodem]</span><br><span class="line">Receive files with ZMODEM/YMODEM/XMODEM protocol</span><br><span class="line">    (X) = option applies to XMODEM only</span><br><span class="line">    (Y) = option applies to YMODEM only</span><br><span class="line">    (Z) = option applies to ZMODEM only</span><br><span class="line">  -+, --append                append to existing files</span><br><span class="line">  -a, --ascii                 ASCII transfer (change CR/LF to LF)</span><br><span class="line">  -b, --binary                binary transfer</span><br><span class="line">  -B, --bufsize N             buffer N bytes (N==auto: buffer whole file)</span><br><span class="line">  -c, --with-crc              Use 16 bit CRC (X)</span><br><span class="line">  -C, --allow-remote-commands allow execution of remote commands (Z)</span><br><span class="line">  -D, --null                  write all received data to /dev/null</span><br><span class="line">      --delay-startup N       sleep N seconds before doing anything</span><br><span class="line">  -e, --escape                Escape control characters (Z)</span><br><span class="line">  -E, --rename                rename any files already existing</span><br><span class="line">      --errors N              generate CRC error every N bytes (debugging)</span><br><span class="line">  -h, --help                  Help, print this usage message</span><br><span class="line">  -m, --min-bps N             stop transmission if BPS below N</span><br><span class="line">  -M, --min-bps-time N          for at least N seconds (default: 120)</span><br><span class="line">  -O, --disable-timeouts      disable timeout code, wait forever for data</span><br><span class="line">      --o-sync                open output file(s) in synchronous write mode</span><br><span class="line">  -p, --protect               protect existing files</span><br><span class="line">  -q, --quiet                 quiet, no progress reports</span><br><span class="line">  -r, --resume                try to resume interrupted file transfer (Z)</span><br><span class="line">  -R, --restricted            restricted, more secure mode</span><br><span class="line">  -s, --stop-at &#123;HH:MM|+N&#125;    stop transmission at HH:MM or in N seconds</span><br><span class="line">  -S, --timesync              request remote time (twice: set local time)</span><br><span class="line">      --syslog[=off]          turn syslog on or off, if possible</span><br><span class="line">  -t, --timeout N             set timeout to N tenths of a second</span><br><span class="line">      --tcp-server            open socket, wait for connection (Z)</span><br><span class="line">      --tcp-client ADDR:PORT  open socket, connect to ... (Z)</span><br><span class="line">  -u, --keep-uppercase        keep upper case filenames</span><br><span class="line">  -U, --unrestrict            disable restricted mode (if allowed to)</span><br><span class="line">  -v, --verbose               be verbose, provide debugging information</span><br><span class="line">  -w, --windowsize N          Window is N bytes (Z)</span><br><span class="line">  -X  --xmodem                use XMODEM protocol</span><br><span class="line">  -y, --overwrite             Yes, clobber existing file if any</span><br><span class="line">      --ymodem                use YMODEM protocol</span><br><span class="line">  -Z, --zmodem                use ZMODEM protocol</span><br><span class="line"></span><br><span class="line">short options use the same arguments as the long ones</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>Xshell</tag>
      </tags>
  </entry>
  <entry>
    <title>关于树莓派lirc的配置</title>
    <url>//2015/10/31/%E5%85%B3%E4%BA%8E%E6%A0%91%E8%8E%93%E6%B4%BElirc%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="记录原因"><a href="#记录原因" class="headerlink" title="记录原因"></a>记录原因</h2><p>这是我正在DIY的一个<a target="_blank" rel="noopener" href="https://github.com/kaiiak/NineSky/blob/master/README.md">基于树莓派智能家居</a>的过程中，配置lirc的一个小问题的总结。<br>因为在网上搜索到的类似的博客给出的解决方式都不可行，所以打算记录下来，方便后来者。</p>
<h2 id="事情的起因"><a href="#事情的起因" class="headerlink" title="事情的起因"></a>事情的起因</h2><p>安装lirc——一个开源的红外控制的库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install lirc</span><br></pre></td></tr></table></figure>
<p>配置到这一步时，网络上给出的下一步都是在</p>
<blockquote>
<p>加载内核模块</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo modprobe lirc_rpi gpio_in_pin=23gpio_out_pin=24</span><br></pre></td></tr></table></figure>
<p>然而照着做以后，并不能成功。</p>
</blockquote>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>配置树莓派的lirc，需要在<code>/boot/config.txt</code>中添加，在<a target="_blank" rel="noopener" href="https://github.com/raspberrypi/firmware/blob/master/boot/overlays/README">这里</a>找到的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dtoverlay=lirc-rpi,gpio_in_pin=23,gpio_out_pin=24</span><br></pre></td></tr></table></figure>
<p>然后重启就可以了。</p>
<p>加载lir_rpi内核模块</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo modprobe lirc_rpi</span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mode2 -d /dev/lirc0</span><br></pre></td></tr></table></figure>
<p>现在就会看到一大串space和pulse交替产生。</p>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>树莓派</tag>
        <tag>lirc</tag>
      </tags>
  </entry>
  <entry>
    <title>打算买个小米路由刷openWRT</title>
    <url>//2015/08/05/%E6%89%93%E7%AE%97%E4%B9%B0%E4%B8%AA%E6%9E%81%E8%B7%AF%E7%94%B1%E5%88%B7openWRT/</url>
    <content><![CDATA[<p>主要是因为学校的天翼客户端不能用路由器，这样的话我的树莓派就没法用了。<br>所以买个路由器刷openWRT，然后破解客户端，在openWRT上编写破解程序用路由器分享wifi。毕竟动态域名也是要一个外网ip的。<br>哈哈～<br>这是想象之中的，但愿我能坚持下来吧。<br>Thx～<br>然而在极路由和小米路由器mini之间我选择了小米路由mini。<br>毕竟第一次折腾openWRT，不是很敢自己刷。可以直接在他们定制的openWRT系统上折腾。</p>
]]></content>
      <tags>
        <tag>openWRT</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派直连电脑二三事</title>
    <url>//2015/10/11/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%9B%B4%E8%BF%9E%E7%94%B5%E8%84%91%E4%BA%8C%E4%B8%89%E4%BA%8B/</url>
    <content><![CDATA[<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>因为在学校的实验室网络不是很稳定，所以树莓派一直不能直接用网线连接网络。而且wpa_supplication真的很不稳定，莫名其妙的罢工好几次，每次只能重新写镜像。<br>种种原因选择了直连电脑的方法来联网,而我的电脑连接的是信号很弱的无线网，无奈条件太艰苦。</p>
<p>需要额外准备的东西就是一根直通线啦。好啦，接下来就是设置的时间了。</p>
<p>首先打开网络与共享中心-&gt;更改适配器设置-&gt;右击无线网络连接-&gt;属性-&gt;共享。<br>如图：<br>        <img src="http://ww2.sinaimg.cn/mw690/ae94c92cgw1ewxgxexpm2j20ah0camy8.jpg" alt="无线网络属性共享"><br>根据别人写的教程，做到这步就可以实现远程登录树莓派和树莓派访问外网了。但是我只能实现远程登录树莓派，访问外网实现不了。经过试验，是没有配置DNS服务器的原因，在本地连接的IPV4属性中添加DNS服务器就可以了。这里我使用的是OpenDNS。<br>        <img src="http://ww3.sinaimg.cn/mw690/ae94c92cgw1ewxgxrj8stj20bi0bxgn5.jpg" alt="IPV4属性"></p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>windows实现直连访问的技术叫做ICS，百科上的解释如下：</p>
<blockquote>
<p>ICS即Internet连接共享(InternetConnectionSharing)的英文简称，是Windows系统针对家庭网络或小型的Intranet网络提供的一种Internet连接共享服务。它实际上相当于一种网络地址转换器，所谓网络地址转换器就是当数据包向前传递的过程中，可以转换数据包中的IP地址和TCP&#x2F;UDP端口等地址信息。有了网络地址转换器，家庭网络或小型的办公网络中的电脑就可以使用私有地址，并且通过网络地址转换器将私有地址转换成ISP分配的单一的公用IP地址从而实现对Internet的连接。ICS方式也称之为Internet转换连接。</p>
</blockquote>
<p>这里是<a target="_blank" rel="noopener" href="http://windows.microsoft.com/zh-cn/windows/using-internet-connection-sharing#1TC=windows-7">在微软的官方帮助文档</a>中对ICS的介绍，使用它也可以连接路由器使用。</p>
<h3 id="推荐阿里和中科大的的树莓派镜像"><a href="#推荐阿里和中科大的的树莓派镜像" class="headerlink" title="推荐阿里和中科大的的树莓派镜像"></a>推荐阿里和中科大的的树莓派镜像</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deb http://mirrors.aliyun.com/raspbian/raspbian/   wheezy main contrib non-free rpi</span><br><span class="line">deb http://mirrors.ustc.edu.cn/raspbian/raspbian/   wheezy main contrib non-free rpi</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title>第一篇</title>
    <url>//2015/07/30/%E7%AC%AC%E4%B8%80%E7%AF%87/</url>
    <content><![CDATA[<h2 id="第一次在github上写博客"><a href="#第一次在github上写博客" class="headerlink" title="第一次在github上写博客"></a>第一次在github上写博客</h2><p>哈哈，有点小兴奋呢</p>
<h3 id="测试下代码高亮"><a href="#测试下代码高亮" class="headerlink" title="测试下代码高亮"></a>测试下代码高亮</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最近在做ACM和准备电赛，多多加油！</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>编译apue.3e并解决编译错误</title>
    <url>//2016/01/28/%E7%BC%96%E8%AF%91apue-3e%E5%B9%B6%E8%A7%A3%E5%86%B3%E7%BC%96%E8%AF%91%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<h2 id="下载源代码"><a href="#下载源代码" class="headerlink" title="下载源代码"></a>下载源代码</h2><p>我们在学习APUE这本书的时候，总会见到书上的源代码总会引用<code>apue.h</code>这个头文件，这个并不是Linux系统自带的。所以，我们要自己编译。<br>我们在<a target="_blank" rel="noopener" href="http://www.apuebook.com/src.3e.tar.gz">http://www.apuebook.com/src.3e.tar.gz</a>下载源代码后，解压。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf src.3e.tar.gz</span><br></pre></td></tr></table></figure>
<p>然后编译</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo make</span><br></pre></td></tr></table></figure>
<p>但是在编译过程中，会出现错误，错误部分的log是这样的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -ansi -I../include -Wall -DLINUX -D_GNU_SOURCE  badexit2.c -o badexit2  -L../lib -lapue -pthread -lrt -lbsd</span><br><span class="line">/usr/bin/ld: cannot find -lbsd</span><br><span class="line">collect2: ld returned 1 exit status</span><br><span class="line">Makefile:31: recipe for target &#x27;badexit2&#x27; failed</span><br><span class="line">make[1]: *** [badexit2] Error 1</span><br><span class="line">make[1]: Leaving directory &#x27;/home/pi/apue.3e/threads&#x27;</span><br><span class="line">Makefile:6: recipe for target &#x27;all&#x27; failed</span><br><span class="line"></span><br><span class="line">make: *** [all] Error 1</span><br></pre></td></tr></table></figure>

<h2 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h2><p>出现这个错误是因为，我们缺少一个库。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get inatall libbsd-dev</span><br></pre></td></tr></table></figure>

<p>安装完成后，重新进行编译.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp ./include/apue.h ./lib/error.c /usr/include</span><br></pre></td></tr></table></figure>
<p>然后，在<code>/usr/include/apue.h</code>的<code>ifdef</code>和<code>endif</code>中间添加<code>#include &quot;error.c&quot;</code>,就可以在编写的程序中，愉快的使用<code>apue.h</code>了。</p>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>APUE</tag>
      </tags>
  </entry>
  <entry>
    <title>解决Yilia主题的subnav中链接的问题</title>
    <url>//2015/07/31/%E8%A7%A3%E5%86%B3Yilia%E4%B8%BB%E9%A2%98%E7%9A%84subnav%E4%B8%AD%E9%93%BE%E6%8E%A5%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="问题说明"><a href="#问题说明" class="headerlink" title="问题说明"></a>问题说明</h2><p>我很喜欢Yilia这个漂亮的主题，但是当我自己用的时候发现在subnav区生成的链接并不是我想要的。比如我的github地址是<code>github.com/kaiiak</code>，但是实际生成的是<code>kaiiak.github.io/github.com/kaiiak</code>。微博地址也是这样，邮箱地址也是。</p>
<h2 id="心路历程"><a href="#心路历程" class="headerlink" title="心路历程"></a>心路历程</h2><p>我一点一点试验嘛，今天一晚上翻来覆去改了有30多次。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">subnav:</span><br><span class="line">  github: &quot;https://github.com/kaiiak&quot;</span><br><span class="line">  weibo:  &quot;http://weibo.com/itkaikai&quot;</span><br><span class="line">  #mail:   &quot;itkaikai@gmail.com&quot;</span><br></pre></td></tr></table></figure>
<p>  这时可以了，我以为是因为链接对齐了呢，可是我把mail那里的<code>#</code>去掉后，发现邮箱那一栏生成的地址还是没变啊。我又陷入了沉思～</p>
<h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>解决的原因是我把git生成的diff看了一遍，发现微博那一栏在没加<code>http://</code>时，生成的html代码是这样的<code>/weibo.com/itkaikai</code>，加了<code>http://</code>后生成的html代码就变成了<code>http://weibo.com/itkaikai</code>了。看到这里，大家一定会明白了。<br>把subnav改成这样子就可以了。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">subnav:</span><br><span class="line">  github: &quot;https://github.com/kaiiak&quot;</span><br><span class="line">  weibo:  &quot;http://weibo.com/itkaikai&quot;</span><br><span class="line">  mail:   &quot;mailto:itkaikai@gmail.com&quot;</span><br></pre></td></tr></table></figure>

<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>把时间花费在打磨工具上有点很吃亏啊，还是等有钱买个vps好了。<br>晚安～</p>
]]></content>
      <tags>
        <tag>Hexo主题</tag>
      </tags>
  </entry>
  <entry>
    <title>通过pylirc实现红外控制</title>
    <url>//2015/11/14/%E9%80%9A%E8%BF%87pylirc%E5%AE%9E%E7%8E%B0%E7%BA%A2%E5%A4%96%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h2 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h2><p>在2005年更新的官方文档，点击<a target="_blank" rel="noopener" href="http://bazaar.launchpad.net/~rockstar/pylirc2/trunk/view/head:/doc/simple.txt">这里</a>.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pyLirc v0.0.5</span><br><span class="line"></span><br><span class="line">Introduction</span><br><span class="line"></span><br><span class="line">pyLirc is a module for Python that interacts with lirc to give </span><br><span class="line">Python programs the ability to receive commands from remote </span><br><span class="line">controls.</span><br><span class="line"></span><br><span class="line">This isn&#x27;t much of documentation, but at least it&#x27;s a start and</span><br><span class="line">there isn&#x27;t much to document right now anyway.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Initialization</span><br><span class="line"></span><br><span class="line">Before you can receive any commands from lirc, you&#x27;ll need to </span><br><span class="line">initialize the module. After importing pyLirc, call the pylirc.init()</span><br><span class="line">function:</span><br><span class="line"></span><br><span class="line">   import pylirc</span><br><span class="line"></span><br><span class="line">   integer = pylirc.init(string name[, string configuration [, integer blocking ]])</span><br><span class="line"></span><br><span class="line">the returnvalue is the returnvalue of lircs client library</span><br><span class="line">lirc_init(), ie a socket, or zero on failure.</span><br><span class="line"></span><br><span class="line">The socket can be used with select.select() to wait for data if you don&#x27;t</span><br><span class="line">want to use blocking. This is especially useful in multithreaded programs</span><br><span class="line">as blocking mode of pylirc will blick all threads, whereas select() will</span><br><span class="line">only block the current and with optional timeout.</span><br><span class="line"></span><br><span class="line">name: the name used for your program in the lirc configuration</span><br><span class="line">file, must be supplied.</span><br><span class="line"></span><br><span class="line">configuration:  a filename to a lirc configuration file in case you wish not to</span><br><span class="line">use lircs default configuration file (usually ~/.lircrc).</span><br><span class="line"></span><br><span class="line">blocking: a flag indicating wether you want blocking mode or not. See also </span><br><span class="line">blocking() and select.select() (latter in python docs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Polling</span><br><span class="line"></span><br><span class="line">If initialization was ok, you can poll lirc for commands. To read any commands</span><br><span class="line">in queue call pylirc.nextcode():</span><br><span class="line"></span><br><span class="line">   list = pylirc.nextcode([integer Exteneded])</span><br><span class="line"></span><br><span class="line">The returnvalue is &#x27;None&#x27;, if no commands was on the queue, or a list</span><br><span class="line">containing the commands read.</span><br><span class="line"></span><br><span class="line">To get the commands one by one enumerate the list:</span><br><span class="line"></span><br><span class="line">   for code in list:</span><br><span class="line">      print code</span><br><span class="line"></span><br><span class="line">If you supply the optional argument Extended as true, code will be a dictionary</span><br><span class="line">otherwise it will be a string (old behaviour).</span><br><span class="line"></span><br><span class="line">The dictionary currently contains:</span><br><span class="line">&quot;config&quot;: The config string from lirc config file - the same string you&#x27;d get in</span><br><span class="line">          non-extended mode.</span><br><span class="line">&quot;repeat&quot;: The repeat count of the buttonpress.</span><br><span class="line">      </span><br><span class="line">Note, that there can still be more commands on queue after a call</span><br><span class="line">to pylirc.nextcode(). You should call it in a loop until you get</span><br><span class="line">&#x27;None&#x27; back.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Exiting</span><br><span class="line"></span><br><span class="line">When you&#x27;re done using pyLirc and before you exit your program you</span><br><span class="line">should clean up:</span><br><span class="line"></span><br><span class="line">   pylirc.exit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Changing mode</span><br><span class="line"></span><br><span class="line">When you initialize pyLirc, you can chose wether you want blocking or</span><br><span class="line">non-blocking mode. Blocking mode means pylirc.nextcode() waits until</span><br><span class="line">there is a command to be read until it returns.</span><br><span class="line">To change mode after initialization, use blocking():</span><br><span class="line"></span><br><span class="line">   success = pylirc.blocking(int)</span><br></pre></td></tr></table></figure>

<h2 id="中文翻译"><a href="#中文翻译" class="headerlink" title="中文翻译"></a>中文翻译</h2><p>自己尝试翻译一下，英语渣渣，有不正确的地方请指正。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pyLirc v0.0.5</span><br><span class="line"></span><br><span class="line">介绍</span><br><span class="line"></span><br><span class="line">pyLirc是一个与LIRC交互给</span><br><span class="line">Python程序从远程接收远程命令的能力</span><br><span class="line">的Python模块。</span><br><span class="line"></span><br><span class="line">这是没有太多的文档，毕竟它是一个新项目，</span><br><span class="line">现在反正没有太多的文档。</span><br><span class="line"></span><br><span class="line">初始化</span><br><span class="line"></span><br><span class="line">在接受来自lirc的命令之前，你应该初始化本模块。在 import pylirc之后，使用 pylirc.inti()函数：</span><br><span class="line">	import pylirc</span><br><span class="line">	integer = pylirc.init(string name[, string configuration [, integer blocking ]])</span><br><span class="line">返回值是客户端库中lirc_init()函数的返回值，是一个socket，如果返回值是0，则初始化失败。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> pylirc</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Buttons</span>:</span><br><span class="line">    SELECT = <span class="number">0</span></span><br><span class="line">    RIGHT = <span class="number">1</span></span><br><span class="line">    DOWN = <span class="number">2</span></span><br><span class="line">    UP = <span class="number">3</span></span><br><span class="line">    LEFT = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, app, conf</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pylirc.init(app, conf, <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;Unable to init pylirc&quot;</span>);</span><br><span class="line">        pylirc.blocking(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">readButton</span>(<span class="params">self</span>):</span><br><span class="line">        btn = pylirc.nextcode()</span><br><span class="line">        <span class="keyword">if</span> btn:</span><br><span class="line">            <span class="keyword">return</span> btn[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>树莓派</tag>
        <tag>pylirc</tag>
      </tags>
  </entry>
</search>
